{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Data_Structure/",
    "result": {"data":{"cur":{"id":"f3762fa5-29bd-524c-9de4-5c98b3099907","html":"<h2 id=\"1-priority-queue-우선순위-큐--heap-힙\" style=\"position:relative;\"><a href=\"#1-priority-queue-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90--heap-%ED%9E%99\" aria-label=\"1 priority queue 우선순위 큐  heap 힙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Priority Queue (우선순위 큐) &#x26; Heap (힙)</h2>\n<ul>\n<li>\n<p>Priority Queue: 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조</p>\n<ul>\n<li>데이터를 우선순위에 따라 처리하고 싶을 때 사용함</li>\n</ul>\n</li>\n<li>\n<p>Priority Queue 구현 방법</p>\n<ol>\n<li>List 이용: 차례로 데이터 삽입 &#x26; 꺼낼 때 우선 순위 비교해서 높은 것부터 꺼냄</li>\n<li>Heap 이용</li>\n</ol>\n</li>\n<li>\n<p>데이터 개수가 N일 때, 구현 방식에 따른 시간 복잡도</p>\n<table>\n<thead>\n<tr>\n<th>우선순위 큐 구현 방식</th>\n<th>삽입 시간</th>\n<th>삭제 시간</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>List</td>\n<td>O(1)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>Heap</td>\n<td>O(logN)</td>\n<td>O(logN)</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>단순히 데이터를 Heap에 넣었다가 모두 꺼내는 작업 = 정렬 작업</p>\n<ul>\n<li>‘힙 정렬’이라고 함</li>\n<li>시간 복잡도: O(NlogN)</li>\n</ul>\n</li>\n<li>\n<p>Heap의 특징</p>\n<ul>\n<li>Heap은 Complete Binary Tree(완전 이진 트리)의 일종</li>\n<li>항상 Root node를 제거함</li>\n<li>Min Heap (최소 힙)\n<ul>\n<li>root 노드가 가장 작은 값을 가짐</li>\n<li>값이 작은 데이터가 우선적으로 제거됨</li>\n</ul>\n</li>\n<li>Max Heap (최대 힙)\n<ul>\n<li>root 노드가 가장 큰 값을 가짐</li>\n<li>값이 큰 데이터가 우선적으로 제거됨</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 Complete Binary Tree (완전 이진 트리)란?\n: root 노드부터 시작해서 왼쪽 child 노드, 오른쪽 child 노드 순으로 데이터가 차례대로 삽입되는 tree를 의미</p>\n</blockquote>\n<ul>\n<li>\n<p><code class=\"language-text\">Min-Heapify()</code>: 최소 힙 구성 함수</p>\n<ul>\n<li>(Bottom-Up) parent 노드로 거슬러 올라가며, parent보다 자신의 값이 더 작은 경우 위치를 교체함</li>\n<li>(Top-Bottom) 더 작은 child 노드로 내려가며, child보다 자신의 값이 더 큰 경우 위치를 교체</li>\n</ul>\n</li>\n<li>\n<p>Heap 연산 시간 복잡도</p>\n<ul>\n<li>새로운 원소가 삽입되었을 때: O(logN)\n<ul>\n<li>leaf node에 추가된 원소 삽입 (heap 높이: logN) -> Bottom-Up <code class=\"language-text\">Heapify()</code></li>\n</ul>\n</li>\n<li>원소가 제거될 때: O(logN)\n<ul>\n<li>root 노드 제거 -> 제거된 root 노드 자리에 leaf 노드 위치시킴 -> Top-Down <code class=\"language-text\">Heapify()</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Min Heap 예시</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq <span class=\"token comment\"># 기본적으로 Min Heap 제공</span>\n\n<span class=\"token comment\"># 오름차순 힙 정렬(Heap Sort)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">heapsort</span><span class=\"token punctuation\">(</span>iterable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    h <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 모든 원소를 차례대로 힙에 삽입</span>\n    <span class=\"token keyword\">for</span> value <span class=\"token keyword\">in</span> iterable<span class=\"token punctuation\">:</span>\n        heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 힙에 삽입된 모든 원소를 차례때로 꺼내어 담기</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> result\n\nresult <span class=\"token operator\">=</span> heapsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\"># [0,1,2,3,4,5,6,7,8,9]</span></code></pre></div>\n<ul>\n<li>Max Heap 예시</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq \n\n<span class=\"token comment\"># 내림차순 힙 정렬(Heap Sort)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">heapsort</span><span class=\"token punctuation\">(</span>iterable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    h <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 모든 원소를 차례때로 힙에 삽입</span>\n    <span class=\"token keyword\">for</span> value <span class=\"token keyword\">in</span> iterable<span class=\"token punctuation\">:</span>\n        heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> result\n\nresult <span class=\"token operator\">=</span> heapsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\"># [9,8,7,6,5,4,3,2,1,0]</span></code></pre></div>\n<blockquote>\n<p>💡 “그래서 Priority Queue와 Heap의 차이가 뭐야?”\nPriority Queue는 <strong>Abstract Datatype</strong>이다. 그러니까 특정 interface와 그 행위를 지칭하는 <strong>개념적인 용어</strong>이고, 기본 구현에 대해서는 언급하지 않는다.\n반면에, Heap은 <strong>자료구조</strong>이다. 즉, 특정 작업에 대해 매우 효율적으로 동작하도록 설계한 데이터 저장 방식에 대한 명칭이다.\n결국, Heap 자료구조를 이용한 데이터 저장 방식이 Priority Queue를 구현할 수 있도록 해주는 것이다.</p>\n</blockquote>\n<h2 id=\"2-tree-트리\" style=\"position:relative;\"><a href=\"#2-tree-%ED%8A%B8%EB%A6%AC\" aria-label=\"2 tree 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Tree (트리)</h2>\n<ul>\n<li>\n<p>가계도와 같이 계층적인 구조(Hierarchical Structure)를 표현할 때 사용할 수 있는 자료 구조</p>\n</li>\n<li>\n<p>관련 용어</p>\n<ul>\n<li>root node: 부모가 없는 최상위 노드</li>\n<li>leaf node: 자식이 없는 노드</li>\n<li>size: 트리에 포함된 모든 노드의 개수</li>\n<li>depth: root 노드로부터의 거리</li>\n<li>height: depth 중 최댓값</li>\n<li>degree: 각 노드의 (자식 방향) edge 개수</li>\n</ul>\n</li>\n<li>\n<p>Tree의 특징</p>\n<ul>\n<li>Tree의 Size가 N일 때, 전체 Edge의 개수는 N-1</li>\n</ul>\n</li>\n<li>\n<p>Binary Search Tree (이진 탐색 트리)</p>\n<ul>\n<li>이진 탐색이 효율적으로 통작할 수 있도록 고안된 자료구조</li>\n<li>Binary Search Tree의 특징: left child node &#x3C; root node &#x3C; right child node</li>\n<li>Complete Bineary Search Tree일 경우(이상적인 조건), 탐색 시간이 O(logN) 소요</li>\n</ul>\n</li>\n<li>\n<p>Tree Traversal (트리 순회)</p>\n<ul>\n<li>Tree 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법 의미</li>\n<li>대표적인 Tree Traversal 방법\n<ol>\n<li>Pre-order traverse(전위 순회): root 먼저 방문</li>\n<li>In-order traverse(중위 순회): left child -> root -> right child</li>\n<li>Post-order traverse(후위 순회): left child -> right child -> root</li>\n</ol>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABBUlEQVQoz3WQyaqFQAxE/f+PcyO4EL2KOOCI86y5nDx0IfcFYnfsSlUlhvyI67qee13XEkWR7Pv+vN357iGNN8l9rusqwzBInueaEM/zLOd5Ppht2ySOY+n7/iE2fjmjCSDO7qApCAIVIZZlka7rpKoqPanV4XsEyLIskzzLHnXGTZJEyrLUE6e4RhCXiJD0Gu/9AQ4+Hzm2VYqylDRNlQiR4zi05s4/13W1xuE4jn+EfKZp0mRvELIvACTKjNO2rRLiGFxRFGKapliWpW+PQ5ocxxHbtsX3fd0TGYahApumUQc0UCNMUOOO0eHAiO4QAIQoMQKknucpKQuH8HYAMQ5x+l98AQChaFptiqH6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tree_traverse-1.png\"\n        title=\"tree_traverse-1.png\"\n        src=\"/static/98d45563b2ee7caaa7e58cb1d1054200/37523/tree_traverse-1.png\"\n        srcset=\"/static/98d45563b2ee7caaa7e58cb1d1054200/e9ff0/tree_traverse-1.png 180w,\n/static/98d45563b2ee7caaa7e58cb1d1054200/f21e7/tree_traverse-1.png 360w,\n/static/98d45563b2ee7caaa7e58cb1d1054200/37523/tree_traverse-1.png 720w,\n/static/98d45563b2ee7caaa7e58cb1d1054200/302a4/tree_traverse-1.png 1080w,\n/static/98d45563b2ee7caaa7e58cb1d1054200/e40ed/tree_traverse-1.png 1378w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> left_node<span class=\"token punctuation\">,</span> right_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data\n        self<span class=\"token punctuation\">.</span>left_node <span class=\"token operator\">=</span> left_node\n        self<span class=\"token punctuation\">.</span>right_node <span class=\"token operator\">=</span> right_node\n\n<span class=\"token comment\"># Pre-order Traversal</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">pre_order</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>node_data<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># left</span>\n    <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>left_node <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        pre_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>left_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># right</span>\n    <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>right_mode <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        pre_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>right_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># In-order Traversal</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">in_order</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># left</span>\n    <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>left_node <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        in_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>left_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># root</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># right</span>\n    <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>right_node <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        in_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>left_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    \n<span class=\"token comment\"># Post-order Traversal</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">post_order</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># left</span>\n    <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>left_node <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        post_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>left_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># right</span>\n    <span class=\"token keyword\">if</span> node<span class=\"token punctuation\">.</span>right_node <span class=\"token operator\">!=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        post_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>right_node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># root</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># node 개수</span>\nn <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\ntree <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    data<span class=\"token punctuation\">,</span> left_node<span class=\"token punctuation\">,</span> right_node <span class=\"token operator\">=</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> left_node <span class=\"token operator\">==</span> <span class=\"token string\">\"None\"</span><span class=\"token punctuation\">:</span>\n        left_node <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    <span class=\"token keyword\">if</span> right_node <span class=\"token operator\">==</span> <span class=\"token string\">\"None\"</span><span class=\"token punctuation\">:</span>\n        right_node <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    tree<span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> left_node<span class=\"token punctuation\">,</span> right_node<span class=\"token punctuation\">)</span>\n\npre_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nin_oreder<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npost_order<span class=\"token punctuation\">(</span>tree<span class=\"token punctuation\">[</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n</li>\n</ul>\n<h2 id=\"3-binary-indexed-tree-bit-fenwick-tree\" style=\"position:relative;\"><a href=\"#3-binary-indexed-tree-bit-fenwick-tree\" aria-label=\"3 binary indexed tree bit fenwick tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Binary Indexed Tree (BIT, Fenwick Tree)</h2>\n<ul>\n<li>\n<p>조건: 데이터 update가 가능한 상황에서의 Interval Sum(구한 합) 문제</p>\n<ul>\n<li><a href=\"https://www.acmicpc.net/problem/2042\">https://www.acmicpc.net/problem/2042</a></li>\n</ul>\n</li>\n<li>\n<p>2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조 의미</p>\n<ul>\n<li>\n<p>cf. 정수에 따른 2진수 표기</p>\n<table>\n<thead>\n<tr>\n<th>정수</th>\n<th>2진수 표기</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7</td>\n<td>00000000 00000000 00000000 0000111</td>\n</tr>\n<tr>\n<td>-7</td>\n<td>11111111 11111111 11111111 1111001</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n</li>\n<li>\n<p>0이 아닌 마지막 비트를 찾는 방법</p>\n<ul>\n<li>특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서 K &#x26; -K를 계산하면 됨</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABR0lEQVQoz22S6arCQAxGff+nEtSq1Wr9477vS6nWDQrV73IiI3K1EGaSmZx8mTSXZZmiKNLpdNLhcNBut9P5fBbf4/HQ5/d8Pr/s/1kO53q9qtPpaL/f2x4gdrlcNBwO1W63tV6vzSeeJMn7DufL5dL2aZq+gKgiaTqdajKZqFQqyfM8VSoV5fN584vFovmFQkHNZlOLxULz+Vz9fl/j8dhyKWhA2l2tVqZwu90qCAI1Gg1LZG21WraGYah6vW4Qnon7KEcQdr/fX8Dj8ajZbGYwLvi+r1qtZsnVatUKEGNFZa/Xexen3c1mY/YFJAjQwQCwR51biXe7XVPkgOT8BDqFDuYAtI7v1sFg8G7zp8I4jm0YwLjAQMrlsrXHQGjbDYk4fwTFgSCE9yf3dru9gDwwE+MA41cYjUZmbv8Zc8Uxpk0OQgD+AT2KkIxQPoq3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_number-1.png\"\n        title=\"binary_number-1.png\"\n        src=\"/static/8ae80739754c9ac95b26a6ab4a9db1fa/37523/binary_number-1.png\"\n        srcset=\"/static/8ae80739754c9ac95b26a6ab4a9db1fa/e9ff0/binary_number-1.png 180w,\n/static/8ae80739754c9ac95b26a6ab4a9db1fa/f21e7/binary_number-1.png 360w,\n/static/8ae80739754c9ac95b26a6ab4a9db1fa/37523/binary_number-1.png 720w,\n/static/8ae80739754c9ac95b26a6ab4a9db1fa/302a4/binary_number-1.png 1080w,\n/static/8ae80739754c9ac95b26a6ab4a9db1fa/d8817/binary_number-1.png 1238w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>Binary Index Tree 구조</p>\n<ul>\n<li>0이 아닌 마지막 bit = 내가 저장하고 있는 값들의 개수</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVQozz2M6XLCMBCD8/4vxg2lpJ1yDCElxIacDjltJ+rsUvJDI0uf1k4Sx7g8MrjXCLvfO758ie9bgp1/x6cv8SNSuNcHv3njS35vPfHqLwJbL8SHJ+DJBE7T1IjUE2H2RJgWEHkJqUqEWcFZqor9ImMEcQ7BOzVuyW+Jwi0tEOVPOMMwQHcdht6OMrqDNfqVrcFgLdqm5g5Dz73VGrprxxv0Pf/j9H2Ptm1hjEWnNYwxqJsGdV3DWstZG4PqP7ddB601qqpCWZbjhkT/OASyLEOe54iiiJ1ykiRjr5RCHMechRAjS9OUnVQUBbsTBAHO5zNOpxPL9314nofD4YD9fs+MuuPxyJk2xKl/b4i97xzXdbFarbBYLDCfzzGbzbBerzGdTrFcLlnEqCcnNplMxj1x2hLfbDb4A/HBCMk6opL/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_index_tree-1.png\"\n        title=\"binary_index_tree-1.png\"\n        src=\"/static/764a86048c100680b6b2c5a6c2f22821/37523/binary_index_tree-1.png\"\n        srcset=\"/static/764a86048c100680b6b2c5a6c2f22821/e9ff0/binary_index_tree-1.png 180w,\n/static/764a86048c100680b6b2c5a6c2f22821/f21e7/binary_index_tree-1.png 360w,\n/static/764a86048c100680b6b2c5a6c2f22821/37523/binary_index_tree-1.png 720w,\n/static/764a86048c100680b6b2c5a6c2f22821/302a4/binary_index_tree-1.png 1080w,\n/static/764a86048c100680b6b2c5a6c2f22821/07a9c/binary_index_tree-1.png 1440w,\n/static/764a86048c100680b6b2c5a6c2f22821/8fc63/binary_index_tree-1.png 2756w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Update: 0이 아닌 마지막 bit만큼 더하면서 구간들의 값을 변경 -> O(logN)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABc0lEQVQozz2M65KaQBBGef93yUskpryALKIr4n0XUJgZmFlFESKeLUnij1Pf16e72tJFTiQK/LhgGimmcU6QFPifEu9DMEsK3g+GyYdk8ql422XMEo23F133I4W3l7i7jCCSWI8HnE8phfDQatZxUlPMv27yd0w+RxzfUKmLlhOM8jHP7Pqkc1q+kYs5FkB9jmhUj9Y4tMamyQfUsker+9yLPm3xm0q5NOWRxy2jrTKaMuF2irhf045HlVKd078Pn4tK/KKSAyrZ5yr6nPM1zfXIrUyoy5jylFE3LZdr/eLrdKH586Bu7t2uvFRYl2tFISNE7CHiKfkxQGcBWZYilUblGvN1RgiFEILDIUEpidYFQmRIKVBKYYxGCoEVxzGbzZZFuCYMF6xCj+1uTxAELBYLwjBku912+d9tNhvW6zXz+fx1s1qtWC6XWL7v47pjbNvBGfUY/vyB6zqMRiMcx3lh23bnxuNx159uMBi85uFw2Llvygn/7QHBcJoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_index_tree-2.png\"\n        title=\"3rd 변경하는 예시\"\n        src=\"/static/8142f2e1bc876b2d34b43d92e812cf18/37523/binary_index_tree-2.png\"\n        srcset=\"/static/8142f2e1bc876b2d34b43d92e812cf18/e9ff0/binary_index_tree-2.png 180w,\n/static/8142f2e1bc876b2d34b43d92e812cf18/f21e7/binary_index_tree-2.png 360w,\n/static/8142f2e1bc876b2d34b43d92e812cf18/37523/binary_index_tree-2.png 720w,\n/static/8142f2e1bc876b2d34b43d92e812cf18/302a4/binary_index_tree-2.png 1080w,\n/static/8142f2e1bc876b2d34b43d92e812cf18/07a9c/binary_index_tree-2.png 1440w,\n/static/8142f2e1bc876b2d34b43d92e812cf18/0d721/binary_index_tree-2.png 2774w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>Prefix Sum (누적 합): 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합을 계산 -> O(logN)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQoz02MTXOiQBRF+f8/ZfazzWIWE0XLqowGUQhCVJAINNDy2S1nil6ksrh1z33v3WcVecb5XvAe5+w+U97PKW6SszunbMPY5P01w7nc2X6mvJ1inGvGv/BmeBvdjN7ChOMlxRr6nrxuSKqBuOxIyo60Hkiq/jvPu+ir5HwXxEVNUkrjsfjhQpLkJRbA2GZMTcDURtBGaBmgZGB4akOm5sQgY7RSMGl4avQ4Mg49k9ZMTw3Tk77rsKYJ+scXSnoMtc8offrqSFPs0c38+MPs2jpmVDCMimEc6boOKR8orVFKoZSmbVustm0QoqKsHtwzQfGDRSkRZU0tO7L7jSL1uV09siynLCuyLEMIYVTXtcnW5XLlFAR43tEoCALCMMR19xwOBzOLok98d8N+85vj9oXww+F0CnBdF8dx8DzPdHzfx9rtdmw2G1arFbZts1gsTJ59ni2XS9brteHF0mZl/8X+84uVveT1dfHdm+9m/g/RjgWEXA3LEgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"binary_index_tree-3.png\"\n        title=\"11th 까지의 누적 합을 구하는 예시\"\n        src=\"/static/c6e19751c02dbaee76f0e1ba37a066ff/37523/binary_index_tree-3.png\"\n        srcset=\"/static/c6e19751c02dbaee76f0e1ba37a066ff/e9ff0/binary_index_tree-3.png 180w,\n/static/c6e19751c02dbaee76f0e1ba37a066ff/f21e7/binary_index_tree-3.png 360w,\n/static/c6e19751c02dbaee76f0e1ba37a066ff/37523/binary_index_tree-3.png 720w,\n/static/c6e19751c02dbaee76f0e1ba37a066ff/302a4/binary_index_tree-3.png 1080w,\n/static/c6e19751c02dbaee76f0e1ba37a066ff/07a9c/binary_index_tree-3.png 1440w,\n/static/c6e19751c02dbaee76f0e1ba37a066ff/0d721/binary_index_tree-3.png 2774w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\n\n<span class=\"token comment\"># 데이터의 개수(n), 변경 횟수(m), 구간 합 계산 횟수(k)</span>\nn<span class=\"token punctuation\">,</span>m<span class=\"token punctuation\">,</span>k <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 전체 데이터의 개수는 최대 1,000,000개</span>\narr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>     <span class=\"token comment\"># input 데이터를 담는 용도</span>\ntree <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># binary index tree</span>\n\n<span class=\"token comment\"># i번째 수까지의 누적 합을 계산하는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">prefix_sum</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">while</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        result <span class=\"token operator\">+=</span> tree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token comment\"># 0이 아닌 마지막 비트만큼 빼가면서 이동</span>\n        i <span class=\"token operator\">-=</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">&amp;</span><span class=\"token operator\">-</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> result\n\n<span class=\"token comment\"># i번째 수를 dif만큼 더하는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> dif<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">while</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">:</span>\n        tree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> dif\n        i <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">&amp;</span><span class=\"token operator\">-</span>i<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># start부터 end까지의 구간 합을 계산하는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">interval_sum</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> prefix_sum<span class=\"token punctuation\">(</span>end<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> prefix_end<span class=\"token punctuation\">(</span>start<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    x <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x\n    update<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">+</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># operation, index, value</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 업데이트(update) 연산인 경우</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        update<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> c<span class=\"token operator\">-</span>arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 바뀐 크기(diff, 원래 arr[b]였는데 c가 되어야 하니까 c-arr[b]만큼 더해줘야함)만큼 적용</span>\n        arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c\n    <span class=\"token comment\"># 구간 합(interval sum) 연산의 경우</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>interval_sum<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"4-lowest-common-ancestor-lca-최소-공통-조상\" style=\"position:relative;\"><a href=\"#4-lowest-common-ancestor-lca-%EC%B5%9C%EC%86%8C-%EA%B3%B5%ED%86%B5-%EC%A1%B0%EC%83%81\" aria-label=\"4 lowest common ancestor lca 최소 공통 조상 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Lowest Common Ancestor (LCA, 최소 공통 조상)</h2>\n<ul>\n<li>\n<p><a href=\"https://www.acmicpc.net/problem/11437\">BOJ ‘LCA’ 문제</a></p>\n</li>\n<li>\n<p>LCA(Lowest Common Ancestor) 문제는 <strong>두 노드의 공통된 조상 중에서 가장 가까운 조상을 찾는 문제</strong></p>\n</li>\n<li>\n<p>기본적인 LCA 알고리즘 동작 과정</p>\n<ol>\n<li>모든 노드에 대한 depth 계산 (DFS 이용)</li>\n<li>최소 공통 조상을 찾을 두 노드 확인\n<ol>\n<li>먼저 두 노드의 depth가 동일하도록 거슬러 올라감</li>\n<li>이후에 parent가 같아질 때까지 반복적으로 두 노드의 parent 방향으로 거슬러 올라감</li>\n</ol>\n</li>\n<li>모든 LCA(a,b) 연산에 대해 2번 과정 반복</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\nsys<span class=\"token punctuation\">.</span>setrecursionlimit<span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 런타임 오휴 피하기</span>\nn<span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># parent 노드 정보</span>\nd <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 각 노드까지의 depth</span>\nc <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 각 노드의 depth가 계산되었는지 여부</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># graph 정보</span>\n\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># root 노드부터 시작하여 depth를 구하는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> depth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    c<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    d<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> depth\n    <span class=\"token keyword\">for</span> y <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> c<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>    <span class=\"token comment\"># 이미 depth를 구했다면 넘기</span>\n            <span class=\"token keyword\">continue</span>\n        parent<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x\n        dfs<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> depth<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># A와 B의 최소 공통 조상을 찾는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 먼저 depth가 동일하도록 (시작 지점 동일하도록)</span>\n    <span class=\"token keyword\">while</span> d<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> d<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> d<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> d<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            a <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            b <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 노드가 같아지도록 (LCA 찾아서)</span>\n    <span class=\"token keyword\">while</span> a <span class=\"token operator\">!=</span> b<span class=\"token punctuation\">:</span>\n        a <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span>\n        b <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> a\n\ndfs<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># root 노드 = 1번 노드, dfs로 depth 조사</span>\n\nm <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>lca<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>기본적인 LCA 알고리즘 성능 분석</p>\n<ul>\n<li>시간 복잡도: O(NM)\n<ul>\n<li>매 query마다 부모 방향으로 거슬러 올라가기 위해 O(N) 시간 복잡도 소요 x query 개수(M)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.acmicpc.net/problem/11438\">BOJ ‘LCA’ 심화 문제</a></p>\n<ul>\n<li>N과 M이 10만개가 넘어갈 때, 위의 알고리즘으로는 시간 초과 판정</li>\n</ul>\n</li>\n<li>\n<p>LCA 알고리즘 개선하기</p>\n<ul>\n<li>각 노드가 <strong>거슬러 올라가는 속도를 빠르게 만드는 방법</strong> 개선\n<ul>\n<li>2의 제곱 형태로 거슬러 올라가게 할 경우 -> O(logN) 시간 복잡도\n<ul>\n<li>e.g. 15칸 거슬러 올라가야 할 경우, 8칸 -> 4칸 -> 2칸 -> 1칸</li>\n</ul>\n</li>\n<li>메모리를 조금 더 사용하여 2^i 번째 부모에 대한 정보 기록\n<ul>\n<li>각 노드 별로 logN만큼의 메모리 추가 필요: 노드가 N일 때, 총 NlogN만큼의 메모리 추가 소요</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>개선된 LCA 알고리즘</p>\n<ul>\n<li>모든 노드의 깊이와 부모 구하기 + 2^i번 째 부모 구하기\n<ul>\n<li>모든 노드의 깊이와 부모: dfs로 구하기</li>\n<li>2^i번 째 부모 구하기: dynamic programming 이용 -> trade-off를 통해 시간 복잡도 개선 가능</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>개선된 LCA 알고리즘의 시간 복잡도</p>\n<ul>\n<li>O(MlogN)</li>\n<li>매 쿼리마다 부모로 거슬러 올라가기 위해서는 O(logN)의 복잡도 필요 -> 쿼리 M개를 처리하기 위해서는 O(MlogN)</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline  <span class=\"token comment\"># 시간 초과를 피하기 위한 빠른 입력 함수</span>\nsys<span class=\"token punctuation\">.</span>setrecursionlimit<span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 런타임 오류를 피하기 위한 재귀 깊이 제한 설정</span>\nLOG <span class=\"token operator\">=</span> <span class=\"token number\">21</span> <span class=\"token comment\"># 2^20 = 1,048,576(1,000,000)</span>\n\nn <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> LOG <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># parent 노드 정보</span>\nd <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 각 노드까지의 거리</span>\nc <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 각 노드의 depth가 change되었는지 여부</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># graph 정보</span>\n\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># root 노드로부터 시작해서 depth를 구하는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> depth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    c<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    d<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> depth\n    <span class=\"token keyword\">for</span> y <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> c<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>    <span class=\"token comment\"># 이미 depth를 구한 노드라면 넘기기</span>\n            <span class=\"token keyword\">continue</span>\n        parent<span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x\n        dfs<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> depth<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 전체 parent 관계 설정 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">set_parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    dfs<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># root 노드부터 전체 노드의 parent 정보 저장</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> LOG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            parent<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>parent<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># A와 B의 최소 공통 조상을 찾는 함수</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">lca</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># b가 더 깊도록 설정</span>\n    <span class=\"token keyword\">if</span> d<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> d<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        a<span class=\"token punctuation\">,</span>b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">,</span>a\n    <span class=\"token comment\"># 먼저 depth가 동일하도록</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>LOG<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> d<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> d<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            b <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 부모가 같아지도록</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> a\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>LOG<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 조상을 향해 2^i만큼 거슬러 올라가기</span>\n        <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            a <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            b <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 이후에 부모 = 찾고자 하는 조상</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-priority-queue-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90--heap-%ED%9E%99\">1. Priority Queue (우선순위 큐) &#x26; Heap (힙)</a></li>\n<li><a href=\"#2-tree-%ED%8A%B8%EB%A6%AC\">2. Tree (트리)</a></li>\n<li><a href=\"#3-binary-indexed-tree-bit-fenwick-tree\">3. Binary Indexed Tree (BIT, Fenwick Tree)</a></li>\n<li><a href=\"#4-lowest-common-ancestor-lca-%EC%B5%9C%EC%86%8C-%EA%B3%B5%ED%86%B5-%EC%A1%B0%EC%83%81\">4. Lowest Common Ancestor (LCA, 최소 공통 조상)</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","excerpt":"1. Priority Queue (우선순위 큐) & Heap (힙) Priority Queue: 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조 데이터를 우선순위에 따라 처리하고 싶을 때 사용함 Priority Queue 구현 방법 List 이용: 차례로 데이터 삽입 & 꺼낼 때 우선 순위 비교해서 높은 것부터 꺼냄 Heap 이용 데이터 개수가 N일 때, 구현 방식에 따른 시간 복잡도 우선순위 큐 구현 방식 삽입 시간 삭제 시간 List O(1) O(N) Heap O(logN) O(logN) 단순히 데이터를 Heap에 넣었다가 모두 꺼내는 작업 = 정렬 작업 ‘힙 정렬’이라고 함 시간 복잡도: O(NlogN) Heap의 특징 Heap은 Complete Binary Tree(완전 이진 트리)의 일종 항상 Root node를 제거함 Min Heap (최소 힙) root 노드가 가장 작은 값을 가짐 값이 작은 데이터가 우선적으로 제거됨 Max Heap (최대 힙) root 노…","frontmatter":{"date":"November 07, 2022","title":"자료구조 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Data_Structure/"}},"next":{"id":"29c46c26-f92c-5cc3-8977-87d9220073c5","html":"<p>졸업 후, 취준을 하며 여느 졸업생(취준생)들과 비슷한 시간을 보내고 있었다.\n그러던 중, 지도 교수님과 논문 관련해서 상담을 하게되었다.</p>\n<p>교수님께서는 미국 박사 유학을 적극 추천해주셨고,\n이제까지는 ‘내 일이 아니다’라며 생각했던 진로에 대해 진지하게 고민해보게 되었다.</p>\n<p>현실적으로 지금은 박사 유학을 위한 준비가 아무것도 되어있지 않다보니,\n내년 가을에 Application을 넣고, 2024년 9월 입학을 고려해야 한다. (28살에 박사 입학)</p>\n<p>그러기 위해선 내년(2023년) 이 맘때쯤 전까지 준비가 완료되어있어야하기 때문에\n어떤 준비가 필요한지에 대해 찾아보고 정리해두려고 한다.</p>\n<h2 id=\"0-국내-해외-대학원-유학-장학금\" style=\"position:relative;\"><a href=\"#0-%EA%B5%AD%EB%82%B4-%ED%95%B4%EC%99%B8-%EB%8C%80%ED%95%99%EC%9B%90-%EC%9C%A0%ED%95%99-%EC%9E%A5%ED%95%99%EA%B8%88\" aria-label=\"0 국내 해외 대학원 유학 장학금 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. 국내 해외 대학원 유학 장학금</h2>\n<ul>\n<li>삼성 이건희 장학금</li>\n<li>관청 이종환 장학금</li>\n<li>국비 유학생 선발 파견 장학금</li>\n<li>한국 고등교육재단 장학금</li>\n</ul>\n<h2 id=\"1-준비해야-할-것\" style=\"position:relative;\"><a href=\"#1-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83\" aria-label=\"1 준비해야 할 것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 준비해야 할 것</h2>\n<p>학교마다 다르겠지만, 보통의 학교 입학을 위해 준비해야하는 것들은 아래와 같다.</p>\n<ul>\n<li>\n<p>필수 사항</p>\n<ul>\n<li>학사 학위 / High GPA (최소 3.0/4.0, 3.9 ~ 4.0/4.5)</li>\n<li>GRE / TOEFL (Minimum: 80~100/120)</li>\n<li>Resume = CV\n<ul>\n<li>연구 실적\n<ul>\n<li><strong>영어발표 or 영어로 된 논문 쓴 경험</strong></li>\n<li>국내외 학회 포스터/구두 발표 참여 경험</li>\n<li>논문(학위논문, 학회발표논문, 국외 논문, 학회지논문)</li>\n<li>수상실적(우수발표상 등)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SOP (Statement of Purpose, 자기소개서)\n<ul>\n<li>저술한 논문의 결론 및 주장, 의견, 이론이 입학에 중요한 영향을 미침</li>\n<li>연구실 생활을 연대기적으로 요약 정리, 기술하여 랩 생활에 대한 김이 있음을 어필해야 함</li>\n</ul>\n</li>\n<li>추천서 (3 ~ 5개)</li>\n</ul>\n</li>\n<li>\n<p>권장 사항</p>\n<ul>\n<li><strong>지원하는 교수님께 지원 프로세스 전에 이메일 보내기</strong></li>\n<li>Writing Sample</li>\n<li>GRE Subject</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-준비-timeline\" style=\"position:relative;\"><a href=\"#2-%EC%A4%80%EB%B9%84-timeline\" aria-label=\"2 준비 timeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 준비 Timeline</h2>\n<table>\n<thead>\n<tr>\n<th>시기</th>\n<th>준비해야 할 것</th>\n<th>비고</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2022.11</td>\n<td>프로그램 Search</td>\n<td>1~2개월 소요, 엑셀에 정리</td>\n</tr>\n<tr>\n<td>2022.11</td>\n<td>영어 Speaking 공부 시작</td>\n<td>1~2개월 소요, 엑셀에 정리</td>\n</tr>\n<tr>\n<td>2022.03</td>\n<td>GRE 준비</td>\n<td>4개월 소요, 7월 시험 (2~4회/달, 결과 10일 내 발표)</td>\n</tr>\n<tr>\n<td>2023.03</td>\n<td>TOEFL 준비</td>\n<td>3개월 소요, 6월 시험 (6회/달, 결과 4~5일 내 발표 )</td>\n</tr>\n<tr>\n<td>2023.03</td>\n<td>CV 준비</td>\n<td>1~2주 소요</td>\n</tr>\n<tr>\n<td>2023.03</td>\n<td>SOP 준비</td>\n<td>3개월 소요</td>\n</tr>\n<tr>\n<td>2023.07</td>\n<td>fulbright scholarship program</td>\n<td>3개월 소요</td>\n</tr>\n<tr>\n<td>2023.08</td>\n<td>컨택 메일 보내기</td>\n<td>8월 말 ~ 9월 초</td>\n</tr>\n<tr>\n<td>2023.08</td>\n<td>온라인 원서 오픈 상황 Check</td>\n<td>8월 ~ 9월</td>\n</tr>\n<tr>\n<td>2023.10</td>\n<td>인터뷰 준비 시작</td>\n<td>3개월 소요, 연구 주제 설명</td>\n</tr>\n<tr>\n<td>2023.09-12</td>\n<td>Application</td>\n<td>시험 점수 Reporting 2주 소요</td>\n</tr>\n<tr>\n<td>2023.10-2024.02</td>\n<td>진행 상황 Check</td>\n<td></td>\n</tr>\n<tr>\n<td>2023.12-2024.02</td>\n<td>Interview</td>\n<td></td>\n</tr>\n<tr>\n<td>2024.08</td>\n<td>출국</td>\n<td></td>\n</tr>\n<tr>\n<td>2024.09</td>\n<td>입학</td>\n<td>28살</td>\n</tr>\n<tr>\n<td>2029.09</td>\n<td>박사 졸업</td>\n<td>33살 (5년 소요 예상)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-준비-details\" style=\"position:relative;\"><a href=\"#3-%EC%A4%80%EB%B9%84-details\" aria-label=\"3 준비 details permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 준비 Details</h2>\n<ul>\n<li>\n<p>프로그램 Search</p>\n<ul>\n<li><a href=\"https://www.usnews.com/rankings\">https://www.usnews.com/rankings</a></li>\n<li><a href=\"https://www.topuniversities.com/subject-rankings/2022\">https://www.topuniversities.com/subject-rankings/2022</a></li>\n<li>학 학교 해당 학과 페이지의 ‘Research’, ‘Faculty’, ‘Laboratory’, ‘Program’ 참고</li>\n<li>정리해야 할 항목\n<ul>\n<li>마감일, GPA, TOEFL, GRE, 선수과목, 기타 부가 서류 여부, 교수, 관련 연구, 지원료</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>School Selection</p>\n<ul>\n<li>해당 지역의 안정성, 도시 규모, 장학금/생활비, 한인 커뮤니티 규모 기준으로 줄여나감</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>유학 준비에 참고할만한 블로그</p>\n<ul>\n<li><a href=\"https://ygsj.tistory.com/10\">https://ygsj.tistory.com/10</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#0-%EA%B5%AD%EB%82%B4-%ED%95%B4%EC%99%B8-%EB%8C%80%ED%95%99%EC%9B%90-%EC%9C%A0%ED%95%99-%EC%9E%A5%ED%95%99%EA%B8%88\">0. 국내 해외 대학원 유학 장학금</a></li>\n<li><a href=\"#1-%EC%A4%80%EB%B9%84%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B2%83\">1. 준비해야 할 것</a></li>\n<li><a href=\"#2-%EC%A4%80%EB%B9%84-timeline\">2. 준비 Timeline</a></li>\n<li><a href=\"#3-%EC%A4%80%EB%B9%84-details\">3. 준비 Details</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 06, 2022","title":"미국 박사 유학","categories":"PhD","author":"Mini","emoji":"🧩"},"fields":{"slug":"/PhD in US/"}},"prev":{"id":"c5fd76b3-665f-5351-a848-10ac2f57916d","html":"<h2 id=\"1-disjoint-sets-서로소-집합-자료구조\" style=\"position:relative;\"><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"1 disjoint sets 서로소 집합 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Disjoint Sets (서로소 집합) 자료구조</h2>\n<ul>\n<li>\n<p>서로소: ‘공통 원소가 없는 두 집합’ 의미</p>\n</li>\n<li>\n<p>서로소 집합 자료구조: 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조</p>\n</li>\n<li>\n<p>서로소 집합 자료구조(= <strong>Union Find 자료구조</strong>)의 연산</p>\n<ul>\n<li><strong>Union(합집합)</strong></li>\n<li><strong>Find(찾기)</strong>: 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산</li>\n</ul>\n</li>\n<li>\n<p>서로소 집합 자료구조 동작 과정</p>\n<ol>\n<li>Union 연산 확인 -> 서로 연결된 두 노드 A, B 확인\n<ol>\n<li>A와 B의 루트 노드 A’, B’를 각각 찾음</li>\n<li>A’를 B’의 부모 노드로 설정</li>\n</ol>\n</li>\n<li>모든 Union 연산을 처리할 때까지 1번 과정 반복</li>\n</ol>\n</li>\n<li>\n<p>서로소 집합 자료구조의 연결성</p>\n<ul>\n<li>기본적인 형태로 서로소 집합 자료구조에서는 root 노드에 즉시 접근할 수 없음\n-> root 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야 함</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABWElEQVQoz22PQU/CQBCF+6c96NWDJ3+GF9GTiSEaEhI1lBZtDdaWEoQ2ECPQbUvbBbbbPrOLJdQwyZd5szvvZVcpyxKiqp7nuaQqoTnn+x3GGIqiqHlEr1AqUZlplmFNqQwRc5omoJTKEBGWJLv5WJgMxEGJkCiOsUoSlEWBgnMsAyJnlCVyxkAIQZqm+8D/pYgQgfxGWSDbbLHI1mCcY81yLLM1ArrBlnNQliOmG/lysV95D1HiOEYURViQEPOAYElCkDDCT0AwJwSrv/vdHEp9iPAfonzPZhhMfFw+6Di/beGiqaNjjzDzJ/B9H+PxGK7rSu17HobDIb5GI3ieJ8+m02kNxR04eLVsnFzd4/S6hbM7Fc2uAcfq48Oy0O/3YZgmLMuSvJkm3lUVlmHg07bhOE4NpdfroaNpaDy2cdN6QqP1jPZLB7rWRbe7Q1XVo1rTNOi6XuMXuy1T+a8HV44AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-1.png\"\n        title=\"노드 3의 root를 찾기 위해 노드 2를 거쳐 노드 1에 접근해야 함\"\n        src=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png\"\n        srcset=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/e9ff0/disjoint_set-1.png 180w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/f21e7/disjoint_set-1.png 360w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png 720w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/302a4/disjoint_set-1.png 1080w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/07a9c/disjoint_set-1.png 1440w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/17d12/disjoint_set-1.png 1666w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>기본적인 구현 방법</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합을 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_partent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화</span>\n\n<span class=\"token comment\"># 부모 테이블상에서, 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># Union 연산 각각 수행</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 각 원소가 속한 집합 출력</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"각 원소가 속한 집합: \"</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 부모 테이블 내용 출력하기</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'부모 테이블: '</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>‘기본적인 구현 방법’의 문제점</p>\n<ul>\n<li>Union 연산이 편향되게 이루어지는 경우 Find 함수가 비효율적으로 동작</li>\n<li>최악의 경우에는 Find 함수가 모든 노드를 다 확인하게 되어 시간 복잡도다 O(V)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABiElEQVQoz02RS4sTQRSF+/f6A9y5c6kuXbp0IwyKDMMM6CTd6XZQJpmeJJ1MhIQk/UgC6Uz6/f6kLiIWXM6pc27dunVLq+uaxWLBZDJhuVyy3+/Z7XZ4nsd6vZbwfV9QaSpntVqJdgxD1Hm1uq4T1Nq25XA4sNlspFiaJMRRRBzHpGkqkSQJURSRZxlZmgpv/ivUNM0/rvF3VXVNWTeotLKqyfOcsmllXxQFeVFQdVA3rXhZWVK1HVmWk2UZqjHpsKoq6rIgjc6kSUxRlkRxTHg8ck4SkrzgdDoRhiFxXhAnqXinKCItS57PZ05hKJeoWpp65q/fa67vJ3y3nzCfNqw2Lr7nSXiuK/NyXVd4EPgyHuUFvs92uxUvCAIZmaY+5N2lwYsPX3j56ZZXlz8Z3D8wdxzsx0dGowdmsxm2bTMajXAcR3A8HjOdThkOh4JKn8/naHd3P3h/ccXrj195+/kbby5uuLnVsUwT3TAwDAPTstB1nX6/j2magqKbJr1ej8FgINyyLP4AJ9P/2tPubNUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-2.png\"\n        title=\"최악의 경우 예시\"\n        src=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png\"\n        srcset=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/e9ff0/disjoint_set-2.png 180w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/f21e7/disjoint_set-2.png 360w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png 720w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/302a4/disjoint_set-2.png 1080w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/07a9c/disjoint_set-2.png 1440w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/96191/disjoint_set-2.png 2176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>Path Compression (경로 압축)</p>\n<ul>\n<li>Find 함수를 최적화하기 위한 방법</li>\n<li>Find 함수를 재귀적으로 호출한 뒤에 <strong>부모 테이블 값을 바로 갱신</strong>\n<ul>\n<li>Find 함수를 호출한 이후에 해당 노드의 root 노드가 바로 부모 노드가 됨</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>partent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드가 아니라면 root 노드를 찾을 때까지 재귀적으로 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"disjoint-set을-활용한-cycle-판별\" style=\"position:relative;\"><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\" aria-label=\"disjoint set을 활용한 cycle 판별 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disjoint Set을 활용한 Cycle 판별</h3>\n<ul>\n<li>서로소 집합은 <strong>무방향 그래프(Undirected Graph) 내에서의 사이클을 판별</strong>할 때 사용 가능\n<ul>\n<li>cf. 방향 그래프(Directed Graph)에서의 사이클 여부는 DFS를 이용하여 판별 가능</li>\n</ul>\n</li>\n<li>Cycle 판별 알고리즘\n<ol>\n<li>각 Edge를 하나씩 확인하여 두 노드의 root 노드를 확인함\n<ol>\n<li>root 노드가 서로 다르다면 두 노드에 대해 Union 수행</li>\n<li>root 노드가 서로 같다면 Cycle이 발생한 것임</li>\n</ol>\n</li>\n<li>그래프에 포함되어 있는 모든 Edge에 대해 1번 과정을 반복</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(Union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화하기</span>\n\n<span class=\"token comment\"># 부모 테이블에서 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\ncycle <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span> <span class=\"token comment\"># 사이클 발생 여부</span>\n\n<span class=\"token comment\"># Edge를 순회하며 cycle 탐색</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># cycle이 발생한 경우 종료</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        cycle <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">break</span>\n    <span class=\"token comment\"># cycle이 발생하지 않았다면 Union 연산 수행</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"there is cycle\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no cycle\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"2-minimum-spanning-tree-최소-신장-트리\" style=\"position:relative;\"><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\" aria-label=\"2 minimum spanning tree 최소 신장 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Minimum Spanning Tree (최소 신장 트리)</h2>\n<ul>\n<li>Spanning Tree: 그래프에서 <strong>모든 노드를 포함</strong>하면서 <strong>cycle이 존재하지 않는 부분 그래프</strong> 의미\n<ul>\n<li>cf. Tree의 조건: 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다</li>\n<li>Edge의 개수 = Vertex의 개수 - 1</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA70lEQVQY002ObW+DMAyE+f//a6q6VUzTNqFC2/HyYZogQCgqISE8k1PR7STL9tm+cwTgvWee55CttSzLwgbpnVtwy322IdzIrl+ZZxt6QbSJTdP0EJTaOYd1jts0Yaxj8R5j5oehZCNPrOv9xpjAR3JojAnqQqzrGgyE2752/0IMRGD7VubaedR4wxpDpLVGKcUwDNR1Td/3dF33F1rTdj2NUlzHEdW2YUeyHq781DXfnUY1DX1TExVFQVmWZFlGHMckSUJVVeR5TlkWJOmZ+D3l9SPl7TMjLwryy4XjfkcWH0hf9pwPzxx3T3ydMn4BG7x+0KXicSUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"spanning_tree-1.png\"\n        title=\"spanning_tree-1.png\"\n        src=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png\"\n        srcset=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/e9ff0/spanning_tree-1.png 180w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/f21e7/spanning_tree-1.png 360w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png 720w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/302a4/spanning_tree-1.png 1080w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/07a9c/spanning_tree-1.png 1440w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/b918a/spanning_tree-1.png 2780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>Minimum Spanning Tree: <strong>최소한의 비용으로 구성되는 신장 트리</strong></p>\n<ul>\n<li>e.g., N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 <strong>전체 도시가 서로 연결</strong>될 수 있게 도로를 설치하는 경우 (= 두 도시 A, B를 선택했을 때 A에서 B로 이동하는 경로가 반드시 존재)</li>\n</ul>\n</li>\n<li>\n<p><strong>Kruskal 알고리즘</strong></p>\n<ul>\n<li>대표적인 Minimum Spanning Tree 알고리즘</li>\n<li>Greedy 알고리즘</li>\n<li>동작 과정:\n<blockquote>\n<ol>\n<li>edge 데이터를 cost에 따라 <strong>오름차순으로 정렬</strong></li>\n<li>edge를 하나씩 확인하며 <strong>현재의 간선이 사이클을 발생시키는지 확인</strong>\n<ol>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시킴</li>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시키지 않음</li>\n</ol>\n</li>\n<li>모든 edge에 대해 2번 과정 반복</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 간선(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 자기 자신을 부모로 parent table 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># 모든 edge를 담을 리스트와 final cost를 담을 변수</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nresult <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 연산에 포함될 경우 = MST에 포함된다는 의미</span>\n\n<span class=\"token comment\"># 모든 간선에 대한 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> cost <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 cost으로 설정</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 cost순으로 정렬</span>\nedges<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 하나씩 확인해가며</span>\n<span class=\"token keyword\">for</span> edge <span class=\"token keyword\">in</span> edges<span class=\"token punctuation\">:</span>\n    cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> edge\n    <span class=\"token comment\"># 사이클이 발생하지 않는 경우에만 집합에 포함</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">+=</span> cost\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Kruskal 알고리즘의 성능 분석\n<ul>\n<li>시간 복잡도: O(ElogE) (Edge 개수 = E일 때)</li>\n<li>가장 많은 시간 요구하는 곳: edge 정렬 부분\n<ul>\n<li>표준 라이브러리(<code class=\"language-text\">sort()</code>)를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도: O(ElogE)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-topological-sort-위상-정렬\" style=\"position:relative;\"><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\" aria-label=\"3 topological sort 위상 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Topological Sort (위상 정렬)</h2>\n<ul>\n<li>**Cycle이 없는 Directed Graph(DAG, Directed Acyclic Graph)**의 모든 노드를 <strong>방향성에 거스르지 않도록 순서대로 나열</strong>\n<blockquote>\n<p>💡 DAG 여야하는 이유?\n: Cycle이 존재할 경우 Cycle이 존재하는 모든 노드의 Indegree가 1 이상이 되므로 다음 알고리즘을 사용할 경우, Cycle이 존재하는 모든 노드가 영원히 Queue에 들어갈 수 없음(=Sorting 수행할 수 없음)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>cf. Indegree와 Outdegree</p>\n<ul>\n<li>Indegree: 특정한 노드로 들어오는 edge의 개수</li>\n<li>Outdegree: 특정한 노드에서 나가는 edge의 개수</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Queue</strong>를 이용하는 Topological Sort 알고리즘 동작 과정\\</p>\n<ul>\n<li>각 노드가 Queue에 들어온 순서 = Topological Sort 수행 결과</li>\n</ul>\n<blockquote>\n<ol>\n<li>Indegree가 0인 모든 노드를 Queue에 넣음</li>\n<li>Queue가 빌 때까지 다음의 과정 반복</li>\n<li>Queue에서 원소를 꺼내 해당 노드에서 Outdegree를 그래프에서 제거함</li>\n<li>새롭게 Indegree가 0이 된 노드를 Queue에 넣음</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>Topological Sort 특징</p>\n<ul>\n<li>DAG (Direct Acyclic Graph), 순환하지 않는 방향 그래프에서만 수행 가능</li>\n<li><strong>여러 가지 답이 존재</strong>할 수 있음\n<ul>\n<li>한 단계에서 Queue에 새롭게 드어가는 원소가 2개 이상 있다면, 여러 가지 답이 존재</li>\n</ul>\n</li>\n<li><strong>모든 원소를 방문하기 전에 큐가 빈다면 Cycle이 존재</strong>한다고 판단\n<ul>\n<li>Cycle에 포함된 원소 중에서 어떠한 원소도 Queue에 들어가지 못함</li>\n</ul>\n</li>\n<li>Stack을 활용한 DFS를 이용해서도 Topological Sort 수행 가능</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\n<span class=\"token comment\"># 노드의 개수와 Edge의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 노드에 대한 indegree를 0으로 초기화</span>\nindegree <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결된 edge 정보를 담기 위한 연결 리스트 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> ragne<span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 방향 그래프의 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># A에서 B로 이동 가능</span>\n    <span class=\"token comment\"># indegree를 1 증가</span>\n    indegree<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># Topological Sort</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">topology_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># 알고리즘 수행 결과를 담을 리스트</span>\n    q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># queue</span>\n    <span class=\"token comment\"># 처음 시작할 때는 진입 차수가 0인ㅇ 노드를 queue에 삽입</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 큐가 빌 때까지 반복</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 큐에서 원소 꺼내기</span>\n        now <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 해당 원소와 연결된 노드들의 indegree에서 1 빼기</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token comment\"># 새롭게 indegree가 0이 되는 노드를 queue에 삽입</span>\n            <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Topological Sort 수행 결과 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> result<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\ntopology_sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Topology Sort의 성능 분석\n<ul>\n<li>시간 복잡도: O(V+E)</li>\n<li>차례대로 모든 Vertex를 확인해가며 각 Vertex에서 나가는 Edge를 차례대로 제거해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">1. Disjoint Sets (서로소 집합) 자료구조</a></p>\n<ul>\n<li><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\">Disjoint Set을 활용한 Cycle 판별</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\">2. Minimum Spanning Tree (최소 신장 트리)</a></p>\n</li>\n<li>\n<p><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\">3. Topological Sort (위상 정렬)</a></p>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 07, 2022","title":"Graph 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Graph/"}},"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/Data_Structure/","nextSlug":"/PhD in US/","prevSlug":"/Graph/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}