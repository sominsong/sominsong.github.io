{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Shortest_Path/",
    "result": {"data":{"cur":{"id":"290d3173-ced6-596b-ace6-0bac606c540c","html":"<ul>\n<li>가장 짧은 경로를 찾는 알고리즘</li>\n<li>최단 경로 알고리즘이 사용될 수 있는 다양한 문제 상황\n<ul>\n<li>한 지점에서 다른 한 지점까지의 최단 경로</li>\n<li>한 지점에서 다른 모든 지점까지의 최단 경로</li>\n<li>모든 지점에서 다른 모든 지점까지의 최단 경로</li>\n</ul>\n</li>\n<li>Dynamic Programming 문제로 분류되기도 함</li>\n</ul>\n<h2 id=\"1-dijkstra-shortest-path-알고리즘\" style=\"position:relative;\"><a href=\"#1-dijkstra-shortest-path-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"1 dijkstra shortest path 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Dijkstra Shortest Path 알고리즘</h2>\n<ul>\n<li><strong>특정한 한 노드</strong>에서 출발하여 <strong>다른 모든 노드</strong>로 가는 최단 경로 계산</li>\n<li>조건: <strong>음수 Edge가 없을 때</strong> (현실 세계의 도로)</li>\n<li>Greedy 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 Node를 선택</li>\n</ul>\n<blockquote>\n<p>💡 알고리즘 동작 과정</p>\n<ol>\n<li>출발 노드 설정</li>\n<li>최단 거리 테이블 초기화 (모든 노드까지의 거리 무한으로 설정 &#x26; 자기 자신까지의 거리는 0으로 설정)\n<ul>\n<li>최단 거리 테이블: 각 노드에 대한 현재끼ㅏ지의 최단 거리 정보 저장</li>\n</ul>\n</li>\n<li>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택</li>\n<li>해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신</li>\n<li>위 과정에서 3번과 4번을 반복</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>Dijkstra 알고리즘 특징</p>\n<ul>\n<li>Greedy 알고리즘: 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정 반복</li>\n</ul>\n</li>\n<li>\n<p>단계를 거치며 <strong>한 번 처리된 노드의 최단 거리는 고정</strong>되어 더 이상 바뀌지 않음</p>\n<ul>\n<li>한 단계당 하나의 노드에 대한 최단 거리를 확실하게 찾음</li>\n</ul>\n</li>\n<li>\n<p>알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 <strong>거리</strong> 정보만 저장됨</p>\n<ul>\n<li>완벽한 형태의 최단 <strong>경로</strong>를 구하려면 소스코드에 추가적인 기능을 더 넣어야 함</li>\n</ul>\n</li>\n<li>\n<p>간단한 구현 방법</p>\n<ul>\n<li>단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 <strong>매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력 받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 방문한 적이 있는지 체크하는 목적의 리스트</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_smallest_node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    min_value <span class=\"token operator\">=</span> INF\n    index <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\"># 가장 최단 거리가 짧은 노드(인덱스)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min_value <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            min_value <span class=\"token operator\">=</span> distnace<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            index <span class=\"token operator\">=</span> i\n    <span class=\"token keyword\">return</span> index\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    visited<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    <span class=\"token comment\"># 시작 노드와 연결된 노드까지의 거리</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드를 제외한 전체 n-1개의 노드에 대해 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리</span>\n        now <span class=\"token operator\">=</span> get_smallest_node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        visited<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 노드 확인</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐 해당 노드로 갈 때의 거리</span>\n            cost <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서 해당 노드로 이동하는 거리가 더 짧은 경우 최단 거리 테이블 update</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n\n<span class=\"token comment\"># 다익스트라 알고리즘 수행</span>\ndikstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한(INFINITY)라고 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도달할 수 있는 경우 거리 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distnace<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>‘간단한 구현 방법’ 성능 분석</p>\n<ul>\n<li>전체 시간 복잡도: <strong>O(V^2)</strong>\n<ul>\n<li>총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색</li>\n</ul>\n</li>\n<li>전체 노드의 개수가 5,000개 이하일 경우 가능 BUT <strong>만 개를 넘어간다면 불가능</strong></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 우선순위 큐 (Priority Queue)\n: 우선 순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조\ne.g., 여러 개의 물건 데이터를 자료 구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는 경우</p>\n<ul>\n<li>Heap: Priority Queue를 구현하기 위해 사용하는 자료구조\n<ul>\n<li>Min Heap &#x26; Max Heap 존재</li>\n</ul>\n</li>\n<li>시간 복잡도: O(NlogN) (merge sort, quick sort와 동일)</li>\n</ul>\n</blockquote>\n<p><a href=\"https://sominsong.github.io/Data_Structure/#1-priority-queue-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90--heap-%ED%9E%99\">Priority 정리 참고</a></p>\n<ul>\n<li>\n<p>개선된 구현 방법</p>\n<ul>\n<li>단계마다 <strong>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택</strong>하기 위해 <strong>Heap</strong> 자료구조 이용</li>\n<li>알고리즘이 동작하는 기본 원리는 동일</li>\n<li>현재 가장 가까운 노드를 저장해 놓기 위해 Heap 자료구조를 추가로 이용한다는 점이 다름</li>\n<li>현재의 최단 거리가 가장 짧은 노드를 선택해야 함으로 <strong>Min Heap 사용</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq\n<span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력 받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">#### 여기까지는 기존 방법과 동일 ####</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dikstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    q <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드로 가기 위한 최단 경로르 0으로 설정, 큐에 삽입</span>\n    heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>    <span class=\"token comment\"># 큐가 비어있지 않다면</span>\n        <span class=\"token comment\"># 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기</span>\n        dist<span class=\"token punctuation\">,</span> now <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 현재 노드가 이미 처리된 적이 있는 노드라면 무시</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 인접 노드들 확인</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            cost <span class=\"token operator\">=</span> dist <span class=\"token operator\">+</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n                heapq<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 다익스트라 알고리즘 수행</span>\ndijkstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한으로 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도다랗ㄹ 수 있는 경우 거리 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>‘개선된 구현 방법’ 성능 분석</p>\n<ul>\n<li>시간 복잡도: O(ElogV)\n<ul>\n<li>노드를 하나씩 꺼내 검사하는 반복문(<code class=\"language-text\">while</code>문)은 노드의 개수 V 이상 처리되지 않음\n: 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 최대 edge의 개수(E)만큼 수행됨</li>\n</ul>\n</li>\n<li>직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사\n<ul>\n<li>O(ElogE)로 판단할 수 있음</li>\n<li>중복 간선을 초함하지 않는 경우 O(ElogV)로 정리 가능\n: O(ElogE) -> O(ElogV^2) -> O(2ElogV) -> O(ElogV)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-floyd-warshall-알고리즘\" style=\"position:relative;\"><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"2 floyd warshall 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Floyd-Warshall 알고리즘</h2>\n<ul>\n<li><strong>모든 노드</strong>에서 <strong>다른 모든 노드</strong>까지의 최단 경로를 모두 계산</li>\n<li>다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘 수행\n<ul>\n<li>다만 매 단계마다 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾는 과정 필요하지 않음</li>\n</ul>\n</li>\n<li>2차원 테이블에 최단 거리 정보 저장</li>\n<li>Dynamic Programming 유형에 속함: 2차원 최단 거리 테이블을 점화식으로 update\n<ul>\n<li>각 단계마다 <strong>특정한 노드 K를 거쳐 가는 경우 확인</strong>: a에서 b로 가는 최단 거리보다 a에서 k를 거처 b로 가는 거리가 더 짧은지 검사</li>\n<li>점화식: <code class=\"language-text\">D_ab = min(D_ab, D_ak + D_kb)</code></li>\n</ul>\n</li>\n<li>시간 복잡도: O(N^3) -> 노드가 적은 경우에만 이용할 수 있음</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">INF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수 및 간선의 개수를 입력받기</span>\nn <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nm <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 2차원 리스트(그래프 표현)를 만들고, 무한으로 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화</span>\n<span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token operator\">==</span>b<span class=\"token punctuation\">:</span>\n            graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token comment\"># 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># A에서 B로 가는 비용은 C라고 설정</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c\n\n<span class=\"token comment\"># 점화식에 따라 플로이스 워션 알고리즘 수행</span>\n<span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>graph<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 수행된 결과를 출력</span>\n<span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 도달할 수 없는 경우, 무한</span>\n        <span class=\"token keyword\">if</span> graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 도달할 수 있는 경우, 거리 출력</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Floyd-Warshall 알고리즘 성능 분석\n<ul>\n<li>시간 복잡도: O(N^3)\n<ul>\n<li>노드의 개수가 N개일 때, 알고리즘 상으로 N번의 단계(k를 거쳐 가는 경우)를 수행함</li>\n<li>각 단계마다 O(N^2)의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려함</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-bellman-ford-알고리즘\" style=\"position:relative;\"><a href=\"#3-bellman-ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"3 bellman ford 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Bellman-Ford 알고리즘</h2>\n<ul>\n<li>\n<p>조건: 음수 Edge가 포함된 상황에서의 최단 거리 문제</p>\n<ul>\n<li>e.g. <a href=\"https://www.acmicpc.net/problem/11657\">https://www.acmicpc.net/problem/11657</a></li>\n<li>음수 Edge에 대한 최단 경로 문제의 분류\n<ol>\n<li>모든 edge가 양수인 경우</li>\n<li>음수 edge가 있는 경우\n<ol>\n<li>음수 edge cycle이 없는 경우</li>\n<li>음수 edge cycle이 있는 경우</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Bellan-Ford 알고리즘</p>\n<ul>\n<li>음수 edge가 포함된 상황에서 사용 가능</li>\n<li>음수 edge의 cycle 감지 가능</li>\n<li>기본 시간 복잡도: O(VE)\n<ul>\n<li>Dijkstra 알고리즘에 비해 느림</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Bellman-Ford 알고리즘 동작 과정</p>\n<ol>\n<li>출발 노드 설정</li>\n<li>최단 거리 테이블 초기화</li>\n<li>다음 과정은 N-1번 반복\n<ol>\n<li>전체 edge E개를 하나씩 확인함</li>\n<li>각 edge를 거쳐 다른 노드로 가는 비용을 계산하여 최단거리 테이블 update</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>If, 음수 edge cycle이 발생하는지 체크하고 싶다면 3번의 과정을 한 번 더 수행\n<ul>\n<li>이 때, 최단거리 테이블이 update된다면 음수 edge cycle이 존재한다는 의미</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 Bellman-Ford 알고리즘 v.s. Dijkstra 알고리즘</p>\n<ul>\n<li>Dijkstra 알고리즘\n<ul>\n<li><strong>매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택</strong></li>\n<li>음수 edge가 없다면 최적의 해를 찾을 수 있음</li>\n</ul>\n</li>\n<li>Bellman-Ford 알고리즘\n<ul>\n<li><strong>매번 모든 edge를 전부 확인함</strong>-> 따라서 <strong>Dijkstra 알고리즘에서의 최적의 해를 항상 포함</strong></li>\n<li>Dijkstra 알고리즘에 비해서 시간이 오래 걸리지만 음수 edge cycle을 탐지할 수 있음</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>realine\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 무한을 의미하는 값으로 10억 설정</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bf</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    dist<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\"># 전체 n번의 round를 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 매 반복마다 '모든 edge'를 확인하며</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            cur <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n            next_node <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            cost <span class=\"token operator\">=</span> edge<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 edge를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> INF <span class=\"token keyword\">and</span> dist<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> cost<span class=\"token punctuation\">:</span>\n                dist<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> cost\n                <span class=\"token comment\"># n번째 라운드에서도 값이 갱신된다면 음수 cycle이 존재</span>\n                <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> n <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n<span class=\"token comment\"># 노드의 개수, edge의 개수 입력받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 edge에 대한 정보를 담는 리스트 만들기</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 edge 정보를 입력받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 벨만 포드 알고리즘 수행</span>\nnegative_cycle <span class=\"token operator\">=</span> bf<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 1번 노드가 시작 노드</span>\n\n<span class=\"token keyword\">if</span> negative_cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1번 노드를 제외한 다른 모든 노드로 가기 위한 최단 거리 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 도달할 수 없는 경우 -1 출력</span>\n        <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 도달할 수 있는 경우 거리 출력</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-dijkstra-shortest-path-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">1. Dijkstra Shortest Path 알고리즘</a></li>\n<li><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">2. Floyd-Warshall 알고리즘</a></li>\n<li><a href=\"#3-bellman-ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">3. Bellman-Ford 알고리즘</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","excerpt":"가장 짧은 경로를 찾는 알고리즘 최단 경로 알고리즘이 사용될 수 있는 다양한 문제 상황 한 지점에서 다른 한 지점까지의 최단 경로 한 지점에서 다른 모든 지점까지의 최단 경로 모든 지점에서 다른 모든 지점까지의 최단 경로 Dynamic Programming 문제로 분류되기도 함 1. Dijkstra Shortest Path 알고리즘 특정한 한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로 계산 조건: 음수 Edge가 없을 때 (현실 세계의 도로) Greedy 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 Node를 선택 💡 알고리즘 동작 과정 출발 노드 설정 최단 거리 테이블 초기화 (모든 노드까지의 거리 무한으로 설정 & 자기 자신까지의 거리는 0으로 설정) 최단 거리 테이블: 각 노드에 대한 현재끼ㅏ지의 최단 거리 정보 저장 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신 위 과정에…","frontmatter":{"date":"November 09, 2022","title":"Shortest Path 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Shortest_Path/"}},"next":{"id":"c5fd76b3-665f-5351-a848-10ac2f57916d","html":"<h2 id=\"1-disjoint-sets-서로소-집합-자료구조\" style=\"position:relative;\"><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"1 disjoint sets 서로소 집합 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Disjoint Sets (서로소 집합) 자료구조</h2>\n<ul>\n<li>\n<p>서로소: ‘공통 원소가 없는 두 집합’ 의미</p>\n</li>\n<li>\n<p>서로소 집합 자료구조: 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조</p>\n</li>\n<li>\n<p>서로소 집합 자료구조(= <strong>Union Find 자료구조</strong>)의 연산</p>\n<ul>\n<li><strong>Union(합집합)</strong></li>\n<li><strong>Find(찾기)</strong>: 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산</li>\n</ul>\n</li>\n<li>\n<p>서로소 집합 자료구조 동작 과정</p>\n<ol>\n<li>Union 연산 확인 -> 서로 연결된 두 노드 A, B 확인\n<ol>\n<li>A와 B의 루트 노드 A’, B’를 각각 찾음</li>\n<li>A’를 B’의 부모 노드로 설정</li>\n</ol>\n</li>\n<li>모든 Union 연산을 처리할 때까지 1번 과정 반복</li>\n</ol>\n</li>\n<li>\n<p>서로소 집합 자료구조의 연결성</p>\n<ul>\n<li>기본적인 형태로 서로소 집합 자료구조에서는 root 노드에 즉시 접근할 수 없음\n-> root 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야 함</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABWElEQVQoz22PQU/CQBCF+6c96NWDJ3+GF9GTiSEaEhI1lBZtDdaWEoQ2ECPQbUvbBbbbPrOLJdQwyZd5szvvZVcpyxKiqp7nuaQqoTnn+x3GGIqiqHlEr1AqUZlplmFNqQwRc5omoJTKEBGWJLv5WJgMxEGJkCiOsUoSlEWBgnMsAyJnlCVyxkAIQZqm+8D/pYgQgfxGWSDbbLHI1mCcY81yLLM1ArrBlnNQliOmG/lysV95D1HiOEYURViQEPOAYElCkDDCT0AwJwSrv/vdHEp9iPAfonzPZhhMfFw+6Di/beGiqaNjjzDzJ/B9H+PxGK7rSu17HobDIb5GI3ieJ8+m02kNxR04eLVsnFzd4/S6hbM7Fc2uAcfq48Oy0O/3YZgmLMuSvJkm3lUVlmHg07bhOE4NpdfroaNpaDy2cdN6QqP1jPZLB7rWRbe7Q1XVo1rTNOi6XuMXuy1T+a8HV44AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-1.png\"\n        title=\"노드 3의 root를 찾기 위해 노드 2를 거쳐 노드 1에 접근해야 함\"\n        src=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png\"\n        srcset=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/e9ff0/disjoint_set-1.png 180w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/f21e7/disjoint_set-1.png 360w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png 720w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/302a4/disjoint_set-1.png 1080w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/07a9c/disjoint_set-1.png 1440w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/17d12/disjoint_set-1.png 1666w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>기본적인 구현 방법</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합을 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_partent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화</span>\n\n<span class=\"token comment\"># 부모 테이블상에서, 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># Union 연산 각각 수행</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 각 원소가 속한 집합 출력</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"각 원소가 속한 집합: \"</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 부모 테이블 내용 출력하기</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'부모 테이블: '</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>‘기본적인 구현 방법’의 문제점</p>\n<ul>\n<li>Union 연산이 편향되게 이루어지는 경우 Find 함수가 비효율적으로 동작</li>\n<li>최악의 경우에는 Find 함수가 모든 노드를 다 확인하게 되어 시간 복잡도다 O(V)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABiElEQVQoz02RS4sTQRSF+/f6A9y5c6kuXbp0IwyKDMMM6CTd6XZQJpmeJJ1MhIQk/UgC6Uz6/f6kLiIWXM6pc27dunVLq+uaxWLBZDJhuVyy3+/Z7XZ4nsd6vZbwfV9QaSpntVqJdgxD1Hm1uq4T1Nq25XA4sNlspFiaJMRRRBzHpGkqkSQJURSRZxlZmgpv/ivUNM0/rvF3VXVNWTeotLKqyfOcsmllXxQFeVFQdVA3rXhZWVK1HVmWk2UZqjHpsKoq6rIgjc6kSUxRlkRxTHg8ck4SkrzgdDoRhiFxXhAnqXinKCItS57PZ05hKJeoWpp65q/fa67vJ3y3nzCfNqw2Lr7nSXiuK/NyXVd4EPgyHuUFvs92uxUvCAIZmaY+5N2lwYsPX3j56ZZXlz8Z3D8wdxzsx0dGowdmsxm2bTMajXAcR3A8HjOdThkOh4JKn8/naHd3P3h/ccXrj195+/kbby5uuLnVsUwT3TAwDAPTstB1nX6/j2magqKbJr1ej8FgINyyLP4AJ9P/2tPubNUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-2.png\"\n        title=\"최악의 경우 예시\"\n        src=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png\"\n        srcset=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/e9ff0/disjoint_set-2.png 180w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/f21e7/disjoint_set-2.png 360w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png 720w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/302a4/disjoint_set-2.png 1080w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/07a9c/disjoint_set-2.png 1440w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/96191/disjoint_set-2.png 2176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>Path Compression (경로 압축)</p>\n<ul>\n<li>Find 함수를 최적화하기 위한 방법</li>\n<li>Find 함수를 재귀적으로 호출한 뒤에 <strong>부모 테이블 값을 바로 갱신</strong>\n<ul>\n<li>Find 함수를 호출한 이후에 해당 노드의 root 노드가 바로 부모 노드가 됨</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>partent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드가 아니라면 root 노드를 찾을 때까지 재귀적으로 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"disjoint-set을-활용한-cycle-판별\" style=\"position:relative;\"><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\" aria-label=\"disjoint set을 활용한 cycle 판별 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disjoint Set을 활용한 Cycle 판별</h3>\n<ul>\n<li>서로소 집합은 <strong>무방향 그래프(Undirected Graph) 내에서의 사이클을 판별</strong>할 때 사용 가능\n<ul>\n<li>cf. 방향 그래프(Directed Graph)에서의 사이클 여부는 DFS를 이용하여 판별 가능</li>\n</ul>\n</li>\n<li>Cycle 판별 알고리즘\n<ol>\n<li>각 Edge를 하나씩 확인하여 두 노드의 root 노드를 확인함\n<ol>\n<li>root 노드가 서로 다르다면 두 노드에 대해 Union 수행</li>\n<li>root 노드가 서로 같다면 Cycle이 발생한 것임</li>\n</ol>\n</li>\n<li>그래프에 포함되어 있는 모든 Edge에 대해 1번 과정을 반복</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(Union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화하기</span>\n\n<span class=\"token comment\"># 부모 테이블에서 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\ncycle <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span> <span class=\"token comment\"># 사이클 발생 여부</span>\n\n<span class=\"token comment\"># Edge를 순회하며 cycle 탐색</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># cycle이 발생한 경우 종료</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        cycle <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">break</span>\n    <span class=\"token comment\"># cycle이 발생하지 않았다면 Union 연산 수행</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"there is cycle\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no cycle\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"2-minimum-spanning-tree-최소-신장-트리\" style=\"position:relative;\"><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\" aria-label=\"2 minimum spanning tree 최소 신장 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Minimum Spanning Tree (최소 신장 트리)</h2>\n<ul>\n<li>Spanning Tree: 그래프에서 <strong>모든 노드를 포함</strong>하면서 <strong>cycle이 존재하지 않는 부분 그래프</strong> 의미\n<ul>\n<li>cf. Tree의 조건: 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다</li>\n<li>Edge의 개수 = Vertex의 개수 - 1</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA70lEQVQY002ObW+DMAyE+f//a6q6VUzTNqFC2/HyYZogQCgqISE8k1PR7STL9tm+cwTgvWee55CttSzLwgbpnVtwy322IdzIrl+ZZxt6QbSJTdP0EJTaOYd1jts0Yaxj8R5j5oehZCNPrOv9xpjAR3JojAnqQqzrGgyE2752/0IMRGD7VubaedR4wxpDpLVGKcUwDNR1Td/3dF33F1rTdj2NUlzHEdW2YUeyHq781DXfnUY1DX1TExVFQVmWZFlGHMckSUJVVeR5TlkWJOmZ+D3l9SPl7TMjLwryy4XjfkcWH0hf9pwPzxx3T3ydMn4BG7x+0KXicSUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"spanning_tree-1.png\"\n        title=\"spanning_tree-1.png\"\n        src=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png\"\n        srcset=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/e9ff0/spanning_tree-1.png 180w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/f21e7/spanning_tree-1.png 360w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png 720w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/302a4/spanning_tree-1.png 1080w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/07a9c/spanning_tree-1.png 1440w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/b918a/spanning_tree-1.png 2780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>Minimum Spanning Tree: <strong>최소한의 비용으로 구성되는 신장 트리</strong></p>\n<ul>\n<li>e.g., N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 <strong>전체 도시가 서로 연결</strong>될 수 있게 도로를 설치하는 경우 (= 두 도시 A, B를 선택했을 때 A에서 B로 이동하는 경로가 반드시 존재)</li>\n</ul>\n</li>\n<li>\n<p><strong>Kruskal 알고리즘</strong></p>\n<ul>\n<li>대표적인 Minimum Spanning Tree 알고리즘</li>\n<li>Greedy 알고리즘</li>\n<li>동작 과정:\n<blockquote>\n<ol>\n<li>edge 데이터를 cost에 따라 <strong>오름차순으로 정렬</strong></li>\n<li>edge를 하나씩 확인하며 <strong>현재의 간선이 사이클을 발생시키는지 확인</strong>\n<ol>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시킴</li>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시키지 않음</li>\n</ol>\n</li>\n<li>모든 edge에 대해 2번 과정 반복</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 간선(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 자기 자신을 부모로 parent table 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># 모든 edge를 담을 리스트와 final cost를 담을 변수</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nresult <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 연산에 포함될 경우 = MST에 포함된다는 의미</span>\n\n<span class=\"token comment\"># 모든 간선에 대한 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> cost <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 cost으로 설정</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 cost순으로 정렬</span>\nedges<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 하나씩 확인해가며</span>\n<span class=\"token keyword\">for</span> edge <span class=\"token keyword\">in</span> edges<span class=\"token punctuation\">:</span>\n    cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> edge\n    <span class=\"token comment\"># 사이클이 발생하지 않는 경우에만 집합에 포함</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">+=</span> cost\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Kruskal 알고리즘의 성능 분석\n<ul>\n<li>시간 복잡도: O(ElogE) (Edge 개수 = E일 때)</li>\n<li>가장 많은 시간 요구하는 곳: edge 정렬 부분\n<ul>\n<li>표준 라이브러리(<code class=\"language-text\">sort()</code>)를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도: O(ElogE)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-topological-sort-위상-정렬\" style=\"position:relative;\"><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\" aria-label=\"3 topological sort 위상 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Topological Sort (위상 정렬)</h2>\n<ul>\n<li>**Cycle이 없는 Directed Graph(DAG, Directed Acyclic Graph)**의 모든 노드를 <strong>방향성에 거스르지 않도록 순서대로 나열</strong>\n<blockquote>\n<p>💡 DAG 여야하는 이유?\n: Cycle이 존재할 경우 Cycle이 존재하는 모든 노드의 Indegree가 1 이상이 되므로 다음 알고리즘을 사용할 경우, Cycle이 존재하는 모든 노드가 영원히 Queue에 들어갈 수 없음(=Sorting 수행할 수 없음)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>cf. Indegree와 Outdegree</p>\n<ul>\n<li>Indegree: 특정한 노드로 들어오는 edge의 개수</li>\n<li>Outdegree: 특정한 노드에서 나가는 edge의 개수</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Queue</strong>를 이용하는 Topological Sort 알고리즘 동작 과정\\</p>\n<ul>\n<li>각 노드가 Queue에 들어온 순서 = Topological Sort 수행 결과</li>\n</ul>\n<blockquote>\n<ol>\n<li>Indegree가 0인 모든 노드를 Queue에 넣음</li>\n<li>Queue가 빌 때까지 다음의 과정 반복</li>\n<li>Queue에서 원소를 꺼내 해당 노드에서 Outdegree를 그래프에서 제거함</li>\n<li>새롭게 Indegree가 0이 된 노드를 Queue에 넣음</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>Topological Sort 특징</p>\n<ul>\n<li>DAG (Direct Acyclic Graph), 순환하지 않는 방향 그래프에서만 수행 가능</li>\n<li><strong>여러 가지 답이 존재</strong>할 수 있음\n<ul>\n<li>한 단계에서 Queue에 새롭게 드어가는 원소가 2개 이상 있다면, 여러 가지 답이 존재</li>\n</ul>\n</li>\n<li><strong>모든 원소를 방문하기 전에 큐가 빈다면 Cycle이 존재</strong>한다고 판단\n<ul>\n<li>Cycle에 포함된 원소 중에서 어떠한 원소도 Queue에 들어가지 못함</li>\n</ul>\n</li>\n<li>Stack을 활용한 DFS를 이용해서도 Topological Sort 수행 가능</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\n<span class=\"token comment\"># 노드의 개수와 Edge의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 노드에 대한 indegree를 0으로 초기화</span>\nindegree <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결된 edge 정보를 담기 위한 연결 리스트 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> ragne<span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 방향 그래프의 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># A에서 B로 이동 가능</span>\n    <span class=\"token comment\"># indegree를 1 증가</span>\n    indegree<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># Topological Sort</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">topology_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># 알고리즘 수행 결과를 담을 리스트</span>\n    q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># queue</span>\n    <span class=\"token comment\"># 처음 시작할 때는 진입 차수가 0인ㅇ 노드를 queue에 삽입</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 큐가 빌 때까지 반복</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 큐에서 원소 꺼내기</span>\n        now <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 해당 원소와 연결된 노드들의 indegree에서 1 빼기</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token comment\"># 새롭게 indegree가 0이 되는 노드를 queue에 삽입</span>\n            <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Topological Sort 수행 결과 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> result<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\ntopology_sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Topology Sort의 성능 분석\n<ul>\n<li>시간 복잡도: O(V+E)</li>\n<li>차례대로 모든 Vertex를 확인해가며 각 Vertex에서 나가는 Edge를 차례대로 제거해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">1. Disjoint Sets (서로소 집합) 자료구조</a></p>\n<ul>\n<li><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\">Disjoint Set을 활용한 Cycle 판별</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\">2. Minimum Spanning Tree (최소 신장 트리)</a></p>\n</li>\n<li>\n<p><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\">3. Topological Sort (위상 정렬)</a></p>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 08, 2022","title":"Graph 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Graph/"}},"prev":{"id":"9dbf3f7c-995f-565b-9212-1338c7e081f8","html":"<h2 id=\"0-들어가기-전에\" style=\"position:relative;\"><a href=\"#0-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"0 들어가기 전에 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. 들어가기 전에</h2>\n<p>아직 면접 경험이 별로 없지만, 면접 기회가 생길 때마다 질문으로 나올 만한 CS 개념들을 정리해두면\n앞으로의 면접에서도 많은 도움을 받을 수 있지 않을까해서 정리해둔다.</p>\n<p>참고로, 아래에는 일반적인 CS 개념들도 포함되어 있지만\n일부는 내가 석사 과정동안 진행했던 연구들에 대한 개념들도 함께 들어있다.</p>\n<p>석사 과정동안 진행했던 연구의 키워드들은 조금 깊게,\n그리고 그 이외의 CS 키워드들은 좀 더 얕게 정리할 계획이다.</p>\n<p>참고로 면접에서는 장황하게 말하는 것보다, 키워드를 담은 한 문장으로 설명하는 것이 중요하더라.\n그래서 최대한 키워드를 담은 한 문장을 통해 개념을 설명하고, 추가 질문에 대비한 답변들도 정리해 둘 계획이다.</p>\n<p>지금 당장은 외국 기업 면접을 앞두고 있는터라, 영어로도 함께 정리해 둘 계획이다.</p>\n<p>큰 카테고리로 나누어서 개념들을 정리해두었다.</p>\n<h2 id=\"common-cs-interview\" style=\"position:relative;\"><a href=\"#common-cs-interview\" aria-label=\"common cs interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Common CS Interview</h2>\n<h3 id=\"1-os\" style=\"position:relative;\"><a href=\"#1-os\" aria-label=\"1 os permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. OS</h3>\n<ul>\n<li>‘Operating System’이라는 용어를 일반인에게 설명</li>\n</ul>\n<blockquote>\n<p>짧게 말하자면, ‘무엇인가를 수행’하기 위해서 하드웨어에 로드하는 소프트웨어를 말한다.\n예를 들어, 당신의 아이폰이라는 하드웨어에서 실행되는 iOS 운영 체제가 있다.\n<u>The short answer is that an operatin system is software that you load on your hardware to make it ‘do things’.</u>\n<u>The example is iOS operating system which runs on your iPhone hordware.</u></p>\n</blockquote>\n<ul>\n<li>Linux의 네트워크 인터페이스</li>\n</ul>\n<blockquote>\n<p>Loopback과 Ethernet이 있습니다. Loopback(lo)는 127.0.0.1 IP 주소를 가지며, Ethernet(eth0) 인터페이스는 DHCP에 의해 dynamic address를 부여받으며,</p>\n</blockquote>\n<ul>\n<li>Linux에서 네트워킹 도구 사례</li>\n</ul>\n<blockquote>\n<p>네트워크 도달 가능성을 테스트하기 위한 가장 기본적인 네트워크 테스트 도구인 Ping이 있으며, 네트워크를 통해 ICMP(Internet Control Message Protocol) 패킷을 보내고 응답이 있는지 알려준다. 호스트가 작동 중이고 네트워크에서 통신할 수 있는 경우, ICMP 응답이 반환된다.\n<u>Ping is the most basic network test tool around for testing network reachabiltiy, and it sends out an Internet Control Message Protocol (ICMP) patcket across the network and norifies you whether there is a reponse. If a host is up and able to communicate on the network, an ICMP response will be returned.</u>\n또 다른 도구는 네트워크 trouble shooting 도구인 traceroute이며, 로컬 시스템에서 출발하여 destination으로 도달하기까지 경로를 따라 라우팅되는 각 IP 라우터에 대한 정보를 수집한다. 이를 통해 어떤 노드가 문제를 일으키는지 확인할 수 있습니다.\n<u>Another Linux network trouble shooting tool is traceroute, and it proves the network between the local system and a destination, gathering information about each IP router in the path. It is usefuls when you want to find out which node is creating the problem.</u></p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Linux의 Inter-Process Communication 기술</strong></p>\n</li>\n<li>\n<p>System Daemon 설명</p>\n</li>\n</ul>\n<blockquote>\n<p>시스템 데몬은 일반적으로 작업을 시작하기 전에 특정 조건 집합을 기다리는 백그라운드 시스템 프로세스이며, 일반적으로는 사용자가 직접 제어하지 않고 시스템 자체에사 제어한다.\n<u>A system daemon is typically a background system process that awaits a specific set of conditions before jumping into action, and it is not typically under the direct control of users, but rather of the system itself.</u></p>\n</blockquote>\n<ul>\n<li>\n<p>Message Queue의 작업 설명</p>\n</li>\n<li>\n<p>Semaphore와 Busy Waiting 설명</p>\n<ul>\n<li>실제 사례를 사용하여 Busy Waiting 설명</li>\n</ul>\n</li>\n<li>\n<p><strong>Semaphore와 Mutex</strong></p>\n</li>\n<li>\n<p><strong>Multi-threading 설명</strong></p>\n<ul>\n<li>Multi-threading의 장점은 무엇인가?</li>\n</ul>\n</li>\n<li>\n<p>리눅스에서 실행 중인 프로세스의 PID를 가져오는 프로그램</p>\n</li>\n<li>\n<p><strong>스케줄링의 종류</strong></p>\n</li>\n<li>\n<p>한가지 프로세스 스케줄링 방법을 다른 스케줄링 방법으로 변환하는 방법</p>\n</li>\n<li>\n<p>Queue를 구현하지 위해서 몇 개의 Stack이 필요한가? 구현을 위한 Pseudo-code</p>\n</li>\n<li>\n<p>메모리의 유형</p>\n</li>\n<li>\n<p>Virtual Memory</p>\n</li>\n<li>\n<p>Cache memory와 Main Memory의 차이점</p>\n</li>\n<li>\n<p>System Call 설명</p>\n</li>\n<li>\n<p>Printf()는 어떻게 작동하는가?</p>\n</li>\n<li>\n<p>Deadlock</p>\n</li>\n<li>\n<p>Context Switching</p>\n</li>\n<li>\n<p>Paging과 Segmentation</p>\n</li>\n<li>\n<p>Process 상태와 속성</p>\n</li>\n<li>\n<p><strong>Thread</strong></p>\n<ul>\n<li>Thread 관련 프로그래밍</li>\n</ul>\n</li>\n<li>\n<p>라이브러리의 유형</p>\n<ul>\n<li>동적 라이브러리를 driver test 프로그램과 연결하는 방법</li>\n</ul>\n</li>\n<li>\n<p>시스템 간의 Synchronous &#x26; Asynchronous communication 방법</p>\n</li>\n<li>\n<p>Recycle bin(휴지통)의 내부 구현</p>\n</li>\n<li>\n<p>Atomic Transaction(원자적 트랜잭션) 설명</p>\n<ul>\n<li>트랜잭션이 atomic한지 어떻게 확인할 수 있는가?</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-network\" style=\"position:relative;\"><a href=\"#2-network\" aria-label=\"2 network permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Network</h3>\n<ul>\n<li>MAC 주소란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>MAC(Media Access Control) 주소는 OSI 모델의 데이터 링크 계층인 2계층에서 네트워크 인터페이스에 할당된 고유 식별자이며, 네트워크 인터페이스에는 IP 주소는 없더라도 하드웨어 주소라고도 하는 MAC 주소가 항상 존재한다.</p>\n</blockquote>\n<h2 id=\"research-interview\" style=\"position:relative;\"><a href=\"#research-interview\" aria-label=\"research interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Research Interview</h2>\n<h3 id=\"1-cloud-computing\" style=\"position:relative;\"><a href=\"#1-cloud-computing\" aria-label=\"1 cloud computing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Cloud Computing</h3>\n<ul>\n<li>\n<p>Cloud 기술은 무엇인가?</p>\n</li>\n<li>\n<p>Cloud Computing의 Key 특징은 무엇인가?</p>\n</li>\n<li>\n<p>Cloud Delivery Model에는 무엇이 있는가?</p>\n</li>\n<li>\n<p>Cloud Deployment Model에는 무엇이 있는가?</p>\n</li>\n<li>\n<p>Cloud Computing Architecture에 대해 설명하라</p>\n</li>\n<li>\n<p>Cloud의 Storage Level에는 무엇이 있는가?</p>\n</li>\n<li>\n<p>Microservice란 무엇인가?</p>\n</li>\n<li>\n<p>Cloud-Native Application이란 무엇인가?</p>\n</li>\n</ul>\n<h3 id=\"2-container\" style=\"position:relative;\"><a href=\"#2-container\" aria-label=\"2 container permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Container</h3>\n<ul>\n<li>Container란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>컨테이너란 개념적으로 단지 namespaced되고 isolated된 프로세스이다.\n<u>Containers are just conceptually namespaced and isolated processes.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- Virtual Machine과의 차이점은 무엇인가?\n- 가상화는 어떤 종류가 있는가?</code></pre></div>\n<ul>\n<li>하이퍼바이저란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>하이퍼바이저란 VM이 작동하도록 만드는 소프트웨어를 말하며, Linux에는 KVM이 포함되어 있다.\n<u>Hypervisor is a software that allow VMs to function, and Linux includes an excellent hypervisor called KVM</u></p>\n</blockquote>\n<ul>\n<li>\n<p>Container Image란 무엇인가?</p>\n</li>\n<li>\n<p>Container가 실행되는 단계를 설명하라</p>\n</li>\n<li>\n<p>Docker란 무엇인가?</p>\n</li>\n<li>\n<p>Kubenetes란 무엇인가?</p>\n</li>\n<li>\n<p>gVisor에 대해 설명하라</p>\n</li>\n<li>\n<p>Kata Container에 대해 설명하라</p>\n</li>\n<li>\n<p>Container Runtime이란 무엇인가?</p>\n</li>\n<li>\n<p>OCI란 무엇인가?</p>\n</li>\n<li>\n<p>CRI란 무엇인가?</p>\n</li>\n</ul>\n<h3 id=\"3-program-analysis\" style=\"position:relative;\"><a href=\"#3-program-analysis\" aria-label=\"3 program analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Program Analysis</h3>\n<ul>\n<li>\n<p>GCC란 무엇인가?</p>\n<ul>\n<li>GCC IR은 무엇인가?</li>\n<li>GCC의 컴파일 단계에 대해 설명하라</li>\n</ul>\n</li>\n<li>\n<p>LLVM은 무엇인가?</p>\n<ul>\n<li>LLVM IR은 무엇인가?</li>\n<li>LLVM의 컴파일 단계에 대해 설명하라</li>\n</ul>\n</li>\n<li>\n<p>Clang은 무엇인가?</p>\n</li>\n<li>\n<p>GCC와 LLVM의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>컴파일 단계에 대해 설명하라</p>\n</li>\n<li>\n<p>ftrace는 무엇인가?</p>\n<ul>\n<li>이외 다른 트레이싱 도구는 무엇이 있는가?</li>\n<li>ftrace가 다른 트레이싱 도구들에 비해 가지는 장점이 있는가?</li>\n</ul>\n</li>\n<li>\n<p>동적 분석은 무엇인가</p>\n<ul>\n<li>동적 분석 기법을 아는대로 말해보라</li>\n</ul>\n</li>\n<li>\n<p>정적 분석은 무엇인가</p>\n<ul>\n<li>정적 분석 기법을 아는대로 말해보라</li>\n</ul>\n</li>\n<li>\n<p>동적 분석과 정적 분석의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>라이브러리란 무엇인가?</p>\n</li>\n<li>\n<p>API란 무엇인가?</p>\n</li>\n<li>\n<p>라이브러리 함수란 무엇인가?</p>\n</li>\n</ul>\n<h3 id=\"4-linux-kernel\" style=\"position:relative;\"><a href=\"#4-linux-kernel\" aria-label=\"4 linux kernel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Linux Kernel</h3>\n<ul>\n<li>Kernel이란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>커널은 컴퓨터를 시작할 때 <strong>가장 첫 번째로 로드되는 프로그램</strong>으로써, CPU 하드웨어를 제어하고, 메모리를 할당하고, 데이터에 액세스하고, 프로세스를 스케쥴링하고, 애플리케이션을 실행시키고, 서로 다른 애플리케이션의 실행을 보호하는 역할을 수행하는 운영체제의 매우 특수한 부분을 일컬음\n하드웨어 및 소프트웨어 프로세스를 관리하는 커널 외에도 Linux distribution에는 하드웨어 액세스 및 제어를 위한 device driver, shared libraies, 애플리케이션, 백그라운드에서 실행하면서 네트워크 요청에 응답하는 시스템 데몬과 같은 리눅스 소프트웨어 집합이 포함된다.\n<u>The kernel is the first program loaded on the computer when the computer starts up, and it is the special piece of the operating system that controls the CPU harware, allocates memory, access data, schedules processes, runts the applications, and protects them from each other.</u>\n<u>Linux distributions include collection of Linnux sortware, such as device drivers for accessing and controlling hardware, shared libraries, applications, and system daemons, which run in the background and respond to network requests.</u></p>\n</blockquote>\n<ul>\n<li>Linux Distribution이란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>Distribution은 리눅스 커널의 특정 버전과 함께 해당 커널 버전과 호환되고 상호 운영성 테스트를 거친 다양한 라이브러리, 시스템 데몬, 개발 도구, 애플리케이션, 패키징 및 life-cycle 관리 도구의 조합을 일컫는다.\nLinux Distribution의 예로는 Ubuntu, Debian, Fedora, openSUSE, Cumulus Linux가 있다.\n<u>A distribution is the combination of specific versions of the Linux Kernel with other libraries, system daemons, development tools, applications, packaging, and life-cycle management tools that are compatible with each other and tested for interoperability.</u>\n<u>Exmaples of Linux distributions are Ubuntu, Debian, Fedora, openSUSE, and Cumulus Linux</u></p>\n</blockquote>\n<ul>\n<li>Kernel Space와 User Space의 차이는 무엇인가?</li>\n</ul>\n<blockquote>\n<p>커널 공간과 사용자 공간의 분리는 가능한 한 안정적으로 안전한 운영 체제임을 보장하기 위해 만들어졌다.\n운영 체제는 커널로부터 시스템이 종료되거나 시스템이 충돌나는 것을 방지하기 위해 보호되고 제한된 메모리에서 커널을 실행하는데, 이 공간을 커널 공간이라고 한다.\n사용자가 애플리케이션이나 툴을 실행할때, 이러한 애플리케이션이나 도구가 실행되는 공간을 유저 공간이라고 한다.\n<u>In short, the separation beween user space and kernel space is made to ensure that Linux is as reliable and secure an operating system as possible</u>\n<u>Operating systems executes their kernel in protected and restricted memory that is called kernel space to prevent the kernel from terminating and crashing the system.</u>\n<u>When a user runs an application or tool, that application or tool executes in what is called user space.</u></p>\n</blockquote>\n<ul>\n<li>시스템콜이란 무엇인가?</li>\n</ul>\n<blockquote>\n</blockquote>\n<h3 id=\"5-research---security\" style=\"position:relative;\"><a href=\"#5-research---security\" aria-label=\"5 research   security permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Research - Security</h3>\n<ul>\n<li>\n<p>Malware란 무엇인가?</p>\n</li>\n<li>\n<p>Exploit이란 무엇인가?</p>\n</li>\n<li>\n<p>Malware와 Exploit의 차이점은?</p>\n</li>\n<li>\n<p>Vulnerability란 무엇인가?</p>\n</li>\n<li>\n<p>CVE란 무엇인가?</p>\n</li>\n<li>\n<p>Seccomp란 무엇인가?</p>\n<ul>\n<li>Seccomp와 Seccomp-BPF의 차이점은 무엇인가?</li>\n</ul>\n</li>\n<li>\n<p>Container Escape/Break-Out이 무엇인가?</p>\n</li>\n<li>\n<p>Container 환경에서 Threat Model은 무엇이 있는가?</p>\n</li>\n<li>\n<p>BPF-LSM이란 무엇인가?</p>\n<ul>\n<li>KRSI와 BPF-LSM의 차이점은 무엇인가?</li>\n</ul>\n</li>\n<li>\n<p>LSM이란 무엇인가?</p>\n<ul>\n<li>\n<p>AppArmor와 SELinux의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>LSM Hook이란 무엇인가?</p>\n</li>\n</ul>\n</li>\n<li>\n<p>MAC과 DAC의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>eBPF란 무엇인가?</p>\n</li>\n<li>\n<p>Security Policy란 무엇인가?</p>\n</li>\n<li>\n<p>Libbpfgo란 무엇인가?</p>\n</li>\n<li>\n<p>BTF란 무엇인가?</p>\n</li>\n<li>\n<p>CO-RE란 무엇인가?</p>\n</li>\n<li>\n<p>BPF Map이란 무엇인가?</p>\n</li>\n<li>\n<p>bpfbox에 대해 설명해달라</p>\n</li>\n<li>\n<p>bpfcontian에 대해 설명해달라</p>\n</li>\n<li>\n<p>bpfbox와 bpfcontain의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>KubeArmor에 대해 설명해달라</p>\n</li>\n<li>\n<p>bpfbox, bpfcontainer과 KubeArmor의 차이점은 무엇인가?</p>\n</li>\n</ul>\n<h3 id=\"6-research---data-analysis\" style=\"position:relative;\"><a href=\"#6-research---data-analysis\" aria-label=\"6 research   data analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Research - Data Analysis</h3>\n<ul>\n<li>\n<p>N-gram이란 무엇인가</p>\n</li>\n<li>\n<p>Word Embedding이란 무엇인가</p>\n<ul>\n<li>Word embedding 기법을 아는대로 말해보라</li>\n</ul>\n</li>\n<li>\n<p>GSP 알고리즘을 설명하라</p>\n<ul>\n<li>GSP 알고리즘 이외에 패턴 매칭(mining) 알고리즘을 말해보라</li>\n</ul>\n</li>\n<li>\n<p>TF-IDF란 무엇인가</p>\n<ul>\n<li>다른 IR 기법은 무엇이 있는가?</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://www.interviewbit.com/cloud-computing-interview-questions/\">https://www.interviewbit.com/cloud-computing-interview-questions/</a></li>\n<li><a href=\"https://velog.io/@jeon3029/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B3%B5%ED%95%99-CS-%EA%B3%B5%EB%B6%80%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%A7%81%ED%81%AC%EB%8B%A8%EC%88%9C-%EB%A7%81%ED%81%AC-%EB%AA%A8%EC%9D%8C\">https://velog.io/@jeon3029/컴퓨터-공학-CS-공부를-위한-유용한-링크단순-링크-모음</a></li>\n<li><a href=\"https://www.actualtechmedia.com/wp-content/uploads/2017/12/CUMULUS-NETWORKS-Linux101.pdf\">https://www.actualtechmedia.com/wp-content/uploads/2017/12/CUMULUS-NETWORKS-Linux101.pdf</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#0-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\">0. 들어가기 전에</a></p>\n</li>\n<li>\n<p><a href=\"#common-cs-interview\">Common CS Interview</a></p>\n<ul>\n<li><a href=\"#1-os\">1. OS</a></li>\n<li><a href=\"#2-network\">2. Network</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#research-interview\">Research Interview</a></p>\n<ul>\n<li><a href=\"#1-cloud-computing\">1. Cloud Computing</a></li>\n<li><a href=\"#2-container\">2. Container</a></li>\n<li><a href=\"#3-program-analysis\">3. Program Analysis</a></li>\n<li><a href=\"#4-linux-kernel\">4. Linux Kernel</a></li>\n<li><a href=\"#5-research---security\">5. Research - Security</a></li>\n<li><a href=\"#6-research---data-analysis\">6. Research - Data Analysis</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 16, 2022","title":"CS 면접 대비","categories":"Interview","author":"Mini","emoji":"📚"},"fields":{"slug":"/CS_Interview/"}},"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/Shortest_Path/","nextSlug":"/Graph/","prevSlug":"/CS_Interview/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}