{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Shortest_Path/",
    "result": {"data":{"cur":{"id":"290d3173-ced6-596b-ace6-0bac606c540c","html":"<ul>\n<li>가장 짧은 경로를 찾는 알고리즘</li>\n<li>최단 경로 알고리즘이 사용될 수 있는 다양한 문제 상황\n<ul>\n<li>한 지점에서 다른 한 지점까지의 최단 경로</li>\n<li>한 지점에서 다른 모든 지점까지의 최단 경로</li>\n<li>모든 지점에서 다른 모든 지점까지의 최단 경로</li>\n</ul>\n</li>\n<li>Dynamic Programming 문제로 분류되기도 함</li>\n</ul>\n<h2 id=\"1-dijkstra-shortest-path-알고리즘\" style=\"position:relative;\"><a href=\"#1-dijkstra-shortest-path-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"1 dijkstra shortest path 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Dijkstra Shortest Path 알고리즘</h2>\n<ul>\n<li><strong>특정한 한 노드</strong>에서 출발하여 <strong>다른 모든 노드</strong>로 가는 최단 경로 계산</li>\n<li>조건: <strong>음수 Edge가 없을 때</strong> (현실 세계의 도로)</li>\n<li>Greedy 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 Node를 선택</li>\n</ul>\n<blockquote>\n<p>💡 알고리즘 동작 과정</p>\n<ol>\n<li>출발 노드 설정</li>\n<li>최단 거리 테이블 초기화 (모든 노드까지의 거리 무한으로 설정 &#x26; 자기 자신까지의 거리는 0으로 설정)\n<ul>\n<li>최단 거리 테이블: 각 노드에 대한 현재끼ㅏ지의 최단 거리 정보 저장</li>\n</ul>\n</li>\n<li>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택</li>\n<li>해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신</li>\n<li>위 과정에서 3번과 4번을 반복</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>Dijkstra 알고리즘 특징</p>\n<ul>\n<li>Greedy 알고리즘: 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정 반복</li>\n</ul>\n</li>\n<li>\n<p>단계를 거치며 <strong>한 번 처리된 노드의 최단 거리는 고정</strong>되어 더 이상 바뀌지 않음</p>\n<ul>\n<li>한 단계당 하나의 노드에 대한 최단 거리를 확실하게 찾음</li>\n</ul>\n</li>\n<li>\n<p>알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 <strong>거리</strong> 정보만 저장됨</p>\n<ul>\n<li>완벽한 형태의 최단 <strong>경로</strong>를 구하려면 소스코드에 추가적인 기능을 더 넣어야 함</li>\n</ul>\n</li>\n<li>\n<p>간단한 구현 방법</p>\n<ul>\n<li>단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 <strong>매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력 받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 방문한 적이 있는지 체크하는 목적의 리스트</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_smallest_node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    min_value <span class=\"token operator\">=</span> INF\n    index <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\"># 가장 최단 거리가 짧은 노드(인덱스)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min_value <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            min_value <span class=\"token operator\">=</span> distnace<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            index <span class=\"token operator\">=</span> i\n    <span class=\"token keyword\">return</span> index\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    visited<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    <span class=\"token comment\"># 시작 노드와 연결된 노드까지의 거리</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드를 제외한 전체 n-1개의 노드에 대해 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리</span>\n        now <span class=\"token operator\">=</span> get_smallest_node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        visited<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 노드 확인</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐 해당 노드로 갈 때의 거리</span>\n            cost <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서 해당 노드로 이동하는 거리가 더 짧은 경우 최단 거리 테이블 update</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n\n<span class=\"token comment\"># 다익스트라 알고리즘 수행</span>\ndikstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한(INFINITY)라고 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도달할 수 있는 경우 거리 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distnace<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>‘간단한 구현 방법’ 성능 분석</p>\n<ul>\n<li>전체 시간 복잡도: <strong>O(V^2)</strong>\n<ul>\n<li>총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색</li>\n</ul>\n</li>\n<li>전체 노드의 개수가 5,000개 이하일 경우 가능 BUT <strong>만 개를 넘어간다면 불가능</strong></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 우선순위 큐 (Priority Queue)\n: 우선 순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조\ne.g., 여러 개의 물건 데이터를 자료 구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는 경우</p>\n<ul>\n<li>Heap: Priority Queue를 구현하기 위해 사용하는 자료구조\n<ul>\n<li>Min Heap &#x26; Max Heap 존재</li>\n</ul>\n</li>\n<li>시간 복잡도: O(NlogN) (merge sort, quick sort와 동일)</li>\n</ul>\n</blockquote>\n<p><a href=\"https://sominsong.github.io/Data_Structure/#1-priority-queue-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90--heap-%ED%9E%99\">Priority 정리 참고</a></p>\n<ul>\n<li>\n<p>개선된 구현 방법</p>\n<ul>\n<li>단계마다 <strong>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택</strong>하기 위해 <strong>Heap</strong> 자료구조 이용</li>\n<li>알고리즘이 동작하는 기본 원리는 동일</li>\n<li>현재 가장 가까운 노드를 저장해 놓기 위해 Heap 자료구조를 추가로 이용한다는 점이 다름</li>\n<li>현재의 최단 거리가 가장 짧은 노드를 선택해야 함으로 <strong>Min Heap 사용</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq\n<span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력 받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">#### 여기까지는 기존 방법과 동일 ####</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dikstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    q <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드로 가기 위한 최단 경로르 0으로 설정, 큐에 삽입</span>\n    heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>    <span class=\"token comment\"># 큐가 비어있지 않다면</span>\n        <span class=\"token comment\"># 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기</span>\n        dist<span class=\"token punctuation\">,</span> now <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 현재 노드가 이미 처리된 적이 있는 노드라면 무시</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 인접 노드들 확인</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            cost <span class=\"token operator\">=</span> dist <span class=\"token operator\">+</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n                heapq<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 다익스트라 알고리즘 수행</span>\ndijkstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한으로 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도다랗ㄹ 수 있는 경우 거리 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>‘개선된 구현 방법’ 성능 분석</p>\n<ul>\n<li>시간 복잡도: O(ElogV)\n<ul>\n<li>노드를 하나씩 꺼내 검사하는 반복문(<code class=\"language-text\">while</code>문)은 노드의 개수 V 이상 처리되지 않음\n: 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 최대 edge의 개수(E)만큼 수행됨</li>\n</ul>\n</li>\n<li>직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사\n<ul>\n<li>O(ElogE)로 판단할 수 있음</li>\n<li>중복 간선을 초함하지 않는 경우 O(ElogV)로 정리 가능\n: O(ElogE) -> O(ElogV^2) -> O(2ElogV) -> O(ElogV)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-floyd-warshall-알고리즘\" style=\"position:relative;\"><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"2 floyd warshall 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Floyd-Warshall 알고리즘</h2>\n<ul>\n<li><strong>모든 노드</strong>에서 <strong>다른 모든 노드</strong>까지의 최단 경로를 모두 계산</li>\n<li>다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘 수행\n<ul>\n<li>다만 매 단계마다 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾는 과정 필요하지 않음</li>\n</ul>\n</li>\n<li>2차원 테이블에 최단 거리 정보 저장</li>\n<li>Dynamic Programming 유형에 속함: 2차원 최단 거리 테이블을 점화식으로 update\n<ul>\n<li>각 단계마다 <strong>특정한 노드 K를 거쳐 가는 경우 확인</strong>: a에서 b로 가는 최단 거리보다 a에서 k를 거처 b로 가는 거리가 더 짧은지 검사</li>\n<li>점화식: <code class=\"language-text\">D_ab = min(D_ab, D_ak + D_kb)</code></li>\n</ul>\n</li>\n<li>시간 복잡도: O(N^3) -> 노드가 적은 경우에만 이용할 수 있음</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">INF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수 및 간선의 개수를 입력받기</span>\nn <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nm <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 2차원 리스트(그래프 표현)를 만들고, 무한으로 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화</span>\n<span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token operator\">==</span>b<span class=\"token punctuation\">:</span>\n            graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token comment\"># 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># A에서 B로 가는 비용은 C라고 설정</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c\n\n<span class=\"token comment\"># 점화식에 따라 플로이스 워션 알고리즘 수행</span>\n<span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>graph<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 수행된 결과를 출력</span>\n<span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 도달할 수 없는 경우, 무한</span>\n        <span class=\"token keyword\">if</span> graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 도달할 수 있는 경우, 거리 출력</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Floyd-Warshall 알고리즘 성능 분석\n<ul>\n<li>시간 복잡도: O(N^3)\n<ul>\n<li>노드의 개수가 N개일 때, 알고리즘 상으로 N번의 단계(k를 거쳐 가는 경우)를 수행함</li>\n<li>각 단계마다 O(N^2)의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려함</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-bellman-ford-알고리즘\" style=\"position:relative;\"><a href=\"#3-bellman-ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"3 bellman ford 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Bellman-Ford 알고리즘</h2>\n<ul>\n<li>\n<p>조건: 음수 Edge가 포함된 상황에서의 최단 거리 문제</p>\n<ul>\n<li>e.g. <a href=\"https://www.acmicpc.net/problem/11657\">https://www.acmicpc.net/problem/11657</a></li>\n<li>음수 Edge에 대한 최단 경로 문제의 분류\n<ol>\n<li>모든 edge가 양수인 경우</li>\n<li>음수 edge가 있는 경우\n<ol>\n<li>음수 edge cycle이 없는 경우</li>\n<li>음수 edge cycle이 있는 경우</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Bellan-Ford 알고리즘</p>\n<ul>\n<li>음수 edge가 포함된 상황에서 사용 가능</li>\n<li>음수 edge의 cycle 감지 가능</li>\n<li>기본 시간 복잡도: O(VE)\n<ul>\n<li>Dijkstra 알고리즘에 비해 느림</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Bellman-Ford 알고리즘 동작 과정</p>\n<ol>\n<li>출발 노드 설정</li>\n<li>최단 거리 테이블 초기화</li>\n<li>다음 과정은 N-1번 반복\n<ol>\n<li>전체 edge E개를 하나씩 확인함</li>\n<li>각 edge를 거쳐 다른 노드로 가는 비용을 계산하여 최단거리 테이블 update</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>If, 음수 edge cycle이 발생하는지 체크하고 싶다면 3번의 과정을 한 번 더 수행\n<ul>\n<li>이 때, 최단거리 테이블이 update된다면 음수 edge cycle이 존재한다는 의미</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 Bellman-Ford 알고리즘 v.s. Dijkstra 알고리즘</p>\n<ul>\n<li>Dijkstra 알고리즘\n<ul>\n<li><strong>매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택</strong></li>\n<li>음수 edge가 없다면 최적의 해를 찾을 수 있음</li>\n</ul>\n</li>\n<li>Bellman-Ford 알고리즘\n<ul>\n<li><strong>매번 모든 edge를 전부 확인함</strong>-> 따라서 <strong>Dijkstra 알고리즘에서의 최적의 해를 항상 포함</strong></li>\n<li>Dijkstra 알고리즘에 비해서 시간이 오래 걸리지만 음수 edge cycle을 탐지할 수 있음</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>realine\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 무한을 의미하는 값으로 10억 설정</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bf</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    dist<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\"># 전체 n번의 round를 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 매 반복마다 '모든 edge'를 확인하며</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            cur <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n            next_node <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            cost <span class=\"token operator\">=</span> edge<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 edge를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> INF <span class=\"token keyword\">and</span> dist<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> cost<span class=\"token punctuation\">:</span>\n                dist<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> cost\n                <span class=\"token comment\"># n번째 라운드에서도 값이 갱신된다면 음수 cycle이 존재</span>\n                <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> n <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n<span class=\"token comment\"># 노드의 개수, edge의 개수 입력받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 edge에 대한 정보를 담는 리스트 만들기</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 edge 정보를 입력받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 벨만 포드 알고리즘 수행</span>\nnegative_cycle <span class=\"token operator\">=</span> bf<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 1번 노드가 시작 노드</span>\n\n<span class=\"token keyword\">if</span> negative_cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1번 노드를 제외한 다른 모든 노드로 가기 위한 최단 거리 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 도달할 수 없는 경우 -1 출력</span>\n        <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 도달할 수 있는 경우 거리 출력</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-dijkstra-shortest-path-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">1. Dijkstra Shortest Path 알고리즘</a></li>\n<li><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">2. Floyd-Warshall 알고리즘</a></li>\n<li><a href=\"#3-bellman-ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">3. Bellman-Ford 알고리즘</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","excerpt":"가장 짧은 경로를 찾는 알고리즘 최단 경로 알고리즘이 사용될 수 있는 다양한 문제 상황 한 지점에서 다른 한 지점까지의 최단 경로 한 지점에서 다른 모든 지점까지의 최단 경로 모든 지점에서 다른 모든 지점까지의 최단 경로 Dynamic Programming 문제로 분류되기도 함 1. Dijkstra Shortest Path 알고리즘 특정한 한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로 계산 조건: 음수 Edge가 없을 때 (현실 세계의 도로) Greedy 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 Node를 선택 💡 알고리즘 동작 과정 출발 노드 설정 최단 거리 테이블 초기화 (모든 노드까지의 거리 무한으로 설정 & 자기 자신까지의 거리는 0으로 설정) 최단 거리 테이블: 각 노드에 대한 현재끼ㅏ지의 최단 거리 정보 저장 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신 위 과정에…","frontmatter":{"date":"November 07, 2022","title":"Shortest Path 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Shortest_Path/"}},"next":{"id":"c5fd76b3-665f-5351-a848-10ac2f57916d","html":"<h2 id=\"1-disjoint-sets-서로소-집합-자료구조\" style=\"position:relative;\"><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"1 disjoint sets 서로소 집합 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Disjoint Sets (서로소 집합) 자료구조</h2>\n<ul>\n<li>\n<p>서로소: ‘공통 원소가 없는 두 집합’ 의미</p>\n</li>\n<li>\n<p>서로소 집합 자료구조: 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조</p>\n</li>\n<li>\n<p>서로소 집합 자료구조(= <strong>Union Find 자료구조</strong>)의 연산</p>\n<ul>\n<li><strong>Union(합집합)</strong></li>\n<li><strong>Find(찾기)</strong>: 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산</li>\n</ul>\n</li>\n<li>\n<p>서로소 집합 자료구조 동작 과정</p>\n<ol>\n<li>Union 연산 확인 -> 서로 연결된 두 노드 A, B 확인\n<ol>\n<li>A와 B의 루트 노드 A’, B’를 각각 찾음</li>\n<li>A’를 B’의 부모 노드로 설정</li>\n</ol>\n</li>\n<li>모든 Union 연산을 처리할 때까지 1번 과정 반복</li>\n</ol>\n</li>\n<li>\n<p>서로소 집합 자료구조의 연결성</p>\n<ul>\n<li>기본적인 형태로 서로소 집합 자료구조에서는 root 노드에 즉시 접근할 수 없음\n-> root 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야 함</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABWElEQVQoz22PQU/CQBCF+6c96NWDJ3+GF9GTiSEaEhI1lBZtDdaWEoQ2ECPQbUvbBbbbPrOLJdQwyZd5szvvZVcpyxKiqp7nuaQqoTnn+x3GGIqiqHlEr1AqUZlplmFNqQwRc5omoJTKEBGWJLv5WJgMxEGJkCiOsUoSlEWBgnMsAyJnlCVyxkAIQZqm+8D/pYgQgfxGWSDbbLHI1mCcY81yLLM1ArrBlnNQliOmG/lysV95D1HiOEYURViQEPOAYElCkDDCT0AwJwSrv/vdHEp9iPAfonzPZhhMfFw+6Di/beGiqaNjjzDzJ/B9H+PxGK7rSu17HobDIb5GI3ieJ8+m02kNxR04eLVsnFzd4/S6hbM7Fc2uAcfq48Oy0O/3YZgmLMuSvJkm3lUVlmHg07bhOE4NpdfroaNpaDy2cdN6QqP1jPZLB7rWRbe7Q1XVo1rTNOi6XuMXuy1T+a8HV44AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-1.png\"\n        title=\"노드 3의 root를 찾기 위해 노드 2를 거쳐 노드 1에 접근해야 함\"\n        src=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png\"\n        srcset=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/e9ff0/disjoint_set-1.png 180w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/f21e7/disjoint_set-1.png 360w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png 720w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/302a4/disjoint_set-1.png 1080w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/07a9c/disjoint_set-1.png 1440w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/17d12/disjoint_set-1.png 1666w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>기본적인 구현 방법</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합을 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_partent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화</span>\n\n<span class=\"token comment\"># 부모 테이블상에서, 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># Union 연산 각각 수행</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 각 원소가 속한 집합 출력</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"각 원소가 속한 집합: \"</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 부모 테이블 내용 출력하기</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'부모 테이블: '</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>‘기본적인 구현 방법’의 문제점</p>\n<ul>\n<li>Union 연산이 편향되게 이루어지는 경우 Find 함수가 비효율적으로 동작</li>\n<li>최악의 경우에는 Find 함수가 모든 노드를 다 확인하게 되어 시간 복잡도다 O(V)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABiElEQVQoz02RS4sTQRSF+/f6A9y5c6kuXbp0IwyKDMMM6CTd6XZQJpmeJJ1MhIQk/UgC6Uz6/f6kLiIWXM6pc27dunVLq+uaxWLBZDJhuVyy3+/Z7XZ4nsd6vZbwfV9QaSpntVqJdgxD1Hm1uq4T1Nq25XA4sNlspFiaJMRRRBzHpGkqkSQJURSRZxlZmgpv/ivUNM0/rvF3VXVNWTeotLKqyfOcsmllXxQFeVFQdVA3rXhZWVK1HVmWk2UZqjHpsKoq6rIgjc6kSUxRlkRxTHg8ck4SkrzgdDoRhiFxXhAnqXinKCItS57PZ05hKJeoWpp65q/fa67vJ3y3nzCfNqw2Lr7nSXiuK/NyXVd4EPgyHuUFvs92uxUvCAIZmaY+5N2lwYsPX3j56ZZXlz8Z3D8wdxzsx0dGowdmsxm2bTMajXAcR3A8HjOdThkOh4JKn8/naHd3P3h/ccXrj195+/kbby5uuLnVsUwT3TAwDAPTstB1nX6/j2magqKbJr1ej8FgINyyLP4AJ9P/2tPubNUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-2.png\"\n        title=\"최악의 경우 예시\"\n        src=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png\"\n        srcset=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/e9ff0/disjoint_set-2.png 180w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/f21e7/disjoint_set-2.png 360w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png 720w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/302a4/disjoint_set-2.png 1080w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/07a9c/disjoint_set-2.png 1440w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/96191/disjoint_set-2.png 2176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>Path Compression (경로 압축)</p>\n<ul>\n<li>Find 함수를 최적화하기 위한 방법</li>\n<li>Find 함수를 재귀적으로 호출한 뒤에 <strong>부모 테이블 값을 바로 갱신</strong>\n<ul>\n<li>Find 함수를 호출한 이후에 해당 노드의 root 노드가 바로 부모 노드가 됨</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>partent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드가 아니라면 root 노드를 찾을 때까지 재귀적으로 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"disjoint-set을-활용한-cycle-판별\" style=\"position:relative;\"><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\" aria-label=\"disjoint set을 활용한 cycle 판별 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disjoint Set을 활용한 Cycle 판별</h3>\n<ul>\n<li>서로소 집합은 <strong>무방향 그래프(Undirected Graph) 내에서의 사이클을 판별</strong>할 때 사용 가능\n<ul>\n<li>cf. 방향 그래프(Directed Graph)에서의 사이클 여부는 DFS를 이용하여 판별 가능</li>\n</ul>\n</li>\n<li>Cycle 판별 알고리즘\n<ol>\n<li>각 Edge를 하나씩 확인하여 두 노드의 root 노드를 확인함\n<ol>\n<li>root 노드가 서로 다르다면 두 노드에 대해 Union 수행</li>\n<li>root 노드가 서로 같다면 Cycle이 발생한 것임</li>\n</ol>\n</li>\n<li>그래프에 포함되어 있는 모든 Edge에 대해 1번 과정을 반복</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(Union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화하기</span>\n\n<span class=\"token comment\"># 부모 테이블에서 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\ncycle <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span> <span class=\"token comment\"># 사이클 발생 여부</span>\n\n<span class=\"token comment\"># Edge를 순회하며 cycle 탐색</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># cycle이 발생한 경우 종료</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        cycle <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">break</span>\n    <span class=\"token comment\"># cycle이 발생하지 않았다면 Union 연산 수행</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"there is cycle\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no cycle\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"2-minimum-spanning-tree-최소-신장-트리\" style=\"position:relative;\"><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\" aria-label=\"2 minimum spanning tree 최소 신장 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Minimum Spanning Tree (최소 신장 트리)</h2>\n<ul>\n<li>Spanning Tree: 그래프에서 <strong>모든 노드를 포함</strong>하면서 <strong>cycle이 존재하지 않는 부분 그래프</strong> 의미\n<ul>\n<li>cf. Tree의 조건: 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다</li>\n<li>Edge의 개수 = Vertex의 개수 - 1</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA70lEQVQY002ObW+DMAyE+f//a6q6VUzTNqFC2/HyYZogQCgqISE8k1PR7STL9tm+cwTgvWee55CttSzLwgbpnVtwy322IdzIrl+ZZxt6QbSJTdP0EJTaOYd1jts0Yaxj8R5j5oehZCNPrOv9xpjAR3JojAnqQqzrGgyE2752/0IMRGD7VubaedR4wxpDpLVGKcUwDNR1Td/3dF33F1rTdj2NUlzHEdW2YUeyHq781DXfnUY1DX1TExVFQVmWZFlGHMckSUJVVeR5TlkWJOmZ+D3l9SPl7TMjLwryy4XjfkcWH0hf9pwPzxx3T3ydMn4BG7x+0KXicSUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"spanning_tree-1.png\"\n        title=\"spanning_tree-1.png\"\n        src=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png\"\n        srcset=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/e9ff0/spanning_tree-1.png 180w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/f21e7/spanning_tree-1.png 360w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png 720w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/302a4/spanning_tree-1.png 1080w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/07a9c/spanning_tree-1.png 1440w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/b918a/spanning_tree-1.png 2780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>Minimum Spanning Tree: <strong>최소한의 비용으로 구성되는 신장 트리</strong></p>\n<ul>\n<li>e.g., N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 <strong>전체 도시가 서로 연결</strong>될 수 있게 도로를 설치하는 경우 (= 두 도시 A, B를 선택했을 때 A에서 B로 이동하는 경로가 반드시 존재)</li>\n</ul>\n</li>\n<li>\n<p><strong>Kruskal 알고리즘</strong></p>\n<ul>\n<li>대표적인 Minimum Spanning Tree 알고리즘</li>\n<li>Greedy 알고리즘</li>\n<li>동작 과정:\n<blockquote>\n<ol>\n<li>edge 데이터를 cost에 따라 <strong>오름차순으로 정렬</strong></li>\n<li>edge를 하나씩 확인하며 <strong>현재의 간선이 사이클을 발생시키는지 확인</strong>\n<ol>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시킴</li>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시키지 않음</li>\n</ol>\n</li>\n<li>모든 edge에 대해 2번 과정 반복</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 간선(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 자기 자신을 부모로 parent table 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># 모든 edge를 담을 리스트와 final cost를 담을 변수</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nresult <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 연산에 포함될 경우 = MST에 포함된다는 의미</span>\n\n<span class=\"token comment\"># 모든 간선에 대한 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> cost <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 cost으로 설정</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 cost순으로 정렬</span>\nedges<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 하나씩 확인해가며</span>\n<span class=\"token keyword\">for</span> edge <span class=\"token keyword\">in</span> edges<span class=\"token punctuation\">:</span>\n    cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> edge\n    <span class=\"token comment\"># 사이클이 발생하지 않는 경우에만 집합에 포함</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">+=</span> cost\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Kruskal 알고리즘의 성능 분석\n<ul>\n<li>시간 복잡도: O(ElogE) (Edge 개수 = E일 때)</li>\n<li>가장 많은 시간 요구하는 곳: edge 정렬 부분\n<ul>\n<li>표준 라이브러리(<code class=\"language-text\">sort()</code>)를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도: O(ElogE)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-topological-sort-위상-정렬\" style=\"position:relative;\"><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\" aria-label=\"3 topological sort 위상 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Topological Sort (위상 정렬)</h2>\n<ul>\n<li>**Cycle이 없는 Directed Graph(DAG, Directed Acyclic Graph)**의 모든 노드를 <strong>방향성에 거스르지 않도록 순서대로 나열</strong>\n<blockquote>\n<p>💡 DAG 여야하는 이유?\n: Cycle이 존재할 경우 Cycle이 존재하는 모든 노드의 Indegree가 1 이상이 되므로 다음 알고리즘을 사용할 경우, Cycle이 존재하는 모든 노드가 영원히 Queue에 들어갈 수 없음(=Sorting 수행할 수 없음)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>cf. Indegree와 Outdegree</p>\n<ul>\n<li>Indegree: 특정한 노드로 들어오는 edge의 개수</li>\n<li>Outdegree: 특정한 노드에서 나가는 edge의 개수</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Queue</strong>를 이용하는 Topological Sort 알고리즘 동작 과정\\</p>\n<ul>\n<li>각 노드가 Queue에 들어온 순서 = Topological Sort 수행 결과</li>\n</ul>\n<blockquote>\n<ol>\n<li>Indegree가 0인 모든 노드를 Queue에 넣음</li>\n<li>Queue가 빌 때까지 다음의 과정 반복</li>\n<li>Queue에서 원소를 꺼내 해당 노드에서 Outdegree를 그래프에서 제거함</li>\n<li>새롭게 Indegree가 0이 된 노드를 Queue에 넣음</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>Topological Sort 특징</p>\n<ul>\n<li>DAG (Direct Acyclic Graph), 순환하지 않는 방향 그래프에서만 수행 가능</li>\n<li><strong>여러 가지 답이 존재</strong>할 수 있음\n<ul>\n<li>한 단계에서 Queue에 새롭게 드어가는 원소가 2개 이상 있다면, 여러 가지 답이 존재</li>\n</ul>\n</li>\n<li><strong>모든 원소를 방문하기 전에 큐가 빈다면 Cycle이 존재</strong>한다고 판단\n<ul>\n<li>Cycle에 포함된 원소 중에서 어떠한 원소도 Queue에 들어가지 못함</li>\n</ul>\n</li>\n<li>Stack을 활용한 DFS를 이용해서도 Topological Sort 수행 가능</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\n<span class=\"token comment\"># 노드의 개수와 Edge의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 노드에 대한 indegree를 0으로 초기화</span>\nindegree <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결된 edge 정보를 담기 위한 연결 리스트 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> ragne<span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 방향 그래프의 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># A에서 B로 이동 가능</span>\n    <span class=\"token comment\"># indegree를 1 증가</span>\n    indegree<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># Topological Sort</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">topology_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># 알고리즘 수행 결과를 담을 리스트</span>\n    q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># queue</span>\n    <span class=\"token comment\"># 처음 시작할 때는 진입 차수가 0인ㅇ 노드를 queue에 삽입</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 큐가 빌 때까지 반복</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 큐에서 원소 꺼내기</span>\n        now <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 해당 원소와 연결된 노드들의 indegree에서 1 빼기</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token comment\"># 새롭게 indegree가 0이 되는 노드를 queue에 삽입</span>\n            <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Topological Sort 수행 결과 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> result<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\ntopology_sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Topology Sort의 성능 분석\n<ul>\n<li>시간 복잡도: O(V+E)</li>\n<li>차례대로 모든 Vertex를 확인해가며 각 Vertex에서 나가는 Edge를 차례대로 제거해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">1. Disjoint Sets (서로소 집합) 자료구조</a></p>\n<ul>\n<li><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\">Disjoint Set을 활용한 Cycle 판별</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\">2. Minimum Spanning Tree (최소 신장 트리)</a></p>\n</li>\n<li>\n<p><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\">3. Topological Sort (위상 정렬)</a></p>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 07, 2022","title":"Graph 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Graph/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/Shortest_Path/","nextSlug":"/Graph/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}