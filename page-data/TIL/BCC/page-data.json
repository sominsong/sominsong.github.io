{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/TIL/BCC/",
    "result": {"data":{"cur":{"id":"253a49d1-f542-5c84-ac3c-9a457447a3f5","html":"<p><a href=\"https://github.com/iovisor/bcc\">BCC</a>는 커널 tracing이나 manipulation 프로그램을 만들기 위한 유용한 toolkit을 제공하는 오픈 소스이다.</p>\n<p>맨처음 eBPF 프로그램을 작성하기 시작한다면, 어려워하는 부분이 바로 eBPF 프로그램을 컴파일하고 커널 소스코드에서 eBPF 라이브러리를 연결하는 부분일 것이다.\n이러한 부분을 해결해주기 위해 등장한 Toolkit이 BCC라고 보면 된다.</p>\n<p>즉, BCC는 eBPF 프로그램 작성, 컴파일 및 로드를 위한 Toolchain을 제공하고, 뿐만 아니라 performance issue 디버깅 및 진단을 위한 여러 가지 예제 프로그램과 도구도 제공한다.</p>\n<p>2015년 4월 출시 이후 많은 개발자에 의해 BCC가 발전했으며, 수많은 <a href=\"https://github.com/iovisor/bcc/tree/master/examples\">예제 코드</a>와 함께 즉시 사용 가능한 <a href=\"https://github.com/iovisor/bcc/tree/master/tools\">tracing tool</a>이 제작되었다.</p>\n<p>예를 들어, <a href=\"https://github.com/iovisor/bcc/blob/master/tools/lib/ugc.py\">garbage collection 이벤트 추적</a>, <a href=\"https://github.com/iovisor/bcc/blob/master/tools/lib/ucalls.py\">method call과 system call 추적</a>, <a href=\"https://github.com/iovisor/bcc/blob/master/tools/lib/uthreads.py\">스레드 생성 및 소멸 추적</a>을 위해 작성된 USDT(User Statically-Defined Tracing) probes를 사용하는 스크립트 등이 있다.\n이러한 probe는 이름에서도 알 수 있듯이, 컴파일 타임에 정적으로 사용자의 application에 삽입된다.</p>\n<p>BCC는  eBPF 프로그램 작성을 위해 기존에 LLVM/Clang 컴파일러에서 제공하는 C언어뿐만 아니라 파이썬, Go, Lua 언어를 위한 front-end를 지원한다.</p>\n<p>예를 들어, 다음 코드는 파이썬으로 작성되었으며, <code class=\"language-text\">clone()</code> 시스템콜 이벤트가 발생한 경우 <code class=\"language-text\">kprobe__sys_clone()</code> 함수를 수행하고 <code class=\"language-text\">Hello World</code>를 화면에 출력하는 예시이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> bcc <span class=\"token keyword\">import</span> BPF\nprogram <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">\"\"\"\n        int kprobe__sys_clone(void *ctx){\n            bpf_trace_printk(\"Hello World\");\n            return 0;\n        }\n\"\"\"</span>\nb <span class=\"token operator\">=</span> BPF<span class=\"token punctuation\">(</span>text<span class=\"token operator\">=</span>program<span class=\"token punctuation\">)</span>\nb<span class=\"token punctuation\">.</span>attach_kprobe<span class=\"token punctuation\">(</span>event<span class=\"token operator\">=</span><span class=\"token string\">\"sys_clone\"</span><span class=\"token punctuation\">,</span> fn_name<span class=\"token operator\">=</span><span class=\"token string\">\"kprobe__sys_clone\"</span><span class=\"token punctuation\">)</span>\nb<span class=\"token punctuation\">.</span>trace_print<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>전체 eBPF 프로그램이 <code class=\"language-text\">program</code> 변수에 포함되며, 이 변수는 커널 내부의 eBPF VM애서 실행되는 코드이다.</p>\n<p>함수 이름인 <code class=\"language-text\">kprobe__sys_clone()</code>의 형식은 중요하다.\n<code class=\"language-text\">kprobe__</code> 접두사는 BCC toolchain에 kprobe에 뒤따르는 커널 심볼들을 attach하도록 지시하기 때문이다.\n이 경우, 뒤따르는 커널 심볼은 <code class=\"language-text\">sys_clone()</code>이다.</p>\n<p><code class=\"language-text\">sys_clone()</code>이 호출되고 <code class=\"language-text\">kprobe</code>가 실행되면, eBPF 프로그램이 동작하고 <code class=\"language-text\">bpf_trace_printk()</code> 함수가 <code class=\"language-text\">Hello, World!</code>를 커널의 trace buffer로 출력한다.</p>\n<p>BCC는 front-end를 통해 파이썬을 바인딩하고, BPF back-end가 있는 LLVM/Clang 컴파일러를 호출하여 C를 eBPF 바이트코드로 변환한다.\n그런 다음, BCC는 <code class=\"language-text\">bpf()</code> 시스템콜을 사용하여 eBPF 바이트 코드를 커널에 로드하는 작업을 처리한다.</p>\n<p>예를 들어, in-kernel verifier의 검사가 실패한 경우와 같이 로드가 실패하면 BCC는 로드가 실패한 이유에 대한 힌트를 다음과 같이 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HINT: The `map_value_or_null` error can happen if you dereference a pointer value from a map loopup without first checking if that pointer is NULL</code></pre></div>\n<p>이러한 에러 로그도 BCC를 구성하는 또 다른 주요한 기능히다.\n올바른 eBPF 프로그램을 작성하는 것은 매우 까다로운 작업이기 때문에, BCC가 이를 도울 수 있다.</p>\n<p><code class=\"language-text\">BPF.trace_print()</code>는 커널의 trace 버퍼 파일(<code class=\"language-text\">/sys/kernel/debug/tracing/trace_pipe</code>)에 blocking read를 수행하여 버퍼 파일의 내용을 standard output으로 프린트한다.\n출력은 다음과 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    gnome-terminal--3210  [003] d..2 19252.369014: 0x00000001: Hello, World!\n    gnome-terminal--3210  [003] d..2 19252.369080: 0x00000001: Hello, World!\n    pool-21543 [001] d..2 19252.382317: 0x00000001: Hello, World!\n    bash-21545 [002] d..2 19252.385535: 0x00000001: Hello, World!\n    bash-21546 [003] d..2 19252.385752: 0x00000001: Hello, World!\n    bash-21545 [002] d..2 19252.386883: 0x00000001: Hello, World!</code></pre></div>\n<p>출력은 다음을 포함한다:</p>\n<ul>\n<li>kprobe를 트리거한 application 이름</li>\n<li>application의 PID</li>\n<li>실행 중인 CPU ([괄호] 안)</li>\n<li>다양한 프로세스의 context</li>\n<li>타임스탬프</li>\n<li>주소 0x00000001: 일반적으로 커널 코드가 trace 버퍼에 기록할 때 <code class=\"language-text\">trace_printk()</code> 호출 뒤에 instruction pointer address가 해당 필드에 프린트된다. 그러나 이 함수는 <code class=\"language-text\">bpf_trace_prink()</code>에 대해 구현되어 있지 않으므로 하드 코딩된 주소값인 <code class=\"language-text\">0x00000001</code>이 항상 사용된다.</li>\n<li><code class=\"language-text\">bpf_trace_printk()</code>에 전달한 “Hello, World” 문자열</li>\n</ul>\n<p>이렇게 <code class=\"language-text\">bpr_trace_prink()</code>를 이용하여 런타임 디버깅을 할 수 있지만, <code class=\"language-text\">trace_pipe</code> 파일이 전역 리소스이기 때문에 concurrent writer가 작성한 모든 메세지를 포함하므로, 단일 BPF 프로그램의 메세지를 필터링하기 어렵다는 단점이 존재한다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://lwn.net/Articles/742082/\">https://lwn.net/Articles/742082/</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","excerpt":"BCC는 커널 tracing이나 manipulation 프로그램을 만들기 위한 유용한 toolkit을 제공하는 오픈 소스이다. 맨처음 eBPF 프로그램을 작성하기 시작한다면, 어려워하는 부분이 바로 eBPF 프로그램을 컴파일하고 커널 소스코드에서 eBPF 라이브러리를 연결하는 부분일 것이다.\n이러한 부분을 해결해주기 위해 등장한 Toolkit이 BCC라고 보면 된다. 즉, BCC는 eBPF 프로그램 작성, 컴파일 및 로드를 위한 Toolchain을 제공하고, 뿐만 아니라 performance issue 디버깅 및 진단을 위한 여러 가지 예제 프로그램과 도구도 제공한다. 2015년 4월 출시 이후 많은 개발자에 의해 BCC가 발전했으며, 수많은 예제 코드와 함께 즉시 사용 가능한 tracing tool이 제작되었다. 예를 들어, garbage collection 이벤트 추적, method call과 system call 추적, 스레드 생성 및 소멸 추적을 위해 작성된 USDT(Use…","frontmatter":{"date":"October 27, 2022","title":"TIL - BCC (eBPF Compiler Collection)","categories":"TIL Linux","author":"Mini","emoji":"📖"},"fields":{"slug":"/TIL/BCC/"}},"next":{"id":"11af0ade-450d-5233-9d26-6d8f04f5e213","html":"<h2 id=\"정보-보안의-3요소\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%B3%B4-%EB%B3%B4%EC%95%88%EC%9D%98-3%EC%9A%94%EC%86%8C\" aria-label=\"정보 보안의 3요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정보 보안의 3요소</h2>\n<ul>\n<li>\n<p>Confidentiality(기밀성): asset이 authorization(인가)된 user에 의해서만 접근하는 것을 보장하는 것 (e.g., 비밀 일기)</p>\n<ul>\n<li>일기장을 남이 훔쳐보기 못하도록 지키는 것 = 기밀성을 지키는 것. 남이 훔쳐보더라도 무슨 말인지 못알아보게 적는 것 = 기밀성을 지키기 위해 암호화하는 것.</li>\n<li>Threat list: 도청, 도난, 사회공학 (shouler surfing) 등</li>\n</ul>\n</li>\n<li>\n<p>Integrity(무결성): asset이 authorization된 user에 의해서, authorization된 방법으로만 변경 가능한 것</p>\n<ul>\n<li>일기가 다른 사람에 의해 일부 수정된다 = 무결성이 꺠진 것. 무결성 검증을 위해서는 Hash 값을 비교함.</li>\n<li>Threat list: 트로이 목마, 바이러스</li>\n</ul>\n</li>\n<li>\n<p>Availability(가용성): asset이 적절한 시간에 authorization된 user가 접근할 수 있는 것</p>\n<ul>\n<li>DB를 Active/Standby로 구성하는 것</li>\n<li>Threat list: Dos/DDoS 공격</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"October 26, 2022","title":"TIL - 정보 보안의 3요소","categories":"TIL Security","author":"Mini","emoji":"📖"},"fields":{"slug":"/TIL/Security_3/"}},"prev":{"id":"e1001a6b-923f-5548-9647-b2fc6f9d5a2a","html":"<p>석사 과정동안 진행했던 과제에서 BPF-LSM 기술을 사용하여 컨테이너 환경을 위한 보안 모듈을 개발한 적이 있다.\n이번 기회에 관련된 내용들을 복습하고, 또 정리해두면 좋을 것 같았다.</p>\n<h2 id=\"0-bpf-lsm-기술이란\" style=\"position:relative;\"><a href=\"#0-bpf-lsm-%EA%B8%B0%EC%88%A0%EC%9D%B4%EB%9E%80\" aria-label=\"0 bpf lsm 기술이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. BPF-LSM 기술이란</h2>\n<p>BPF-LSM 기술을 한 마디로 정리하자면 다음과 같다.</p>\n<blockquote>\n<p>Privileged User가 MAC(Mandatory Access Control) 및 Audit 정책을 구현하기 위해 BPF 프로그램을 LSM Hook에 연결하여 시스템을 런타임 계측(Runtime Instrumentation)하는 보안 모듈</p>\n</blockquote>\n<p>즉, BPF-LSM이란 기술을 이해하기 위해선 MAC, BPF, LSM에 대한 개념이 선행되어야 한다.\n따라서 BPF-LSM을 본격적으로 정리하기에 앞서, 관련 기술들을 먼저 하나씩 정리해보았다.</p>\n<p>정리된 글들은 다음에서 확인할 수 있다.</p>\n<ul>\n<li><a href=\"https://sominsong.github.io/eBPF/\"><strong>eBPF</strong></a></li>\n<li><a href=\"https://sominsong.github.io/BCC/\"><strong>BCC</strong></a></li>\n<li><a href=\"https://sominsong.github.io/LSM/\"><strong>LSM</strong></a></li>\n</ul>\n<p>BPF-LSM 기술을 알기 위해서는 KSRI 기술을 먼저 이해해야 한다.\nKRSI는 BPF-LSM이 커널 메인스트림에 병합되기 전 진행되었던 프로젝트의 이름으로 BPF-LSM의 전신이라고 할 수 있다.</p>\n<h2 id=\"1-krsi---kernel-runtime-security-instrumentation\" style=\"position:relative;\"><a href=\"#1-krsi---kernel-runtime-security-instrumentation\" aria-label=\"1 krsi   kernel runtime security instrumentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. KRSI - Kernel Runtime Security Instrumentation</h2>\n<p>기존에 리눅스 환경에서 보안을 강화하는 방법에는 크게 두 가지가 존재했다.\n하나는 악의적인 움직임을 감지하고 이에 대한 정보를 제공하는 것과 다른 하나는 특정 rule에 해당하는 악의적인 움직임을 차단하는 것이다.</p>\n<p>전자에 해당하는 보안 모듈의 경우, 사전에 정의된 규칙에 따라 시스템에서 발생하는 보안 관련 이벤트를 로그로 기록하는 Audit과 Kernel Tracing Point를 이용하여 시스템의 명령이나 어플리케이션의 영향을 추적하는 Perf 등이 있다.</p>\n<p>후자에 해당하는 보안 모듈의 경우, 정해진 Profile에 따라 액세스를 제어하는 SELinux, AppArmor, 프로세스가 사용할 수 있는 시스템콜을 제한하는 Seccomp 등이 있다.</p>\n<p>이 두 가지는 이전까지 ‘동전의 양면’ 관계로 존재했으며, 두 가지 측면에 대하여 서로 다른 모듈로써 존재하기 때문에 동시에 관리하기가 어려웠다.</p>\n<p>이에 KRSI는 이 두 가지를 하나의 API로 제공하여 전반적인 시스템 동작을 제어 및 감시할 수 있도록 만드는 프로젝트이다.</p>\n<p>KRSI의 특징은 다음과 같다:</p>\n<ul>\n<li>악의적인 행동을 기록하는 것 &#x26; 차단하는 것, 두 가지에 대한 Rule을 작성할 수 있는 통합적인 API를 제공</li>\n<li>LSM(Linux Security Module) 이벤트를 이용하여 세세한 MAC 규칙을 시스템에 적용</li>\n<li>eBPF 기반 기술이기 때문에 Rule Update 시 커널의 재 컴파일이 불필요</li>\n</ul>\n<h2 id=\"2-krsi-구현\" style=\"position:relative;\"><a href=\"#2-krsi-%EA%B5%AC%ED%98%84\" aria-label=\"2 krsi 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. KRSI 구현</h2>\n<p>앞서 간략히 설명했듯이, KRSI는 eBPF와 LSM(Linux Security Module)을 이용해서 구현된다.\nLSM은</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://lwn.net/Articles/808048/\">https://lwn.net/Articles/808048/</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#0-bpf-lsm-%EA%B8%B0%EC%88%A0%EC%9D%B4%EB%9E%80\">0. BPF-LSM 기술이란</a></li>\n<li><a href=\"#1-krsi---kernel-runtime-security-instrumentation\">1. KRSI - Kernel Runtime Security Instrumentation</a></li>\n<li><a href=\"#2-krsi-%EA%B5%AC%ED%98%84\">2. KRSI 구현</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 31, 2022","title":"TIL - BPF-LSM","categories":"TIL Linux","author":"Mini","emoji":"📖"},"fields":{"slug":"/TIL/BPF-LSM/"}},"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/TIL/BCC/","nextSlug":"/TIL/Security_3/","prevSlug":"/TIL/BPF-LSM/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}