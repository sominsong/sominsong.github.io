{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/TIL/eBPF/",
    "result": {"data":{"cur":{"id":"693ff1c3-0f14-5fd7-8852-fb00a39ed129","html":"<p>리눅스 커널에 대해 공부한다면, eBPF에 대해 한 번쯤은 들어봤을 것이다.\n필자가 주로 연구했던 분야인 Seccomp도 BPF 기술을 이용하는 리눅스 커널의 보안 모듈이다.\n따라서 석사 과정동안 공부했던 내용들을 기록하기 위해서는 가장 먼저 BPF에 대한 정리가 필요할 것 같아, 이렇게 기록하고자 한다.</p>\n<h2 id=\"0-bpf\" style=\"position:relative;\"><a href=\"#0-bpf\" aria-label=\"0 bpf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. BPF</h2>\n<p>BPF란 Berkeley Packet Filter의 약자이다(였다).\n이 개념은 1992년 Steve McCane과 Van Jacobson의 Usenix Conference Winter ‘93 논문 <a href=\"https://www.tcpdump.org/papers/bpf-usenix93.pdf\">“The BSD Packet Filter: A New Architecture for User-level Packet Capture”</a>에서 처음으로 소개되었다.\n커널과 같은 Privileged context에서 sandboxed program을 실행할 수 있는 기술이다.\n즉, 커널 내부에 사용자가 작성한 코드를 삽입하여 안전하게 실행시킬 수 있는 도구이며, 커널 모듈이 아닌 코드를 실행하기 위한 mini-VM이라고 할 수 있다.\n커널 소스 코드를 변경하거나 커널 모듈을 로드할 필요 없이 커널의 기능을 안전하고 효율적으로 확장하는 데 사용된다.</p>\n<p>운영 체제는 커널의 Privileged 능력으로 인해 Observability, security, networking functionality를 구현하는데 최적인 장소임과 동시에, 안정성 및 보안에 대한 높은 요구 사항으로 그 바전 속도가 외부에 비해 현저히 더뎠다.\nBPF는 이러한 기존의 공식을 근본적으로 바꿨다.\n운영 체제 내에서 샌드박스 프로그램을 실행할 수 있도록 함으로써 애플리케이션 개발자는 BPF 프로그램을 실행하여 런타임에 운영 체제에 추가 기능을 구현할 수 있다.</p>\n<h2 id=\"1-cbpf-vs-ebpf\" style=\"position:relative;\"><a href=\"#1-cbpf-vs-ebpf\" aria-label=\"1 cbpf vs ebpf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. cBPF vs. eBPF</h2>\n<p>BPF는 cBPF와 eBPF로 나누어 명칭된다.\ncBPF는 classic BPF의 약자로 eBPF(extended BPF)가 나오지 전, 패킷 필터의 목적으로만 디자인된 초기 BPF를 의미한다.\n즉, 소켓 필터링을 위해 소켓에만 BPF 프로그램을 연결할 수 있었다.</p>\n<p>이는 BPF의 첫 번째 사용 사례인 <code class=\"language-text\">tcpdump</code>를 살펴보면 알 수 있다.\n<code class=\"language-text\">tcpdump</code>는 유닉스 계열에서 네트워크 상의 패킷을 캡처하여 표시해주는 도구이며, 윈도우 계열에서는 <code class=\"language-text\">Windump</code> 또는 <code class=\"language-text\">WireShark</code>가 있다.\n<code class=\"language-text\">tcpdump</code>를 실행하면 사용자가 정의한 필터가 BPF 프로그램으로 컴파일되고 이 BPF 프로그램은 raw <code class=\"language-text\">AF_PACKET</code> 소켓에 연결(attach)되어 필터에 의해 캡처된 패킷을 프린트한다.</p>\n<p>이후, 2013년 Alexei Starovoitov를 필두로 수년에 걸처 cBPF에 다양한 기능이 추가되었고, 기존의 소켓 필터링 이외에도 다양한 attach point들이 지원되는 현재의 eBPF가 탄생했다.\neBPF는 다음과 같은 여러 가지 방법을 통해 cBPF를 확장한다:</p>\n<ul>\n<li><strong>x86-64와 비슷한 아키텍처</strong>: eBPF는 64비트 레지스터를 사용하며 사용 가능한 레지스터 수(2에서 10으로), opcode 수를 늘렸다. 이를 통해 eBPF를 native instruction에 쉽게 매핑할 수 있으므로 Just-in-Time 컴파일이 가능하여 성능이 크게 향상되었다.</li>\n<li><strong>네트워킹 subsystem에서의 분리</strong>: cBPF는 패킷 기반 데이터 모델로 제한되었으며, 패킷 필터링에 사용되었기 때문에 해당 코드는 네트워킹 하위 시스템 내(<code class=\"language-text\">net/core/filter.c</code>)에 있었다. 이와 달리, <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=daedfb22451dd02b35c0549566cbb7cc06bdd53b\">eBPF는 더이상 데이터 모델에 구속되지 않으며 모든 용도로 사용할 수 있다.</a> 그 결과, tracepoints 또는 kprobes(및 user-space의 uprobes)에 연결 가능해졌다. 이는 eBPF가 instrumentation, performance analysis 및 기타 커널 하위 시스템 내에서 더 많은 용도로 사용될 수 있는 가능성을 열어주었다. 현재 eBPF 코드는 자체 경로인 <code class=\"language-text\">kernel/bpf</code>에 위치한다.</li>\n<li><strong>Maps</strong>: Map은 key-value 형태로 다양한 유형의 데이터를 저장하는 일반적인 데이터 구조이며, 전역 데이터 저장소(glocal data store)이다. eBPF 커널 프로그램 간의 데이터 공유 또는 커널과 user-space 어플리케이션 간의 데이터 공유에 사용된다. Map 덕분에 eBPF로 작성된 프로그램은 state를 유지할 수 있으므로 이벤트 전반에 걸쳐 정보를 집계하고 동적 동작을 수행할 수 있다.</li>\n<li><strong>Helper 함수</strong>: 커널 내부에서 실행되는 함수이며, eBPF 프로그램에서 시스템콜을 호출할 실행할 수 있도록 해준다.</li>\n<li><strong>Tail-calls</strong>: eBPF는 4096 bytes로 크기가 제한된다. 이러한 제한은 tail-call 기능으로 eBPF 프로그램이 새로운 eBPF 프로그램을 호출함으로써 극복할 수 있다.</li>\n</ul>\n<p>이외, 기존 네트워크 프로그래밍과 관련된 기능에서의 확장도 있었다:</p>\n<ul>\n<li>TC(Traffic Control)을 위한 네트워크 스케줄러와 qdiscs</li>\n<li>XDP(eXpress Data Path)</li>\n</ul>\n<p><code class=\"language-text\">bpf()</code> 시스템콜이 추가된 v3.18 이후로는 일부에서만 cBPF가 이용되고 있으며, 이 글을 작성하는 시점인 현재는 eBPF가 cBPF를 완전히 대체하기 때문에 eBPF는 BPF로 언급되기도 한다.</p>\n<p>Packet Filter라는 이름처럼 처음 해당 기술이 만들어진 목적은 커널 내부에서 자체 코드를 실행하여 패킷을 필터링하기 위함이었지만, **정의에 의한 이벤트 구동(event-driven by definition)**이라는 강력한 기능으로 인해 현재는 기존의 네트워크 영역뿐만 아니라 커널 tracing 및 event monitoring 영역에서도 유용하게 사용되고 있다.</p>\n<p>그 뿌리는 packet filter였지만 확장성으로 인해 많은 영역에서 다양한 기능으로 사용되고 있는 현재, <strong><em>eBPF는 더 이상 어떤 것의 약어로써 설명되지 않는다.</em></strong></p>\n<h3 id=\"bpf의-역사\" style=\"position:relative;\"><a href=\"#bpf%EC%9D%98-%EC%97%AD%EC%82%AC\" aria-label=\"bpf의 역사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BPF의 역사</h3>\n<p>앞서 간략하게 언급했듯이, BPF는 1992년 Steve McCane과 Van Jacobson의 Usenix Conference Winter ‘93 논문 <a href=\"https://www.tcpdump.org/papers/bpf-usenix93.pdf\">“The BSD Packet Filter: A New Architecture for User-level Packet Capture”</a>에서 처음으로 소개된 이후로도 다양한 사람들에 의한 발전을 통해 현재의 eBPF가 되었다.</p>\n<p>BPF가 CMU/CSPF(Standford Packet Filter)와 같은 이전 모델과 크게 다른 점은 well throught out memory model을 사용하며, 그것을 커널 내부의 VM을 통하여 노출한다는 것이다.\n이를 통해 BPF 필터는 필터 코드와 커널 사이의 경계를 유지하면서도 효율적인 방식으로 트래픽 필터링을 수행할 수 있었다.\n즉, McCanne과 Jacobson이 제시하는 다음 다이어그램에서처럼 BPF는 필터와 일치하는 모든 패킷에 대해 User-space와 Kernel-space 간의 값비싼 context switch를 만들지 않도록 필터와 User-space 사이에 버퍼를 사용한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.88888888888887%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAACh0lEQVQ4y6VUXU/iUBDt//8Zvpqw+GKigELBAgEXH2hRqyxtkfLZ8lU+1WPO6G2Kkt2HnWTSTm/vmTMz517t7e0NqyjCarXCbrdDGIYIgkDixWIh75vNBrT39/ejnlzTdtstquUybuu/sVwuUTYMGEYZvu9jPB7D87qYz2bxxn+Zxh+n06kwo/V9H71eD2ROhi8vL3h9fY2d/3ONTmN1nuvJGr9pZNXpdMQHgwGen5/Rbrfl3fM8tFqtuGy2gawZK59MJjCbJoIw/AQMJhM0Gg00m00UCgVUKhXcNe5wdXWFarWKSrmMx8dHYbPf76UtiuF6vRZP9lJjlny+AF3XUSwWcXFxgWwmi3w+j+vra6TTadzf38vPHBpZWqYJ07Sw2WwF8GAopExWZElAOmMClkolYf3w8CCbtttPALKkM0ESMGZYq9XECaYXdNyUboRxNpsRQNu245Jnsxnm87kMkk8mOQAcjUb4lUrh5OQEuVwOl5eX8qSzj4wtyzrYxAGRobKkpLThcIhUKoXT01NkMhnp29nZmfSOoOfn5zBN86BPVAGnnQSLGZIy6VNz1CJ76rquCJvJ6CyTOiMz9oylsn9HAf+meiVWJRHGSft+7OKTotQvyl+t4Ps9YRZFEbrdLlzXQxgEGI3Gwr7f78uAFBj3/mCoPrBswzAEhG24rddRrVS/TlEbRV2HbT/FcvnOWFMl0VVJ3EwwGqdJtnKW93thqMonwGa9huO4cQJNNVo5h6S0ptair+uNMStgzO+MmbjzpyNTZxIN/2nsJS8RHpCDoSQnJcPwugiDEPP5DJbVktuId6MakhrKjx4ekwHLebJtDAZDKZ0APFGO48DpOCLs3e74lD8AIDKd/49uiiwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eBPF-1.png\"\n        title=\"eBPF-1.png\"\n        src=\"/static/62cb19611661e69e96e57edc37da7f35/37523/eBPF-1.png\"\n        srcset=\"/static/62cb19611661e69e96e57edc37da7f35/e9ff0/eBPF-1.png 180w,\n/static/62cb19611661e69e96e57edc37da7f35/f21e7/eBPF-1.png 360w,\n/static/62cb19611661e69e96e57edc37da7f35/37523/eBPF-1.png 720w,\n/static/62cb19611661e69e96e57edc37da7f35/27b8e/eBPF-1.png 836w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>McCanne과 Jacobson이 구현한 BPF VM은 accumulator, index register, scratch memory store, implicit program counter로 구성되었으며, 매우 간결하고 단순했다.\n이는 논문에서 저자가 소개한 다음 예제 프로그램에서 살펴볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    ldh [12]                    // ethertype field info를 레지스터에 로드\n    jeq #ETHERTYPE_IP, L1, L2   // IP의 ethertype과 레지스터 비교\nL1: ret #TRUE                   // 비교가 참일 경우, true 반환\nL2: ret #0                      // 비교가 거짓일 경우, 0 반환</code></pre></div>\n<p>이처럼 4개의 VM instruction만을 사용하여 BPF는 IP 패킷 필터를 제공할 수 있었으며, 이는 동일한 기능을 제공하기 위해 184개의 CPU 인스트럭션이 필요한 것과 대조된다.</p>\n<p>이후, 리눅스 커널은 v2.5 이후로 Jay Schullist가 주도하여 BPF 기능을 추가함으로써 이를 지원하기 시작했으며, <code class=\"language-text\">net/core/filter.c</code>에서 리눅스 BPF의 구현을 찾을 수 있다.</p>\n<p>2011년, 커널 v3.15에서 Eric Dumazet이 BPF 인터프리터를 JIT(Just-In-Time) 컴파일러로 전환하였다. 이를 통해 커널은 BPF 바이트코드를 해석할 필요 없이, 대상 아키텍처(x86, ARM, MIPS 등)로 직접 변환할 수 있었다.</p>\n<p>2014년 12월, 커널 v3.18에 <code class=\"language-text\">bpf()</code> 시스템콜이 추가되고 Alexei Starovoitov가 새로운 BPF JIT을 도입하면서부터 eBPF로 알려진 BPF 기반의 새로운 아키텍처가 사용되었다.</p>\n<p>이후 커널 개발자들에 의해 eBPF는 다양한 커널 시스템에서 빠르게 활용되었고, 사양한 use case를 다루는 eBPF 기반 프로젝트들이 탄생했다.\n아래는 리눅스에서 eBPF를 사용한 다양한 커널 tracing tool들을 보여준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACPUlEQVQozyWSW3eqMBSE+f9/yHMeWls9LYoFinKNEHJBESKSEIjgpZxlnef51prZe7RxHO/3++12G8fxdrvd7/efn5+6rvM8J4RkWYYxLoriMgyXXz0NT2lPJs9zjHGe57LrQgC8IMjLMi8KuttBhLrz2QsCY7UKgrBtWwhhmqZ932td1zVNQyndAlAyVhNS+C51nCZNOUxqmDAQ3cviGEVilw2Xi1KKYEwJHcfxAcdx7Ps+hBARctpsruv14Lq3IOCGcVou+MrYz2flfC4CvxZi6AfGmGmaVXXSmqZBKH3Wk23HI1d8L1XwLV1TbKxMn6f/pvH8tfjSif3FRXNkDKXpQl8QQjQIoW3bfd+P46iUgihIoINpBGJ7G88jMENIPwu/524c6lw0TSMAAIZhUEo1jJGu64SQ38tdrYhNPtOpddD93b/vv6+riZfoNTWK5B0Gn/mhTJIYIbRcLh8wY8cwDKuq6jolG/FhwT8fyWQWvyw8nyys7YflTWuyYMl7lTlcNIdDnkDoOE5GqXY8Ht/e3kzTXG82h0M+s5LJIn0x91N7a0Sz2Xpqg0+WWWkwLTJ3uFw5r13X9Xxftq3GObdtG2NclmUrpY0Pxk6sdvwD5q9+8uIl8zhzyuZrX7tZ2St1vV4ppftd9nhV3/d1XUsphRAoTRFCGGPOOWMsjEL4SLiOIgAA6JQax7Ft1bGgNJpdL2eN1/V+v3+O9Lk+KWVZlkKI0+lUFAUAgDF2qiqlVNu2UsqM4gx5Q3/+DxubgC957NvyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eBPF-2.png\"\n        title=\"eBPF-2.png\"\n        src=\"/static/b6d70998647d2f3be603ad133e253ff0/37523/eBPF-2.png\"\n        srcset=\"/static/b6d70998647d2f3be603ad133e253ff0/e9ff0/eBPF-2.png 180w,\n/static/b6d70998647d2f3be603ad133e253ff0/f21e7/eBPF-2.png 360w,\n/static/b6d70998647d2f3be603ad133e253ff0/37523/eBPF-2.png 720w,\n/static/b6d70998647d2f3be603ad133e253ff0/302a4/eBPF-2.png 1080w,\n/static/b6d70998647d2f3be603ad133e253ff0/07a9c/eBPF-2.png 1440w,\n/static/b6d70998647d2f3be603ad133e253ff0/97a96/eBPF-2.png 2400w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>오늘날 eBPF는 다양한 영역에서 광범위하게 사용된다.\n최신 데이터 센터 및 클라우드 네이티브 환경에서 고성능 네트워킹 및 로드 밸런싱 제공하거나, 낮은 오버헤드로 세분화된 Security Observability 데이터 추출하거나, 애플리케이션 개발자가 애플리케이션을 tracing하는 것을 돕거나, Performance Troubleshooing 해결에 insight를 제공하거나, 컨테이너 런타임 보안을 강화하는 등의 Use Case에 사용되고 있다.</p>\n<h2 id=\"2-how-to-work\" style=\"position:relative;\"><a href=\"#2-how-to-work\" aria-label=\"2 how to work permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. How to work</h2>\n<p>BPF 프로그램은 event-driven으로 커널/애플리케이션이 특정 Hook point를 통과할 때 실행된다.\n미리 정의된 hook에는 시스템콜, 함수의 entry/exit, 커널 tracepoint, 네트워크 이벤트 등이 포함된다.</p>\n<p>사용자는 작성한 BPF 프로그램을 <a href=\"https://man7.org/linux/man-pages/man2/bpf.2.html\"><code class=\"language-text\">bpf()</code></a> 시스템콜을 통해 로드할 수 있으며, <code class=\"language-text\">bpf()</code> 시스템콜은 해당 코드의 안전성(루프, 코드 크기 등)을 검사하여 검증한다.\n검증이 완료된 BPF 프로그램만이 커널 개체에 연결되며, 이후 해당 개체에서 이벤트가 발생(e.g., 네트워크 인터페이스가 패킷을 내보낼 때)할 때마다 작성된 BPF 프로그램이 실행된다.</p>\n<p>BPF 프로그램은 크게 3가지의 프로세스를 거쳐 실행된다:</p>\n<ol>\n<li>\n<p>eBPF 프로그램을 바이트 코드로 생성한다: 현재 eBPF 프로그램을 만드는 표준 방법은 C 코드로 작성한 다음 LLVM이 ELF 파일에 있는 eBPF 바이트 코드로 컴파일하도록 하는 것이다.</p>\n</li>\n<li>\n<p>프로그램을 커널에 로드하고 필요한 eBPF Map을 생성한다: 이 과정은 리눅에서 <code class=\"language-text\">bpf()</code> 시스템콜을 통해 수행된다. <code class=\"language-text\">bpf()</code> 시스템콜은 eBPF 프로그램의 유형을 선언하고, 바이트 코드를 로드한 뒤, Map을 초기화한다.</p>\n</li>\n</ol>\n<ul>\n<li>BPF 프로그램 유형: socket filter, kprobe handler, traffic control scheduler, traffic control action, tracepoint handler, eXpress Data Path (XDP), performance monitor, cgroup restriction, light weight tunnel</li>\n</ul>\n<ol start=\"3\">\n<li>로드된 프로그램을 시스템에 연결한다: eBPF 프로그램의 유형에 따라 해당 시스템에 연결되는 방식이 다르다. 프로그램이 연결되면 프로그램이 활성화되면서 정의된 작업을 수행한다. 여기에서 User-space 프로그램은 eBPF Map에서 state를 읽을 수 있으며, eBPF 프로그램을 관리할 수 있다.</li>\n</ol>\n<h2 id=\"3-ebpf를-이루는-구성-요소들\" style=\"position:relative;\"><a href=\"#3-ebpf%EB%A5%BC-%EC%9D%B4%EB%A3%A8%EB%8A%94-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C%EB%93%A4\" aria-label=\"3 ebpf를 이루는 구성 요소들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. eBPF를 이루는 구성 요소들</h2>\n<p>eBPF가 사용되기 위해서는 앞서 기술한 것처럼 프로그램 작성 및 컴파일, 커널 로드 및 시스템 연결 등과 같이 여러 단계가 동반된다.\n사실 이러한 단계들은 모두 eBPF의 안정성에 기여한다.\n여러 단계에서 사용되는 다양한 기술들은 eBPF의 안전성을 여러 계층에서 보장한다.\n다음에서는 각각의 기술들에 대한 세부 사항을 정리한다.</p>\n<h3 id=\"31-ebpf-프로그램\" style=\"position:relative;\"><a href=\"#31-ebpf-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8\" aria-label=\"31 ebpf 프로그램 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. eBPF 프로그램</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhUlEQVQI132M3QqCQBgFff+Hie58gfAiwUoQRBNcKyFT3MBdb/SbYLHoBxo4zM1hPL4QmZ0vWrEK1uzzEJkFO1qsMQTpBj/0qbvT8he3J95nTJDFdhxJjwpVVvS9ZhgM8zTR6Tt5UXG7Nq/Q36Az0LUtZVGTxAXxLiPaJhyijLNqfv7vPAA7xeZ5QDBytgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eBPF-3.png\"\n        title=\"eBPF-3.png\"\n        src=\"/static/a7160cd231b062b321f2a479a4d0848f/37523/eBPF-3.png\"\n        srcset=\"/static/a7160cd231b062b321f2a479a4d0848f/e9ff0/eBPF-3.png 180w,\n/static/a7160cd231b062b321f2a479a4d0848f/f21e7/eBPF-3.png 360w,\n/static/a7160cd231b062b321f2a479a4d0848f/37523/eBPF-3.png 720w,\n/static/a7160cd231b062b321f2a479a4d0848f/302a4/eBPF-3.png 1080w,\n/static/a7160cd231b062b321f2a479a4d0848f/1d553/eBPF-3.png 1159w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>리눅스 커널은 eBPF 프로그램이 바이트코드 형태로 로드될 것으로 예상한다.\n따라서 LLVM/Clang같은 컴파일러를 이용하여 C로 작성한 eBPF 프로그램 소스 코드를 바이트 코드로 컴파일한다.\nLLVM은 컴파일을 통해 프로그램 코드, Map 정의, relocation 정보, BTF meta data와 같은 정보가 포함된 eBPF ELF 파일을 생성한다.</p>\n<p>LLVM은 C와 같은 구문으로 작성된 프로그램을 eBPF 인스트럭션으로 변환하는데 필요한 eBPF 백앤드를 지원하는 유일한 컴파일러였다.\n그러나 GCC 10부터는 GCC 컴파일러에서도 eBPF를 지원하고 있다. 다만, 현재는 일부 기능이 누락되어 있다.</p>\n<p>BPF 프로그램은 여러 가지 Type이 존재하는데,\nBPF 프로그램 Type에 따라, 프로그램이 attach될 수 있는 위치(Hook), verifier가 호출할 수 있는 커널 내의 helper 함수, 네트워크 패킷 데이터에 직접 액세스할 수 있는지 여부, BPF 프로그램으로 전달되는 첫 번째 인자의 object type과 같이 4가지 사항이 결정된다.</p>\n<p>아래는 커널에서 지원하는 eBPF 프로그램 Type이다:</p>\n<ul>\n<li><code class=\"language-text\">BPF_PROG_TYPE_SOCKET_FILTER</code>: 네트워크 packet 필터</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_KPROBE</code>: kprobe</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_SCHED_CLS</code>: 네트워크 트래픽 제어 분류기</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_SCHED_ACT</code>: 네트워크 트래픽 제어 작업</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_TRACEPOINT</code>: tracepoints</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_XDP</code>: device-driver 수신 경로에서 실행되는 네트워크 packet 필터</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_PERF_EVENT</code>: perf</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_CGROUP_SKB</code>: cgroup에 대한 네트워크 packet 필터</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_CGROUP_SOCK</code>: 소켓 옵션이 수정 가능한 cgroup에 대한 네트워크 packet 필터</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_LWT_*</code>: lightweight tunnels용 네트워크 packet 필터</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_SOCK_OPS</code>: 소켓의 인자를 설정하는 프로그램</li>\n<li><code class=\"language-text\">BPF_PROG_TYPE_SK_SKB</code>: 소켓 간에 packet을 전달하기 위한 네트워크 packet 필터</li>\n<li><code class=\"language-text\">BPF_PROG_CGROUP_DEVICE</code>: cgroup에 대한 device</li>\n</ul>\n<h3 id=\"32-loader--verification\" style=\"position:relative;\"><a href=\"#32-loader--verification\" aria-label=\"32 loader  verification permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. Loader &#x26; Verification</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACVElEQVQoz22SW2sTQRSA90f7HxS8IohULQULSn0oWNSiD9oaTN1cTTeb6zbZTZrNJrvZ+0xupp9kW+uLBz7OYRi+M5wzSs2s8lE9whwZRFGMP5tRNcp8Kn7AsntIuSROUtJUkGxJUlarFf+Lq6srlG6/R7FyjtkzGY8dQj/kwrIoVWvYoxEi8Uljjzia3WSP5XLJZrNhvV7f5q1sG8rQuqTTNKkU6xR/1igVNDrNAb4fMvOmDPRDhvU3SK/C8HyfYPiN1XqN7/sYXYOG3sAe2Ugpr4X1eh1d13EcJzuM44gkcomCKXHo4k0s7GEnyxPbIPAuWcxFNgLXdel2u3jev1crW8FfUiFJghFa7jHa6QMGlWcY6lNiY4+0v4cwXyN6r5hdqvTNS4YDC8cZY5pmRpqmKNcDl5ksjNKso/rjM21dxZ/2CD0zwx40if0BkdcnDFz8IKbRbJM/U2m1u0RRki1MWUQ9hFslciqsowYTS0Urf8GxSqyTDhthIGcaRu0I4daIpxqBXcYdqBRyB3z99JJJP8fvuIFMXJR4UkVX39DX3tMu7tLKP6F99hSv+ZK4/xaSCmJ0zPmXOzitdwgnx6h9RKuwy1h7gf79Pn5rh7h/gEwclHBczoTdX4c0fj5HO7lLJ/+I+sk9bG2XpZdHOKcE1jFycpoJ0/Ep4cU+XnOHRu4hYWeH1LoRyqBLOi3jjwosZlXmXhnplUmnJRZ+ld+xnnGVtm7rTdJgFZ5nrCPttpbJFGW7hCAIsrVvv42czzPm8wVSzhFC/JfsrpQIIW/rLX8A4zsjIsyA0J8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eBPF-4.png\"\n        title=\"eBPF-4.png\"\n        src=\"/static/1a1bb6f1e64b1ad5597f57dc17cf1350/37523/eBPF-4.png\"\n        srcset=\"/static/1a1bb6f1e64b1ad5597f57dc17cf1350/e9ff0/eBPF-4.png 180w,\n/static/1a1bb6f1e64b1ad5597f57dc17cf1350/f21e7/eBPF-4.png 360w,\n/static/1a1bb6f1e64b1ad5597f57dc17cf1350/37523/eBPF-4.png 720w,\n/static/1a1bb6f1e64b1ad5597f57dc17cf1350/302a4/eBPF-4.png 1080w,\n/static/1a1bb6f1e64b1ad5597f57dc17cf1350/32ac3/eBPF-4.png 1249w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>컴파일된 eBPF 프로그램은 User-space에서 <code class=\"language-text\">bpf()</code> 시스템콜을 통해 커널로 전달되고, eBPF 프로그램을 커널에 로드하기 위한 작업을 시작한다.\n이를 위해 먼저, eBPF 프로그램을 로드하는 프로세스가 필요한 capabilities(privileges)를 보유하고 있는지 확인한다. unprivileged eBPF를 따로 활성화시키지 않을 경우에는 권한 있는 프로세스(root이거나 <code class=\"language-text\">CAP_BPF</code> capability 필요)만이 eBPF 프로그램을 로드할 수 있다. 즉, 신뢰할 수 없는 프로그램은 eBPF 프로그램을 로드할 수 없다. 만약 unprivileged eBPF가 활성화된 경우에는, 커널에 대한 제한된 액세스와 제한된 기능을 가진 eBPF 프로그램을 로드할 수 있다.</p>\n<p>이후 커널에서는 두 단계를 거쳐 커널에 eBPF 프로그램을 로드하게 되는데, 첫 번쨰 단계로는 전달된 eBPF 프로그램이 안전한 프로그램인지 in-kernel Verifier가 해당 프로그램을 체크하고, 두 번째 단계에서는 JIT(Just-in-Time) 컴파일러를 통해 바이트코드를 kernel native 코드로 컴파일한다.</p>\n<h4 id=\"verification\" style=\"position:relative;\"><a href=\"#verification\" aria-label=\"verification permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Verification</h4>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/UlEQVQoz02O60/aYBjF+++7S5boptu+7MvMpsvijeiiizIuIi1eQJBC7QUsWEAo0HIR2ve3WGXZSU7Ok5yT8xxJCMETnvRSb3Gk3BK/MMmod8zmwT9vgcXt+z4Nu4FW1ajX6nQ6nciTngOCMAwwmy7xQoH1PztktAuCMIi8KCOeVYgwKnRdNyrSqlWqlQotx2E2e0Ra/A5DcO4darbJUTqJqpYJgpf1L/wf3Z6Lbpi02w/ouoVl1fC8ERKBR0QxpmmbnKaT5OQznGYNxAgxHyLmz5ngccDE7zIZdQlmHsbtDYcHmyRPdnEfGsAEKXSzBK7MsPGbrrHHXfEHPSOG6Bwz76YQwxwMcuCdM2mnmfXOCPoy01acQT1GVfmCo24ydY6Yd9NI2tUW1cstrOvvlFLLaMoqSuoVhfxr/PtfMC4gvCzBUGbaOSXsy4jhBQNzA09b4zq+hJ59R7+yim/HkIrZDdTznzC+gscirpMglvhGJrMerSkZO+wkPmPpuwQ9mbmbjQpdfYNmfpnCyRJq6g1OYQXf3kdytANqpT3M/FeKibcY8gpqahlLeY93t4dtHZNXtmmqMXwngehnEQMFr76NoXxAV9Ywch+x85+Ytg6RGJdhrOK3FVw7yaidYXifxnNOmfWvYFSGqRqp8Erg30QUfhkmFRgvqCL8G/4CItmOcN4rDV0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eBPF-5.png\"\n        title=\"eBPF-5.png\"\n        src=\"/static/7eec5ccd8f6fbaf055256da4910acd5a/37523/eBPF-5.png\"\n        srcset=\"/static/7eec5ccd8f6fbaf055256da4910acd5a/e9ff0/eBPF-5.png 180w,\n/static/7eec5ccd8f6fbaf055256da4910acd5a/f21e7/eBPF-5.png 360w,\n/static/7eec5ccd8f6fbaf055256da4910acd5a/37523/eBPF-5.png 720w,\n/static/7eec5ccd8f6fbaf055256da4910acd5a/302a4/eBPF-5.png 1080w,\n/static/7eec5ccd8f6fbaf055256da4910acd5a/dc61a/eBPF-5.png 1147w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Verification 단계에서는 eBPF 프로그램이 커널에서 실행되기에 충분히 안전한지를 확인한다.\n즉, 프로그램 자체의 안전성을 체크하는 과정이다.\n이를 위해 eBPF in-kernel verfier는 eBPF 프로그램이 다음과 같은 조건을 충족하는지 확인한다:</p>\n<ul>\n<li>프로그램이 충돌하거나 시스템에 손상을 주지 않는지: 초기화되지 않은 변수를 사용하거나 범위를 벗어나 허용되지 않은 메모리 영역을 액세스하는지 확인, 시스템이 요구하는 eBPF 프로그램의 크기를 만족하는지 확인</li>\n<li>프로그램이 완전히 완료되는지 (i.e. 무한루프): 프로그램의 CFG를 DFS하여 검사</li>\n<li>프로그램이 유한한 복잡성을 가지는지: verifier는 가능한 모든 실행 경로를 평가하며, 설정된 upper complexity limit 내에 분석이 완료되어야 한다.</li>\n</ul>\n<h4 id=\"jit-complication\" style=\"position:relative;\"><a href=\"#jit-complication\" aria-label=\"jit complication permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JIT Complication</h4>\n<p>JIT(Just-in-Time) 컴파일러는 프로그램의 바이트코드를 machine-specific 인스트럭션 세트(x86, ARM, MIPS, etc)로 변환하여 프로그램의 실행 속도를 최적화시킨다.\n이 과정은 eBPF 프로그램이 native kernel code나 커널 모듈로 로드된 코드만큼 효율적으로 실행될 수 있도록 하는 단계로써 성능 최적화를 위한 과정이라고 볼 수 있다.</p>\n<h4 id=\"hardening\" style=\"position:relative;\"><a href=\"#hardening\" aria-label=\"hardening permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hardening</h4>\n<p>verfication에 대한 과정이 성공적으로 완료될 경우, eBPF 프로그램은 강화 프로세스를 통해 실행된다.\n이 단계에는 다음이 포함된다:</p>\n<ul>\n<li>프로그램 실행 보호: eBPF 프로그램을 보유하고 있는 커널 메모리가 보호되고 읽기 전용이 된다. 커널 버그든 악의적인 조작이든 어떤 이유에서든 eBPF 프로그램을 수정하려고 하면 커널이 corrupted/manipulated 프로그램을 계속 실행하지 않고 crash가 난다.</li>\n<li>Spectre에 대한 완화: 추측에 따르면, CPU는 분기를 잘못 예측하고 side channel을 통해 추출될 수 있는 관측 가능한(observable) side effect를 남기 수 있다. 예를 들어, eBPF 프로그램은 일시적인 명령에 따른 액세스를 제어 영역으로 redirection하기 위해 메모리 액세스를 마스킹한다. verifier는 추측 실행에서만 액세스할 수 있는 프로그램 경로를 따르고 JIT 컴파일러는 tail calls를 직접 호출로 변환할 수 없는 경우 Retpolines를 방출한다.</li>\n<li>상수(constant) 블라인드: 코드의 모든 상수는 JIT spraying attack을 방지하기 위해 블라인드된다. 이렇게 하면 공경자가 상수에 실행 코드를 주입하고, 해당 코드를 실행하기 위하여 커널 버그를 이용해 eBPF 프로그램의 메모리 섹션으로 점프하는 것을 방지할 수 있다.</li>\n</ul>\n<h3 id=\"33-ebpf-maps\" style=\"position:relative;\"><a href=\"#33-ebpf-maps\" aria-label=\"33 ebpf maps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. eBPF Maps</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABsUlEQVQoz22Q3WvTcBSG82d77Y3sSgQZ6I3eTRSHDoZU2s65mnXt1pa6fth2SfqRrvlqu7T5apLfI4kUJ3jggfc9B15ejgSQJCktxeSsMeJbS6GhWHhBmJ0QQrCfTO/9arVCUzX6vT66ruN7fr6XQJAkCVPL5VaZc9NVmFguYbT7J+RvmCCOY6bTCWNNYzQaoSoKtmUhRIq0LxCGEaZhslgYuc7D9s0ekU2agm0vUdUxijqm/2uI46xIUoFEbIJwMPUe8sUXqpUCxqwLOxMRGZCxMyG2IbZyH/tzws09zXqJcuGIu16VNDQg3SLdD06ZdE5gew0PNWJHhk0dsa7mZLvAKLNUT3D1EvFSxp2V8GfH6D/f0Dx7gat9wJ9+JPVUpPblO4atz7C5IVnV2C4qBKZMYF7imzKRU0dpvKVZeILe+4Q7/4GhFFAbr5i3D2mVn2F1DnH6r0k9DUlpH9O/fg9uDfGQNbp6RBXcOsGiiDU4QqxlxPoKWz2lU3lO9/sBzeJThvIBxu1LhK8i4Q2I1l3whwhv8F8IRhCpf7Q/BH+Ab1xg3H3F1kpYapHN/Dz/+W8Fq04jfFw5lwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eBPF-6.png\"\n        title=\"eBPF-6.png\"\n        src=\"/static/e7909dc59d2b139b77f901fce04f60a1/37523/eBPF-6.png\"\n        srcset=\"/static/e7909dc59d2b139b77f901fce04f60a1/e9ff0/eBPF-6.png 180w,\n/static/e7909dc59d2b139b77f901fce04f60a1/f21e7/eBPF-6.png 360w,\n/static/e7909dc59d2b139b77f901fce04f60a1/37523/eBPF-6.png 720w,\n/static/e7909dc59d2b139b77f901fce04f60a1/302a4/eBPF-6.png 1080w,\n/static/e7909dc59d2b139b77f901fce04f60a1/e6c84/eBPF-6.png 1148w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>eBPF 프로그램의 중요한 기능은 수집된 정보를 공유하고 state를 저장하는 것이라고 할 수 있다.\n이를 위해 사용되는 eBPF Map 개념은 eBPF 프로그램이 광범위한 자료 구조에 데이터를 저장하고 검색할 수 있도록 해준다.\n“Map”이라는 이름처럼 데이터는 key를 사용해서 저장되고 검색된다.</p>\n<p>Map은 4가지 값으로 정의된다: type, 최대 element 수, value size (bytes), key size (byte)\n다음은 커널에서 지원하는 Map types이다:</p>\n<ul>\n<li><code class=\"language-text\">BPF_MAP_TYPE_HASH</code>: 해시 테이블</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_ARRAY</code>: 빠른 속도에 최적화된 array map으로 counter에 자주 사용됨</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_PROG_ARRAY</code>: eBPF 프로그램에 대한 fd의 array; 특정 packet 프로토콜을 처리하기 위해 jump 테이블 및 sub-program을 구현하는데 사용됨</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_PERCPU_ARRAY</code>: per-CPU array, latency 히스토그램을 구현하는데 사용됨</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>: perf_event 구조체에 대한 포인터를 저장, perf_event counter를 읽고 저장하는데 사용됨</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_CGROUP_ARRAY</code>: cgroup에 대한 포인터 저장</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_PERCPU_HASH</code>: per-CPU 해시 테이블</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_LRU_HASH</code>: MRU(Most Recently Used) 항목을 유지하는 해시 테이블</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_LRU_PERCPU_HASH</code>: MRU per-CPU 해시 테이블</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_LPM_TRIE</code>: LPM(Longest-Prefix Match) 시도, IP 주소를 범위에 매칭시키는 데 적합</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_STACK_TRACE</code>: stack trace 저장</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_ARRAY_OF_MAPS</code>: map-in-map data structure</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_HASH_OF_MAPS</code>: map-in-map data structure</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_DEVICE_MAP</code>: 네트워크 device 참조를 조회 및 저장</li>\n<li><code class=\"language-text\">BPF_MAP_TYPE_SOCKET_MAP</code>: 소켓을 조횜 치 저장. BPF helper 함수로 소켓 리디렉션 허용</li>\n</ul>\n<p>Map은 <code class=\"language-text\">bpf()</code> 시스템콜을 사용해서 생성되고 조작된다.\nMap이 성공적으로 생성되면, 해당 Map과 관련된 fd가 반환된다.</p>\n<p><code class=\"language-text\">bpf()</code> 시스템콜은 eBPF 바이트 코드를 커널에 로드할 뿐만 아니라 User-space의 App이 eBPF가 이용하는 Map에 접근할 수 있게 만들어준다.\n모든 map은 <code class=\"language-text\">bpf_map_lookup_elem()</code> 및 <code class=\"language-text\">bpf_map_update_elem()</code> 함수를 사용하여 eBPF와 user-space 프로그램에서 액세스할 수 있다. (socket map과 같은 일부 map type의 경우에는, eBPF helper 람수를 추가로 사용해야 한다.)\n이를 통해 user-space App과 eBPF 프로그램은 Map을 이용하여 state를 공유하고 통신할 수 있다.</p>\n<p>Map은 일반적으로 연결된 fd를 close함과 동시에 없어진다.</p>\n<h3 id=\"34-bpf-system-call\" style=\"position:relative;\"><a href=\"#34-bpf-system-call\" aria-label=\"34 bpf system call permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. bpf() system call</h3>\n<p>프로그램은 <code class=\"language-text\">BPF_PROG_LOAD</code> 명령과 함께, <code class=\"language-text\">bpf()</code> 시스템콜을 사용하여 로드된다.\n시스템콜의 프로토타입은 다음과 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">bpf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cmd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">union</span> bpf_attr <span class=\"token operator\">*</span>attr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">bpf_attr</code> union을 사용하면 커널과 사용자 공간 간에 데이터를 전달할 수 있다.\n정확한 형식은 <code class=\"language-text\">cmd</code> 인자에 따라 달라진다.\n<code class=\"language-text\">size</code> 인자는 <code class=\"language-text\">bpf_attr</code> union 개체의 크기를 byte 단위로 제공한다.</p>\n<p>eBPF <code class=\"language-text\">cmd</code>는 eBPF 프로그램을 작업하기 위한 명령, eBPF Map을 작업하기 위한 명령, eBPF 프로그램과 Map 모두(object)를 다루기 위한 명령, 이렇게 세 가지 카테고리가 있다.</p>\n<h3 id=\"34-helper-function\" style=\"position:relative;\"><a href=\"#34-helper-function\" aria-label=\"34 helper function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. Helper function</h3>\n<p>eBPF 프로그램은 임의의 커널 함수를 직접 호출할 수 없다.\n즉, 임의의 커널 메모리에 직접 액세스할 수 없으며, 앞선 eBPF verifier가 이를 검사한다.\n이렇게 임의의 커널 함수를 호출할 경우, eBPF 프로그램은 특정 커널 버전에 바인딩되며 프로그램의 호환성이 상당히 복잡해지기 때문이다.\n따라서 eBPF 프로그램은 커널에서 제공하는 비교적 안정적인 API인 helper function을 통해서 일부 커널 함수를 사용한다.\n이것은 일관된 데이터 액세스를 보장하고 eBPF 프로그램이 커널의 데이터 구조를 무작위로 수정하지 못하도록 한다.</p>\n<p>사용할 수 있는 helper function 집합은 계속해서 확장되고 있으며, 다음과 같은 helper function 예시들이 있다:</p>\n<ul>\n<li>난수 생성</li>\n<li>현재 시간 및 날짜 가져오기</li>\n<li>eBPF Map 접근</li>\n<li>프로세스/cgroup context 가져오기</li>\n<li>네트워크 패킷 및 forwarding logic 조작</li>\n</ul>\n<h2 id=\"4-ebpf-an-example\" style=\"position:relative;\"><a href=\"#4-ebpf-an-example\" aria-label=\"4 ebpf an example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. eBPF: An Example</h2>\n<p>리눅스 커널 소스에는 여러 eBPF 예제가 포함되어 있다.\n예제를 컴파일하기 위해서는 다음 명령어를 입력해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">make</span> sample/bpf/</code></pre></div>\n<p><code class=\"language-text\">sample/bpf</code>에서 사용 가능한 샘플 코드 중 하나인 <code class=\"language-text\">tracex4</code> 프로그램을 살펴본다.</p>\n<p>일반적으로 <code class=\"language-text\">sample/bpf/</code>의 모든 예제는 2개의 파일로 구성되어 있으며, 이 파일의 경우 다음과 같이 구성된다.</p>\n<ul>\n<li><a href=\"https://github.com/torvalds/linux/blob/v4.19/samples/bpf/tracex4_kern.c\"><code class=\"language-text\">tracex4_kern.c</code></a>: eBPF 바이트 코드로 커널에서 실행될 소스 코드이다.</li>\n<li><a href=\"https://github.com/torvalds/linux/blob/v4.19/samples/bpf/tracex4_user.c\"><code class=\"language-text\">tracex4_user.c</code></a>: user-space 프로그램을 포함한다.</li>\n</ul>\n<p><code class=\"language-text\">sample/bpf/</code> 하위의 다른 모든 프로그램도 이와 유사한 구조를 따르며, 항상 두 개의 파일이 쌍으로 존재한다.</p>\n<ul>\n<li><code class=\"language-text\">XXX_kern.c</code>: eBPF 프로그램</li>\n<li><code class=\"language-text\">XXX_user.c</code>: main 프로그램</li>\n</ul>\n<p>eBPF 프로그램은 binary 섹션에 hooking 시킬 Map과 함수를 정의한다. 커널이 특정 event를 발생시키면, hook이 실행된다. Map은 커널 프로그램과 user-space 프로그램 간에 데이터를 교환하는 데 사용된다.</p>\n<p>다음에서 두 파일에 대해 자세히 살펴본다.</p>\n<h3 id=\"tracex4_kernc\" style=\"position:relative;\"><a href=\"#tracex4_kernc\" aria-label=\"tracex4_kernc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>tracex4_kern.c</h3>\n<p><code class=\"language-text\">tracex4_kern.c</code>는 c로 작성된 파일이며, eBPF 바이트코드로 컴파일해야 한다.\n<a href=\"https://github.com/torvalds/linux/blob/v4.19/samples/bpf/Makefile#L266\">Makefile</a>에서는 clang을 사용하여 <code class=\"language-text\">tracex4_kern.c</code>를 object 파일로 컴파일한다.</p>\n<p><code class=\"language-text\">tracex4_kern.c</code> 파일 코드를 자세히 살펴보자.\n먼저, 헤더 파일을 먼저 살펴보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;linux/ptrace.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;linux/version.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;uapi/linux/bpf.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"bpf_helpers.h\"</span></span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">uapi/linux/bpf.h</code>: eBPF instruction이 정의된 파일이다.</li>\n<li><code class=\"language-text\">bpf_helpers.h</code>: helper 함수들이 정의되어 있는 헤더 파일이며, 해당 함수들은 모두 대문자이다.</li>\n</ul>\n<p>다음으로 BPF 프로그램이 사용한 Map이 정의되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span> <span class=\"token punctuation\">{</span>\n    u64 val<span class=\"token punctuation\">;</span>\n    u64 ip<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">bpf_map_def</span> <span class=\"token function\">SEC</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"maps\"</span><span class=\"token punctuation\">)</span> my_map <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> BPF_MAP_TYPE_HASH<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>key_size <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>value_size <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">.</span>max_entries <span class=\"token operator\">=</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">BPF_MAP_TYPE_HASH</code>는 eBPF에서 제공하는 많은 Map 유형 중 하나이며, 이 경우 hash 타입의 자료구조를 의미한다.</p>\n<p><code class=\"language-text\">SEC(\"maps\")</code> 선언에서 사용되는 <code class=\"language-text\">SEC</code>은 바이너리에서 새로운 섹션을 만드는 데 사용되는 매크로이다.\n<code class=\"language-text\">tracex4_kern</code> 예제에서는 아래와 같이 두 개의 섹션을 더 정의한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">SEC</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kprobe/kmem_cache_free\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">bpf_prog1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pt_regs</span> <span class=\"token operator\">*</span>ctx<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span> ptr <span class=\"token operator\">=</span> <span class=\"token function\">PT_REGS_PARM2</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">bpf_map_deleted_elem</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>my_map<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">SEC</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"kretprobe/kmem_cache_alloc_node\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">bpf_prog2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">pt_regs</span> <span class=\"token operator\">*</span>ctx<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span> ptr <span class=\"token operator\">=</span> <span class=\"token function\">PT_REGS_RC</span><span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> ip <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// get ip address of kmem_cache_alloc_node() caller</span>\n    <span class=\"token function\">BPF_KRETPROBE_READ_RET_IP</span><span class=\"token punctuation\">(</span>ip<span class=\"token punctuation\">,</span> ctx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">pair</span> v <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> <span class=\"token function\">bpf_ktime_get_ns</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">.</span>ip <span class=\"token operator\">=</span> ip<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// update bpf map</span>\n    <span class=\"token function\">bpf_map_update_elem</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>my_map<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ptr<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">,</span> BPF_ANY<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 두 가지 함수를 사용하면 Map애서 entry를 삭제(<code class=\"language-text\">kprobe/kmem_cach_free</code>)허거나 Map에 새 entry를 추가(<code class=\"language-text\">kretprobe/kmem_cache_alloc_node</code>)할 수 있다.\n대문자로 된 모든 함수 호출은 <a href=\"https://raw.githubusercontent.com/torvalds/linux/v4.19/tools/testing/selftests/bpf/bpf_helpers.h\"><code class=\"language-text\">bpf_helpers.h</code></a>에 정의된 매크로이다.</p>\n<p>object 파일을 dump하면 다음과 같이 정의된 섹션을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ objdump -h tracex4_kern.o\n\ntracex4_kern.o:     file format elf64-little\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         00000000  0000000000000000  0000000000000000  00000040  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 kprobe/kmem_cache_free 00000048  0000000000000000  0000000000000000  00000040  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  2 kretprobe/kmem_cache_alloc_node 000000c0  0000000000000000  0000000000000000  00000088  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n  3 maps          0000001c  0000000000000000  0000000000000000  00000148  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  4 license       00000004  0000000000000000  0000000000000000  00000164  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  5 version       00000004  0000000000000000  0000000000000000  00000168  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  6 .eh_frame     00000050  0000000000000000  0000000000000000  00000170  2**3\n                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</code></pre></div>\n<h3 id=\"tracex4_userc\" style=\"position:relative;\"><a href=\"#tracex4_userc\" aria-label=\"tracex4_userc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>tracex4_user.c</h3>\n<p>이 프로그램은 메인 프로그램이며, <code class=\"language-text\">kmem_cache_alloc_node</code> 이벤트를 수신하는 역할을 한다.\n해당 이벤트가 발생하면 해당 eBPF 코드가 실행된다.\n이 코드는 object의 IP 속성을 Map에 저장하고 메인 프로그램에서 loop로 프린트한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> ./tracex4\nobj 0xffff8d6430f60a00 is  2sec old was allocated at <span class=\"token function\">ip</span> ffffffff9891ad90\nobj 0xffff8d6062ca5e00 is 23sec old was allocated at <span class=\"token function\">ip</span> ffffffff98090e8f\nobj 0xffff8d5f80161780 is  6sec old was allocated at <span class=\"token function\">ip</span> ffffffff98090e8f</code></pre></div>\n<p>user-space 프로그램과 eBPF 프로그램은 연결되는 방법은 아래와 같다.\n먼저, 초기화 시에 <code class=\"language-text\">tracex4_user.c</code>는 <code class=\"language-text\">load_bpf_file</code> 함수를 사용하여 <code class=\"language-text\">tracex4_kern.o</code> object 파일을 로드한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ac<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">rlimit</span> r <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>RLIM_INFINITY<span class=\"token punctuation\">,</span> RLIM_INFINITY<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> filename<span class=\"token punctuation\">[</span><span class=\"token number\">256</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">snprintf</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"%s_kern.o\"</span><span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">setrlimit</span><span class=\"token punctuation\">(</span>RLIMIT_MEMLOCK<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"setlimit(RLIMIT_MEMLOCK, RLIM_INFINITY)\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// load bpf object file</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">load_bpf_file</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\"</span><span class=\"token punctuation\">,</span> bpf_log_buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print_old_objects</span><span class=\"token punctuation\">(</span>map_fd<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이후 <a href=\"https://github.com/torvalds/linux/blob/v4.19/samples/bpf/bpf_load.c#L492\"><code class=\"language-text\">load_bpf_file</code></a> 함수가 실행되면, eBPF 파일에 정의된 probe가 <code class=\"language-text\">/sys/kernel/debug/tracing/kprobe_events</code>에 추가된다.\n추가된 이후에는 등록된 event를 listen하며, event가 트리거되면 eBPF 프로그램이 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> /sys/kernel/debug/tracing/kprobe_events\np:kprobes/kmem_cache_free kmem_cache_free\nr:kprobes/kmem_cache_alloc_node kmem_cache_alloc_node</code></pre></div>\n<h2 id=\"5-why-ebpf\" style=\"position:relative;\"><a href=\"#5-why-ebpf\" aria-label=\"5 why ebpf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Why eBPF?</h2>\n<p>eBPF의 강력한 기능으로 인해, 인텔의 Brendan Gregg는 BPF 기술을 <a href=\"http://www.brendangregg.com/blog/2016-03-05/linux-bpf-superpowers.html\">Linux superpower</a>라고 언급한바 있다.</p>\n<p>왜 이렇게 많은 사람들은 eBPF 기술을 극찬하고, 또 커널 개발자들은 eBPF 기술에 주목할까</p>\n<h3 id=\"programmability의-힘\" style=\"position:relative;\"><a href=\"#programmability%EC%9D%98-%ED%9E%98\" aria-label=\"programmability의 힘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Programmability의 힘</h3>\n<p>20년 전, 웹 페이지는 주로 HTML(Static Markup Language)만을 사용하여 작성되었다.\n웹 페이지는 기본적으로 문서를 표시할 수 있는 application(browser)였다.</p>\n<p>하지만 오늘날의 웹 페이지는 어떠한가.\n오늘날의 웹 페에지는 완전한 application이 되었으며(e.g., facebook, gmail, twitter), 웹 기반 기술들은 컴파일이 필요한 언어로 작성된 application의 대다수를 대체해왔다.</p>\n<p>무엇이 이러한 진화를 가능하게 했는가?</p>\n<p>바로, JavaScript와 함께 도입된 programmability이다.\n이는 브라우저가 거의 독립적인 운영 체제로 진화하는 거대한 혁명을 일으켰다.</p>\n<p>이러한 진화는 왜 일어났는가?\n프로그래머는 더 이상 특정 브라우저 버전을 실행하는 사용자에게 종속되지 않았다.\n새로운 HTML 태그가 필요하다고 표준 기관을 설득하는 대신, 필요한 building block의 가용성을 기본 브라우저의 혁신 속도 위에서 실행되는 application과 분리했다.\n이것은 물론 HTML이 시간이 지남에 따라 진화했다는 점도 일조했지만, HTML의 진화 자체로는 그것을 설명하기에 충분하지 않았다.</p>\n<p>이러한 예제를 사용하여 eBPF에 적용하기 전에 JavaScript의 도입에 있어 중요한 몇 가지 측면들을 살펴보자면 다음과 같다:</p>\n<ul>\n<li>Safety: 신뢰할 수 없는 코드가 사용자의 브라우저에서 실행되는 문제는 JavaScript 프로그램을 sandboxing하고 브라우저 데이터에 대한 액세스를 추상화하여 해결하였다.</li>\n<li>Continuous Delivery: 새로운 브라우저 버전을 지속적으로 출시하지 않고도 프로그램 로직의 진화하는 문제는 임의의 논리를 빌드하기에 충분한 적절한 low-level building block을 제공함으로써 해결되었다.</li>\n<li>Performance: Programmability는 최소한의 오버헤드로 제공되어야 한다. 이 문제는 JIT(Just-in-Time) 컴파일러의 도입으로 해결되었다.</li>\n</ul>\n<p>위의 모든 경우에서 동일한 이류로 eBPF에서 정확히 대응되는 여러 부분들을 찾을 수 있다.</p>\n<p>리눅스 커널의 주요 목적은 하드웨어 또는 가상 하드웨어를 추상화하고 application이 리소스를 사용하고 공유할 수 있도록 일관된 API(system call)을 제공하는 것이다.\n이를 달성하기 위해서, 커널의 광범위한 하위 시스템 및 계층들이 이러한 책임들을 분산하여 유지 관리한다.\n각 하위 시스템은 일반적으로 사용자의 다양한 요구를 충족하기 위해 일정 수준의 구성을 허용한다.\n만약 원하는 동작을 구성할 수 없는 경우에는 커널을 변경해야 하며, 아래와 같은 두 가지 옵션이 존재한다:</p>\n<ul>\n<li>Native Support\n<ol>\n<li>커널 소스 코드를 변경하고 리눅스 커널 커뮤니티에 변경이 필요하다고 설득한다.</li>\n<li>새 커널 버전이 릴리즈될 때까지 몇 년을 기다려야한다.</li>\n</ol>\n</li>\n<li>Kernel Module\n<ol>\n<li>커널 모듈을 작성한다.</li>\n<li>모든 커널 릴리스에 맞춰 정기적으로 수정해야 한다.</li>\n<li>보안 경계가 없기 때문에 리눅스 커널이 손상될 위험이 있다.</li>\n</ol>\n</li>\n</ul>\n<p>그러나, eBPF에서는 커널 소스 코드를 변경하거나 커널 모듈을 로드하는 위의 두 가지 옵션을 사용하지 않고도, 리눅스 커널의 동작을 다시 프로그래밍할 수 있는 새로운 옵션을 사용할 수 있다.\n여러 면에서 이러한 점들이 JavaScript 및 기타 스크립팅 언어가 변경하기 어렵거나 변경에 비용이 많이 드는 시스템의 진화를 어떻게 풀어내었는지와 매우 유사하다.</p>\n<h2 id=\"6-bpf-code-in-kernel\" style=\"position:relative;\"><a href=\"#6-bpf-code-in-kernel\" aria-label=\"6 bpf code in kernel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. BPF code in kernel</h2>\n<ul>\n<li><code class=\"language-text\">linux/include/linux/bpf.h</code> 파일과 이에 관련된 <code class=\"language-text\">linux/include/uapi/bpf.h</code> 파일에는 커널에서 사용하거나 userspace 프로그램과 인터페이스하기 위한 eBPF 관련 정의가 포함되어 있다.</li>\n<li><code class=\"language-text\">linux/include/linux/filter.h</code> 및 <code class=\"language-text\">linux/include/uapi/filter.h</code> 파일에는 BPF 프로그램을 실행하는 데 사용되는 정보가 포함되어 있다.</li>\n<li>eBPF와 괄년된 주요 코드는 <code class=\"language-text\">linux/kernel/bpf/</code> 디렉토리에 있다. 프로그램 로딩이나 map 관리와 같은 시스템콜에 의해 실행되는 작업들은 <code class=\"language-text\">syscall.c</code> 파일에서 구현된다. 반면, <code class=\"language-text\">core.c</code>는 인터프리터를 포함한다. <code class=\"language-text\">verifier.c</code> 파일에는 in-kernel verifier가 포함되어 있고, <code class=\"language-text\">arrarymap.c</code>는 array-type의 map과 상호 작용하는 데 사용되는 코드들이 있다.</li>\n<li>네트워킹과 관련된 helper (e.g., tc, XDP) 및 사용자가 사용할 수 있는 여러 함수는 <code class=\"language-text\">linux/net/core/filter.c</code>에 구현되어 있다. 이 코드는 cBPF 바이트코드를 eBPF로 마이그레이션하는 코드도 초함한다. (모든 cBPF 프로그램은 실행되기 전에 커널에서 eBPF로 변환된다.)</li>\n<li>event tracing과 관련된 helper 및 함수들은 <code class=\"language-text\">linux/kernel/trace/bpf_trace.c</code>에 구현되어 있다.</li>\n<li>JIT 컴파일러는 각 아키텍처 디렉토리에 위치하며 x86의 경우, <code class=\"language-text\">linux/arch/x86/net/bpf_jit_comp.c</code> 파일에 있다. HW offload로 사용되는 JIT 컴파일러의 경우 예외적으로 드라이버에 위치한다. 예를 들어, Netronome NFP 카드의 경우, <code class=\"language-text\">linux/drivers/net.ethernet/netronome/nfp/bpf/jit.c</code>에 위치한다.</li>\n<li>eBPF의 tc와 관련된 구성 요스들은 <code class=\"language-text\">linux/net/sched/</code> 디렉터리에서 찾을 수 있으며, 주로 <code class=\"language-text\">act_bpf.c</code>(action)과 <code class=\"language-text\">cls_bpf.c</code>(filter)에 있다.</li>\n<li>seccomp-BPF의 코드는 <code class=\"language-text\">linux/kernel/seccomp.c</code>에서 찾을 수 있으며, 이를 사용한 예제 코드는 <code class=\"language-text\">linux/tools/testing/selftests/seccomp/seccomp_bpf.c</code>에서 찾을 수 있다.</li>\n</ul>\n<h2 id=\"7-development-toolchains\" style=\"position:relative;\"><a href=\"#7-development-toolchains\" aria-label=\"7 development toolchains permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Development Toolchains</h2>\n<p>eBPF 프로그램의 개발 및 관리를 지원하기 위하여 여러 개발 도구들이 존재하며, 이러한 다양한 도구들에 대해서는 아래에서 설명한다.</p>\n<h3 id=\"bcc-ebpf-compile-collection\" style=\"position:relative;\"><a href=\"#bcc-ebpf-compile-collection\" aria-label=\"bcc ebpf compile collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BCC (eBPF Compile Collection)</h3>\n<p>BCC는 사용자가 eBPF 프로그램 작성, 컴파일 및 로드를 위한 프레임워크이다.</p>\n<h3 id=\"bpftrace\" style=\"position:relative;\"><a href=\"#bpftrace\" aria-label=\"bpftrace permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>bpftrace</h3>\n<p>bpftrace는 리눅스 eBPF용 고급 tracing 언어이며, 리눅스 커널 v4.x에서 사용할 수 있다.\nbpftrace는 LLVM을 백엔드로 사용하여 스크립트를 eBPF 바이트코드로 컴파일하고, 리눅스 eBPF 서브시스템 및 기존 리눅스 tracing capabiltieis(kprobes(커널 동적 tracing), uprobes(user-level 동적 tracing), tracepoints)와 BCC를 사용하여 상호 작용한다.\nbpftrace 언어는 awk, C 및 이전 tracer인 DTrace, SystemTap에서 영감을 받았다.</p>\n<h3 id=\"ebpf-go-library\" style=\"position:relative;\"><a href=\"#ebpf-go-library\" aria-label=\"ebpf go library permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>eBPF Go Library</h3>\n<p>eBPF Go 라이브러리는 eBPF 바이트코드를 전달받는 프로세스와 eBPF 프로그램을 로드하고 관리하는 프로세스를 서로 분리하여 일반적인 eBPF 라비으러리를 제공한다.\neBPF 프로그램은 일반적으로 더 높은 수준의 언어를 작성한 다음, clang/LLCM 컴파일러를 사용하여 eBPF 바이트 코드로 컴파일하여 만든다.</p>\n<h3 id=\"libbpf-cc-library\" style=\"position:relative;\"><a href=\"#libbpf-cc-library\" aria-label=\"libbpf cc library permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>libbpf C/C++ Library</h3>\n<p>libbpf 라이브러리는 C/C++ 기반의 일반 eBPF 라이브러리로, clang/LLVM 컴파일러에서 생성된 eBPF object 파일을 로드하는 과정을 커널에서 분리하는 데에 도움이 된다.\n일반적으로 애플리케이션에서 사용하기 쉬운 라이브러리 API를 제공함으로써 BPF 시스템콜과의 추상화된 상호 작용 방법을 제공한다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://kubernetes.io/blog/2017/12/using-ebpf-in-kubernetes/\">https://kubernetes.io/blog/2017/12/using-ebpf-in-kubernetes/</a></li>\n<li><a href=\"https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/\">https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/</a></li>\n<li><a href=\"https://www.ferrisellis.com/content/ebpf_past_present_future/\">https://www.ferrisellis.com/content/ebpf_past_present_future/</a></li>\n<li><a href=\"https://blogs.igalia.com/dpino/2019/01/07/introduction-to-xdp-and-ebpf/\">https://blogs.igalia.com/dpino/2019/01/07/introduction-to-xdp-and-ebpf/</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=4SiWL5tULnQ\">https://www.youtube.com/watch?v=4SiWL5tULnQ</a></li>\n<li><a href=\"https://ebpf.io/what-is-ebpf/#what-is-ebpf\">https://ebpf.io/what-is-ebpf/#what-is-ebpf</a></li>\n<li><a href=\"https://lwn.net/Articles/740157/\">https://lwn.net/Articles/740157/</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#0-bpf\">0. BPF</a></p>\n</li>\n<li>\n<p><a href=\"#1-cbpf-vs-ebpf\">1. cBPF vs. eBPF</a></p>\n<ul>\n<li><a href=\"#bpf%EC%9D%98-%EC%97%AD%EC%82%AC\">BPF의 역사</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-how-to-work\">2. How to work</a></p>\n</li>\n<li>\n<p><a href=\"#3-ebpf%EB%A5%BC-%EC%9D%B4%EB%A3%A8%EB%8A%94-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C%EB%93%A4\">3. eBPF를 이루는 구성 요소들</a></p>\n<ul>\n<li>\n<p><a href=\"#31-ebpf-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8\">3.1. eBPF 프로그램</a></p>\n</li>\n<li>\n<p><a href=\"#32-loader--verification\">3.2. Loader &#x26; Verification</a></p>\n<ul>\n<li><a href=\"#verification\">Verification</a></li>\n<li><a href=\"#jit-complication\">JIT Complication</a></li>\n<li><a href=\"#hardening\">Hardening</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#33-ebpf-maps\">3.3. eBPF Maps</a></p>\n</li>\n<li>\n<p><a href=\"#34-bpf-system-call\">3.4. bpf() system call</a></p>\n</li>\n<li>\n<p><a href=\"#34-helper-function\">3.4. Helper function</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-ebpf-an-example\">4. eBPF: An Example</a></p>\n<ul>\n<li><a href=\"#tracex4_kernc\">tracex4_kern.c</a></li>\n<li><a href=\"#tracex4_userc\">tracex4_user.c</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-why-ebpf\">5. Why eBPF?</a></p>\n<ul>\n<li><a href=\"#programmability%EC%9D%98-%ED%9E%98\">Programmability의 힘</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#6-bpf-code-in-kernel\">6. BPF code in kernel</a></p>\n</li>\n<li>\n<p><a href=\"#7-development-toolchains\">7. Development Toolchains</a></p>\n<ul>\n<li><a href=\"#bcc-ebpf-compile-collection\">BCC (eBPF Compile Collection)</a></li>\n<li><a href=\"#bpftrace\">bpftrace</a></li>\n<li><a href=\"#ebpf-go-library\">eBPF Go Library</a></li>\n<li><a href=\"#libbpf-cc-library\">libbpf C/C++ Library</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","excerpt":"리눅스 커널에 대해 공부한다면, eBPF에 대해 한 번쯤은 들어봤을 것이다.\n필자가 주로 연구했던 분야인 Seccomp도 BPF 기술을 이용하는 리눅스 커널의 보안 모듈이다.\n따라서 석사 과정동안 공부했던 내용들을 기록하기 위해서는 가장 먼저 BPF에 대한 정리가 필요할 것 같아, 이렇게 기록하고자 한다. 0. BPF BPF란 Berkeley Packet Filter의 약자이다(였다).\n이 개념은 1992년 Steve McCane과 Van Jacobson의 Usenix Conference Winter ‘93 논문 “The BSD Packet Filter: A New Architecture for User-level Packet Capture”에서 처음으로 소개되었다.\n커널과 같은 Privileged context에서 sandboxed program을 실행할 수 있는 기술이다.\n즉, 커널 내부에 사용자가 작성한 코드를 삽입하여 안전하게 실행시킬 수 있는 도구이며, 커널 모듈이 아닌 …","frontmatter":{"date":"October 24, 2022","title":"TIL - eBPF","categories":"TIL Linux","author":"Mini","emoji":"📖"},"fields":{"slug":"/TIL/eBPF/"}},"next":{"id":"b84b41f9-05f8-5a6c-9d97-6db44084c1fa","html":"<p>졸업하고 첫 이력서를 냈던 곳이 바로 AWS Korea이다.</p>\n<p>국내 기업과 달리 AWS 같은 경우 외국계 기업이기도 했고 채용 프로세스도 특이한 점이 많았다.\n그래서 인터뷰를 준비할 때 여러 가지 어려운 점들이 많았는데, 다행히 여러 분들의 블로그 포스팅을 보머 인터뷰 과정에 많은 도움을 받을 수 있었다.</p>\n<p>그동안 AWS 인터뷰를 준비하면서 여러 가지 경험했던 것들을 공유하고자 글을 남긴다.</p>\n<p>이 글을 보는 당신께도 좋은 결과가 있길 바라며!</p>\n<h2 id=\"0-aws의-채용-프로세스\" style=\"position:relative;\"><a href=\"#0-aws%EC%9D%98-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"0 aws의 채용 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. AWS의 채용 프로세스</h2>\n<p>본격적으로 경험담을 공유하기에 앞서, AWS의 채용 프로세스에 대해 간략하게 소개하고 들어가겠다.\n이 부분의 경우, 각 포지션마다 프로세스가 상이할 수 있으니 다른 포지션일 경우 내용을 선별해서 참고해야 한다.\n필자의 경우, Associate Solutions Architect 포지션에 지원했다.</p>\n<p>각 인터뷰이에게는 채용 담당자분들이 채용 프로세스를 스케쥴링해주시는데, 이분들께 문의하면 각 포지션에 대한 채용 프로세스를 안내받을 수 있다.</p>\n<blockquote>\n<p>💡 참고로, AWS의 채용 담당자분들은 정말 친절하시다!\n이 부분이 채용을 준비하며 가장 감동했던 것 중 하나이다.\n그러니, 궁금한게 있으면 주저말고 직접 물어보자!</p>\n</blockquote>\n<p>내가 진행했던 프로세스는 다음과 같다. (참고로 모두 Online으로 진행되었다.)</p>\n<p><strong>Job Application > Phone Interview (60 min) > Assignment Interview (60 min) > Loop Interview (60 min * 4)</strong></p>\n<h2 id=\"1-job-application\" style=\"position:relative;\"><a href=\"#1-job-application\" aria-label=\"1 job application permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Job Application</h2>\n<p>여느 기업과 마찬가지로 AWS도 직무에 따라 사람들을 모집하고 있다.\n현재 오픈된 Job들의 경우 <a href=\"https://www.amazon.jobs/en/\">Amazon Jobs 페이지</a>에서 찾을 수 있다.</p>\n<p>필자의 경우에도 해당 홈페이지의 Job 포지션과 Description을 읽고, Solutions Architect (SA)로 지원을 했다.\n정확하게 말하면, Associate Soluations Architect (ASA) 직무인데, SA와의 차이점은 Ramp-up 기간의 유무이다.\nASA 포지션으로 지원할 경우, 1년 간의 Ramp-Up 기간이 주어지고 이 기간동안 SA로써 고객분들을 직접 대면하기 위한 준비를 마친다.\n즉, ASA 직무의 경우 경력이 없는 주니어 개발자들을 위한 포지션이라고 할 수 있다.</p>\n<p>원하는 포지션에 Resume를 제출하면 그 때부터 채용 과정이 시작된다.\n필자의 경우, 3페이지의 Resume를 제출했다. (물론 영어로 작성했다.)</p>\n<p>첫 페이지는 Personal Info를 비롯한, Education, Project, Publication 등 이력에 대한 개요를 한 눈에 볼 수 있도록 했고,\n2페이지, 3페이지에서는 각 프로젝트에 대한 좀 더 자세한 설명이 담기 수 있도록 작성했다.</p>\n<blockquote>\n<p>💡 참고로, Resume라는 것 또한 처음 작성해본 것이기 때문에 열심히 구글링해가며 여러 개발자분들의 이력서를 참고했다.\n그 중 가장 많은 영감을 준 Woony님의 <a href=\"https://wonny.space/writing/work/engineer-resume\">개발자 이력서 작성하기 (feat. 이력서 공개)</a> 포스팅이다. (Woony님 정말 감사합니다.)\nResume를 처음 작성해보는 주니어 개발자분들이 있다면 꼭 한번 읽어보길 바란다.</p>\n</blockquote>\n<p>Job에 Apply하고 Resume를 제출하면 다음과 같이 내가 지원한 포지션을 확인할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABT0lEQVQoz5XOa0/CMBgF4P4PBQQUUTaG3OSygcgEJcTrB2P472q8JjAu24rrYOOYFjCYCIlNnpy+Z007kiqdQWveIFdtIXSYx9Z+BtvxLALxrMilwEoqRR3S8SkichGJfA1hqYC02sSuUgaJJDVElQoiiiZEUxXwLpxU15NV7MjLLM9Tmic5yOnQrzqoX3ZQaz+g2rpHuXEnHlkrVV2LhCQVsUxdDLFMDXtHJwgnNQQTZQQTpX8jmUoLjfY10toFivqt+Dup0IBcOv8lucHqGTIcjvD2+gKj38f7xycen57BO0rpwlikadlr2TYVLJuCAMBgMIRh9NDrduF7HiYzwHQ9DMYuDMpgORNsWiabgrqe2BPf9+G6LhhjcBjDbDaDaVMYgxHGDsPIHoN+MXieL77x86t45049gc+EF9xy8a3jOLAsi08/vS8u+xsWd3DfKhLXy3ZyrHoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AWS-interview-1.png\"\n        title=\"AWS-interview-1.png\"\n        src=\"/static/18a9f4ad6ef65fa85ec3e6e45f565370/37523/AWS-interview-1.png\"\n        srcset=\"/static/18a9f4ad6ef65fa85ec3e6e45f565370/e9ff0/AWS-interview-1.png 180w,\n/static/18a9f4ad6ef65fa85ec3e6e45f565370/f21e7/AWS-interview-1.png 360w,\n/static/18a9f4ad6ef65fa85ec3e6e45f565370/37523/AWS-interview-1.png 720w,\n/static/18a9f4ad6ef65fa85ec3e6e45f565370/302a4/AWS-interview-1.png 1080w,\n/static/18a9f4ad6ef65fa85ec3e6e45f565370/07a9c/AWS-interview-1.png 1440w,\n/static/18a9f4ad6ef65fa85ec3e6e45f565370/f238d/AWS-interview-1.png 2078w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>제출한 그 순간부터 채용 프로세스가 시작된다!</p>\n<h2 id=\"2-phone-interview\" style=\"position:relative;\"><a href=\"#2-phone-interview\" aria-label=\"2 phone interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Phone Interview</h2>\n<p>필자의 경우, 7월 27일에 이력서를 제출했고 이틀 뒤인 7월 29일에 Phone Interview를 보자는 메일을 받았다.\n사실 이 부분이 채용 과정에 있어 매우 놀랐던 부분 중 하나인데, 채용 프로세스가 매우 타이트하게 이루어진디.</p>\n<p>보통 이력서의 경우 이틀 내로 합격 연락이 왔으며, Phone Interview의 경우에는 당일 인터뷰를 본 뒤 3시간 만에 연락외 왔다. Assignment Interview도 마찬가지로 하루 뒤에 합격 연락이 왔다.\n마지막, 인터뷰의 경우는 현재 연락을 기다리고 있는 상황이기 때문에 정확이 알 수는 없지만, 다른 분들의 경우를 찾아보니 일주일정도가 걸리는 듯 했다.</p>\n<p>그래서 지원자의 준비만 되어있다면, 전체 프로세스를 한 달 이내로 마무리할 수도 있다.\n하지만 필자의 경우 인터뷰 중간에 추석 연휴와 해회 학회 참석이 있어 인터뷰 프로세스가 평균보다 길어진 편인 것 같다.</p>\n<p>1차 Resume 검토가 완료되면, 다음과 같이 합격 메일이 날라올 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACbElEQVQ4y5VTTWsTURSdn6PJjJ2PN9OZyXy9yUySJimCUStCN4LUhcQvdNHsihSXheqqi0JJLaYWN4qtKxFciaArRdQiummxurBUKZIj94UJCZaii8O5l7nvvHN5Z6TNb7+ws7ePrb0uvuwCn3e7/48fXbz/uod327uQXrz5hOWlFax0HqHdWUe78xjLnXUsr673+AC0s3q1V9+9/wSvP27hw85PSEtrD2HoDI7jQtc0GLoBRZaRO5qDnM+LWs7LgntQcExR+n0+lxPnNp6/xOb3fUhrG0+RFDlONBoYHx9HvV5HrVbD2NgYkiQRKBaLiONYsO/7cF1X9Gmaiu9+EODZq7fY/g1IrZlZFONYiFQqFSFEoJ4EwjBEFEVDTKKMMZimKXh0dBS35m5j8d4DSIwZsG0bjuMMMYGcFAqFPmegnoSGYcBkOqRCwYWu6wJBEIg1aJ2Yc+EwSVOkpRI4761MK3LOxRxdTudI0PM8hGEAyXUdGIZxwI20kgWbWdBVA7bJDpzJzpIx3/eGBYkzUG8zF7rFEVUa0JkHh9l/zR0qOHijqqkYkUdwxC3hzJUWckYAXdH6Kw6aONShyUzII3mcO34eC5cWcfPCPFpT85idmsOd5gIa5VNQVAWMmf/m0LIsqLqKk5XTuDE5jebEZVw7exUXJ5q4PjmNWlyHZmhijpBFZ0iwWq2KQFMO0zQRLxjFIdzARRAH8EIPlmPBck14vidSQJkkUE2vTTp9wSz1cVxESOEVwxw84ojCXpgDPxCgUBMoj9lfQxsOOSyVy8JdUqqAl+vg5Rr8kIuhgueJjBFIIKszQeLBlf8Atc9Uikakzh4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AWS-interview-2.png\"\n        title=\"AWS-interview-2.png\"\n        src=\"/static/e12f962163637423d8a01c4477f1f149/37523/AWS-interview-2.png\"\n        srcset=\"/static/e12f962163637423d8a01c4477f1f149/e9ff0/AWS-interview-2.png 180w,\n/static/e12f962163637423d8a01c4477f1f149/f21e7/AWS-interview-2.png 360w,\n/static/e12f962163637423d8a01c4477f1f149/37523/AWS-interview-2.png 720w,\n/static/e12f962163637423d8a01c4477f1f149/302a4/AWS-interview-2.png 1080w,\n/static/e12f962163637423d8a01c4477f1f149/07a9c/AWS-interview-2.png 1440w,\n/static/e12f962163637423d8a01c4477f1f149/71ba4/AWS-interview-2.png 1870w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>‘Enter your availability’ 버튼을 누르면, Interview Preferences를 제출하는 페이지가 뜬다.\n2주 이내로, 자신이 인터뷰 가능한 날짜와 시간을 기입하여 제출하면 된다.</p>\n<blockquote>\n<p>💡 참고로, 각 프로세스가 진행될 때마다 Interview Preferences를 조사하는데 보통 24시간 이내로 답장을 주어야한다.\n특이사항이 있을 경우, 역시나 주저말고 채용 담당자분께 메일을 드리자!\n누구보다 친절하게 답변해주실 것이다.</p>\n</blockquote>\n<p>Interview Preferences를 제출한 후 이틀 뒤 면접 일정에 대한 안내 메일이 왔다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABs0lEQVQoz52QS2/aUBCF/X94GPsaIyGMbTDG4AcY2ADpD+qym2abTfeViPJQ1lmQdFtFgShK0ipKSBqlKYhWrXSqGWIadZnFpzNnxnesM9J0NseKBaZ3S9bJ7Q+c3rwOaTKb4+x+iW+LJR6f7vG4mON2CVw+/cHVK5CmdwucXH/H7sEY2x93MNo5xGjvCNvE/jMv68T/16M3o70xpPOHn/g0+QLH8SBnBTShQ5FV5LIKI2dya+X62f+brfpC0aApGi38hePTKzSDAKZpwLZtODUHXsOD7zcRRRHXYRgijEIEgY+6V4dbdxHHbfiBz31dz0MIdRV5fHKButdEoVBAqVSCbdm8uFqtwnEcmKbJ6rouK/WJWm3lSXVdh6ZpkGa/gc9fH+AHEUyzDMu2UalUeIllWSgWizAMA0IIpFIpZDKZNel0el3LsgxVVSFtbn3A23fv0Wg08WZjA91uF8PhkLXf73M9GAzYx3GMdruNVqvFJ+h0OuypJqV0klBzUHJZNrQgGSYf9no9hjwp3ZQW0g9oISWhFPSeYksUs1w2kM/nGWomJD6ZEXSnl32KqSgKQ2f5C33+3O7xh4aIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AWS-interview-3.png\"\n        title=\"AWS-interview-3.png\"\n        src=\"/static/008fe26311402cb5baa48ce866b76508/37523/AWS-interview-3.png\"\n        srcset=\"/static/008fe26311402cb5baa48ce866b76508/e9ff0/AWS-interview-3.png 180w,\n/static/008fe26311402cb5baa48ce866b76508/f21e7/AWS-interview-3.png 360w,\n/static/008fe26311402cb5baa48ce866b76508/37523/AWS-interview-3.png 720w,\n/static/008fe26311402cb5baa48ce866b76508/302a4/AWS-interview-3.png 1080w,\n/static/008fe26311402cb5baa48ce866b76508/0940f/AWS-interview-3.png 1154w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>해당 메일과 함께 면접에 대한 안내 사항이 담긴 메일도 오는데, 이 부분 또한 매우 인상깊었던 점 중 하나이다.\n뒤에서 설명하겠지만, AWS 및 Amazon은 <a href=\"https://www.amazon.jobs/en/principles\"><strong>Leadership Principle</strong></a> 문화를 매우 중시한다.\n16가지 Leadership Principle이 존재하는데, 그 중 첫 번째 원칙인 <strong>Customer Obsession</strong>에 대해 몸소 느낄 수 있는 안내 메일이었다.</p>\n<p>지원한 포지션이 어떤 포지션인지에 대한 설명부터 관련된 여러 참고 자료 링크 및 인터뷰 팁까지, 정말 자세한 안내 메일이 보내주신다.\n이후로도 각 프로세스마다 각 인터뷰 과정에 대해 정말 자세하게 알려주시는데, 안내 메일의 경우 채용 담당자에 따라 조금씩 다른 것 같아 보였다.</p>\n<p>사실, 이 인터뷰의 경우 국내 IT 기업의 기술 인터뷰 형식과 비슷하다고 느꼈다.\n다만, 각 포지션 별로 집중적으로 질문하는 범위가 어느 정도 있는 것 같았다.</p>\n<p>Phone Interview를 준비하면서 많이 참고했던 포스팅들은 다음과 같다.</p>\n<ul>\n<li><a href=\"https://velog.io/@jeon3029/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B3%B5%ED%95%99-CS-%EA%B3%B5%EB%B6%80%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%A7%81%ED%81%AC%EB%8B%A8%EC%88%9C-%EB%A7%81%ED%81%AC-%EB%AA%A8%EC%9D%8C\">IT 기업 면접 준비, 컴퓨터 공학 CS 공부를 위한 유용한 링크(단순 링크 모음)</a></li>\n<li><a href=\"https://github.com/JaeYeopHan/Interview_Question_for_Beginner\">Interview Question for Beginner</a></li>\n</ul>\n<p>다양한 영역에 대해 기술 면접 질문 및 답변들이 깔끔하게 정리되어있다.</p>\n<p>SA 인터뷰 질문들을 구글링해가며, 해당 질문과 관련된 부분들에 대해 집중적으로 준비할 것을 권장한다.\n예를 들어, ‘3 tier 웹 어플리케이션의 정의와 구성방식’, ‘RDBMS와 NoSQL의 차이’, ‘TCP와 UDP의 차이’ 같은 질문들이 있을 것이다.</p>\n<p>그리고 면접을 준비할 때 해당 기술에 대해 정확하게 숙지하는 것도 중요하지만, <strong>Keyword를 포함하여 한 문장으로 말하는 것</strong>이 매우 중요하다는 것을 느꼈다.\n즉, 인터뷰어꼐서 어떠한 질문을 하실 때, 구구절절 길게 답변하는 것보다 핵심 keyword를 담은 한 문장으로 답변하는 것이 좋다.\n그래서 예상 질문을 뽑아두고 한 문장으로 답변하는 연습을 많이 할 것을 적극 권장하는 바이다.</p>\n<p>인터뷰의 경우, 총 60분간 진행되었고 간략한 자기 소개 및 지원 동기를 시작으로 기술 면접이 이어졌다.\nDatabase, FrontEnd, Network 외에도 객체 지향 프로그래밍, RESTful API, MVC 패턴 등과 같은 파트에서 질문이 나왔다.\nData Structure, OS, Algorithm 및 Language는 따로 준비하지 않아도 될 것 같지만, 이는 어디까지나 필자의 경험을 위주로 판단한 것이다.</p>\n<p>단순히 A는 무엇인가요? 라는 질문에서 그치지 않고, 왜? 라는 질문을 항상 하신다.\n그래서 필요한 개념들을 너무 얕게만 훑어보지 말고 조금 더 깊이 살펴볼 필요가 있다.</p>\n<p>받았던 질문은 다음과 같다.</p>\n<ul>\n<li>최근에 관심을 가지고 공부하는 IT 도메인이 있는가?</li>\n<li>인터프리터와 컴파일러의 차이점이 무엇인가?\n<ul>\n<li>언제 사용되는가?</li>\n<li>인터프리터와 컴파일러의 예시는 어떤게 있는가?</li>\n</ul>\n</li>\n<li>객체 지향 프로그램이 무엇인가?\n<ul>\n<li>객체가 무엇인가?</li>\n<li>OOP 프로그래밍의 어떤 특징때문에 많이 사용되고 있을까?</li>\n<li>상속이 무엇인가?</li>\n<li>Over-loading과 Overriding의 차이가 무엇인가?</li>\n</ul>\n</li>\n<li>FIFO와 LIFO에 대해 설명하라\n<ul>\n<li>FIFO와 LIFO의 예시는 무엇이 있는가?</li>\n<li>Queue와 Stack은 실제로 어떤 usecase에서 사용될 수 있는가?</li>\n</ul>\n</li>\n<li>REST(ful) API란 무엇인가?</li>\n<li>DB에서 SQL과 NoSQL DB를 설명하라\n<ul>\n<li>SQL DB와 NoSQL DB는 언제 사용하면 좋을까?</li>\n<li>SQL DB를 많이 사용하는 이유는 무엇일까?</li>\n</ul>\n</li>\n<li>DB에서 Index는 무엇인가?\n<ul>\n<li>Index를 왜 사용하는가?</li>\n</ul>\n</li>\n<li>OLTP(Online Transaction Process) / OLAP(Online Analytics Process)가 무엇인가?</li>\n<li>IP 주소가 무엇인가?</li>\n<li>MAC address는 무엇인가?</li>\n<li>OSI 7 계층이 무엇인가?\n<ul>\n<li>7 계층마다 사용될 수 있는 프로토콜 중 TCP/UDP의 차이점이 무엇이고, 어떻게 패킷을 전달하는지 설명하라</li>\n<li>3-way handshake은 무엇인가?</li>\n<li>동영상 스트림 같은 경우 어떤 프로토콜을 사용하는 것이 좋은가?</li>\n<li>Sniffing이나 Spoofing같은 중간자 공격을 TCP에서 해결할 수 있는 방법이 있는가?\n<ul>\n<li>추가적으로 session을 맺어진 시간을 조정을 할 수 있는가?</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTPs에 대해 설명하라\n<ul>\n<li>HTTPs에서 암호화가 어떻게 진행되는가?</li>\n</ul>\n</li>\n<li>L4 방화벽과 L3 방화벽의 동작 과정은 어떠한가?</li>\n<li>고가용성이 무엇인가?</li>\n<li>3-tier architecture에 대해 설명하라\n<ul>\n<li>3-tier로 나눈 이유를 설명하여라</li>\n<li>부하가 늘어났을 때, 부하를 처리할 수 있는 방법이 무엇이 있는가?</li>\n<li>load balancer는 3-tier architecture에서 어디에 놓아야 좋은가?</li>\n</ul>\n</li>\n<li>NAS/DAS/SAN에 대해 설명하라</li>\n<li>Storage에서 Storage를 효율적으로 활용하기 위해 사용하는 방법 / Disk를 나누는 방식</li>\n<li>내구성에 대해 설명하라</li>\n</ul>\n<p>이후, 간단한 Q&#x26;A 시간을 1~2분 정도 가졌다.</p>\n<h2 id=\"3-assignment-interview\" style=\"position:relative;\"><a href=\"#3-assignment-interview\" aria-label=\"3 assignment interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Assignment Interview</h2>\n<p>Phone Interview를 본지 단 3시간 만에 메일이 왔다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA00lEQVQY032QaQ6CQAyFuYkbikFwHEAkRlTUKJsog1v0/ud4po0YTYw/vnTatO91qk2dGeyuwFAfwWoP39i6gN0REF0JabgY9Rzuodo/tCRKMZEBQm8B3woYb+Bj0LJZmGING/0Q+VxEy1Z75OsC2zBGGmVIlhnyTcEGtJHoSd7ONcc8YDYsmM1vPo20u3rgsCuhkgqn/AKVnlBlZ1wPN65Vr7yMFZsu/AihO2dDgvL6XCx4jBWLlInioUtx45zqJEqRTkDNdEun70IaDr9r6m+T4BNDMqMWLnVZmQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AWS-interview-4.png\"\n        title=\"AWS-interview-4.png\"\n        src=\"/static/81cbaaa13715fa76b100c97ed42d4274/37523/AWS-interview-4.png\"\n        srcset=\"/static/81cbaaa13715fa76b100c97ed42d4274/e9ff0/AWS-interview-4.png 180w,\n/static/81cbaaa13715fa76b100c97ed42d4274/f21e7/AWS-interview-4.png 360w,\n/static/81cbaaa13715fa76b100c97ed42d4274/37523/AWS-interview-4.png 720w,\n/static/81cbaaa13715fa76b100c97ed42d4274/302a4/AWS-interview-4.png 1080w,\n/static/81cbaaa13715fa76b100c97ed42d4274/07a9c/AWS-interview-4.png 1440w,\n/static/81cbaaa13715fa76b100c97ed42d4274/e92cd/AWS-interview-4.png 1778w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"31-과제-작성-및-인터뷰-준비\" style=\"position:relative;\"><a href=\"#31-%EA%B3%BC%EC%A0%9C-%EC%9E%91%EC%84%B1-%EB%B0%8F-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84\" aria-label=\"31 과제 작성 및 인터뷰 준비 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1 과제 작성 및 인터뷰 준비</h3>\n<p>이번 과정은 과제를 기반으로 하는 인터뷰이기 때문에, 인터뷰 전에 과제를 작성하고 제출해야 한다.\n과제는 총 2가지인데, 첫 번째 과제는 Coordination 팀에서 보내주신 시나리오를 기반으로 <a href=\"https://docs.aws.amazon.com/wellarchitected/latest/framework/wellarchitected-framework.pdf\">AWS의 Well Architecture Framework</a>의 5 Pillars (운영 우수성, 보안, 안정성, 성능 효율성, 비용 최적화)를 cover할 수 있는 아키텍처를 직접 설계하고, 이를 설명하는 white paper 형태의 문서를 5페이지 내외로 작성해야 한다.\n두 번째 과제는 ‘Work Sample Discussion’으로, 현재 또는 이전에 중요한 역할을 수행한 프로젝트 중 하나를 선택하고 이에 대한 간략한 설명을 제공하는 1페이지 문서를 작성해야 한다.</p>\n<p>첫 번째 과제의 시나리오는 Common 시나리오와 Additional 시나리오로 나뉘어지는데, Common 시나리오의 경우는 필수로 만족해야하는 요구 사항들이며 Additional 시나리오는 선택 요구 사항이다.\n즉, Common 시나리오 + Additional 시나리오을 만족하는 아키텍처를 설계해야 한다.</p>\n<p>Additional 시나리오의 경우, 5가지 Technology Areas에 대해 8가지 시나리오가 주어졌다.\nTechnology Areas는 Infrastructure, Development/DevOps, Database &#x26; Analytics, Container, AI/ML로 구분되었는데, 필자의 경우 평소 MSA 아키텍처에 관심이 있었기 때문에 Dvelopment/DevOps를 선택했다.</p>\n<p>주어진 기간은 2주이며, 가상의 시나리오를 기반으로 한 이키텍처 제안 문서와 경험한 프로젝트에 대한 소개 문서, 이렇게 2가지를 제출해야 했다.</p>\n<p>해당 인터뷰 과정이 필자에겐 굉장히 힘들었는데, 그 이유는 AWS 서비스에 대한 친밀도였다.\nAWS 서비스를 이용해 본 경험이 한 번도 없었기 때문에, EC2라는 것이 무엇인지도 모르던 상태였고 설계를 위해서는 AWS 서비스부터 숙지해야했다.</p>\n<p>현재 AWS에는 약 200여개가 넘는 서비스들이 있기 때문에 이 점이 가장 막막했는데, 다행히 AWS에서는 기술 문서 및 기술 세션 영상들을 풍부하게 제공하고 있었다.</p>\n<p>그러나 필자가 느꼈던 문제는 오히려 너무 자료가 많아 어느 것부터 봐야할지를 모르겠다는 것이였다 😂.\n그래서 Assignment를 준비하며 가장 많은 도움이 된 자료들을 추려보았다.</p>\n<ul>\n<li>\n<p><a href=\"https://youtu.be/fhNpjPr-f54\">천만 사용자를 위한 AWS 클라우드 아키텍처 진화하기</a></p>\n<ul>\n<li>사실 필자는 여러 자료들을 이미 찾아본 뒤 이 영상을 발견하게 되었는데, 이 영상만큼 AWS 클라우드 아키텍쳐에 입문하기 좋은 자료를 없다고 생각한다.</li>\n</ul>\n<p>굉장히 Basic한 내용들을 다루고 있으며, 사용자의 수가 증가함에 따라 아키텍처에 어떤 기능이 보강되어야 하고, 이러한 기능들을 보강하기 위해서는 어떤 AWS 서비스를 사용해야하는지에 대해 이해할 수 있다.\n사실 링크된 영상 말고도 AWS에서는 매년 다양한 온라인 세미나를 통해 제공하는 동일한 주제의 영상이 존재할 것이다. 이러한 동영상들이 큰 맥락은 비슷하지만 완전히 똑같은 영상은 아니다.\n설명하는 SA 분들에 따라, 설명하는 세미나의 성격에 따라, 또는 설명되는 시기에 따라 조금씩 차이가 느껴졌기 때문에, 필자는 5년 전 영상부터 가장 최근의 영상까지 모두 챙겨 보며 서비스들을 익혔던 것 같다.</p>\n</li>\n<li>\n<p><a href=\"https://aws.amazon.com/architecture/\">AWS 아키텍처 센터</a></p>\n<ul>\n<li>AWS에서는 Well-Architected Framework에 따라 설계된 다양한 참조 아키텍처 다이어그램을 제공한다.</li>\n</ul>\n<p>링크된 사이트에서는 참조 아키텍처 다이어그램뿐만 아니라, 여러 가지 guidance, technical guide 및 white paper도 재공한다.\n특히, 과제 문서를 어떻게 작성해야 하는지에 대해 참고 자료가 많이 없어 막막했었는데 guidance와 technical guide, white paper를 보며 어느 정도 감을 잡을 수 있었던 것 같다.</p>\n<p>guidance 문서들의 경우 설계된 아키텍처가 5 Pillars를 어떻게 만족하는지 서술하는 방법에 대해서 많은 인사이트를 얻을 수 있었으며, technical guide와 white paper를 통해서는 AWS 서비스에 대해 깊이있게 이해하는데 많은 도움을 받았다.</p>\n<p>역시나 방대한 양의 자료 속에서 어떤 것들을 먼저 살펴봐야할지 감이 오지 않을 수도 있다.\n필자가 추천하는 바는 <a href=\"https://d1.awsstatic.com/architecture-diagrams/ArchitectureDiagrams/web-application-architecture-on-aws-ra.pdf?did=wp_card&#x26;trk=wp_card\">Web Application Architecture on AWS</a>를 먼저 공부하는 것이다.\n나 역시 해당 아키텍처를 가장 먼저 공부했으며 해당 아키텍처 및 서비스들에 대해 완전히 이해하고 난 뒤에, 해당 아키텍처를 기반으로 구성 요소들을 재배치하거나 대체 및 추가하며 주어진 시나리오에 맞는 나만의 아키텍처를 설계해갔다.</p>\n</li>\n<li>\n<p><a href=\"https://www.youtube.com/@AWSClassroom\">AWS 강의실</a></p>\n<ul>\n<li>아키텍처를 설계하다보면 서비스 하나, 하나에 대해 조금 더 깊이 개념을 공부해야할 필요가 생기게 된다. AWS에서 제공하는 다양한 기술 백서를 통해서 서비스들을 살펴보는 것이 가장 좋겠지만, 필자와 같이 AWS 서비스를 처음으로 접해봤기 떄문에 과제를 준비하는데 시간이 촉박한 분들의 경우 AWS 강의실 유투브를 강력 추천한다. 각 서비스들에 대해 필요한 개념들을 아주 잘 정리해두었으며, 다양한 서비스들에 대한 체계적으로 제공해준다.</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://youtu.be/vCNexbgYmQ8\">AWS를 사용한다면 반드시 알아야 할 네트워크 기초 지식</a></p>\n<ul>\n<li>지원하는 직무에 따라 과제의 세부 조건들이 다르기 때문에 아키텍처를 설계하는데 필요한 서비스들이 다를 것이다. 그러나 공통으로 알아야할 필수 항목은 네트워크 설계라고 생각한다. 이 부분에 대해서도 AWS에서 상당히 자세한 자료를 제공하고 있다. 항상 최신 자료를 찾아보고 업데이트 사항이 없는지도 확인하는 것이 중요하다.</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.youtube.com/playlist?list=PLORxAVAC5fUU79iWsEeAaG8FN6WyXipZO\">This is my architecture - 한국 고객 사례</a></p>\n<ul>\n<li>Assignment Interview의 경우, ‘This is my architecture’ 동영상과 같이 진행되게 된다. AWS에서는 This is my architecture 동영상을 다수 제공하는데, 인터뷰 전에 해당 동영상을 보면서 아키텍처를 어떻게 설명할 것인지에 대해 숙지해두면 좋을 것 같다.</li>\n</ul>\n</li>\n</ul>\n<p>필자는 첫 번째 과제에 대해 6페이지의 문서를 영어로 작성하여 제출하였다.</p>\n<p>문서의 구성은 다음과 같이 작성하였다:</p>\n<ul>\n<li>Brief: 전체 문서에 대한 간략한 개요를 제공하였다.</li>\n<li>Assumptions: 제공된 Requirement에는 나와있지 않았던 추가 가정들에 대해 나열하였다.</li>\n<li>Requirement Analysis: 제공된 common requirement와 of additional suggestions를 분석한 내용을 간략히 나열하였다.</li>\n<li>Proposed Architecture: 제공된 조건들을 만족하는 아키텍처 대한 그림과 함께, 설명을 제공했다. 이 때, 설명은 Requirement Analysis를 기반으로 아키텍처에 대한 설몀을 제공하였다. 설명에서 서비스에 대한 추가 설명들은 AWS에서 제공하는 기술문서를 하이퍼링크로 삽입하였다.</li>\n<li>Conclusion: 문서에 대한 결론을 제공하였다.</li>\n</ul>\n<p>두 번째 과제에 대해서는 1페이지의 문서를 한글로 작성하여 제출하였다.\n문서의 내용이 길지 않았기 때문에 프로젝트에 대한 개요를 먼저 요약하여 제공하였다. 이후 프로젝트의 세부 사항들을 기술하였다.</p>\n<h3 id=\"32-인터뷰-내용\" style=\"position:relative;\"><a href=\"#32-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%82%B4%EC%9A%A9\" aria-label=\"32 인터뷰 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 인터뷰 내용</h3>\n<p>과제를 제출하고, 바로 다음날 White Boarding Session에 대한 안내 메일이 왔다.</p>\n<p>총 1시간에서 1시간 20분 정도 진행된다고 안내 받았으며, 첫 번째 과제(architecture 설계)에 4-50분, 두 번째 과제(project description)에 20분 정도 할애한다고 안내받았다.</p>\n<p>인터뷰 스케줄링은 역시 최대한 많은 배려를 해주셨다.\n원래라면 2주 이내에 인터뷰 날짜를 정해야하지만 연휴가 중간에 끼여있는 나머지, 다른 인터뷰어분들의 휴가 날짜와 겹쳐서 2주보다 더 뒤에 인터뷰 날짜를 잡아주셨다.</p>\n<p>인터뷰어들은 가상의 고객의 입장에서 참여하게 되고,\n인터뷰동안 고객에게 기술적인 해결책을 제안해준다는 생각으로 설명을 진행해야 한다.</p>\n<p>Bluescape 라는 원격 Whiteboarding 툴을 활용해서 인터뷰를 진행했다.</p>\n<p>총 2분의 인터뷰어 분들이 참여하셨고, Bluescape에 미리 제출된 architecture 그림을 준비해주신다.</p>\n<p>인터뷰가 시작되면, 인터뷰어 분들의 간략한 소개 후 바로 Architecture에 대한 설명을 해야한다.</p>\n<p>전체적인 설명을 5분여 정도동안 진행을 했는데,\n고객의 요구 사항과 이에 따른 architecture 설명이 이어질 수 있도록 준비를 했더라면 더 좋았을 것 같다는 아쉬움이 있다.</p>\n<p>전체적인 아키텍처에 대한 설명 이후에는 각 인터뷰어 분들이 아키텍처에 대한 세부 사항들을 질문한다.\n필자가 받았던 질문들 중 기억이 나는 질문들은 다음과 같다.</p>\n<ul>\n<li>NAT Gateway의 역할이 무엇인가?</li>\n<li>NAT Gateway는 어떻게 동작하는가?</li>\n<li>Internet Gateway를 사용한 이유는 무엇인가?</li>\n<li>VPC의 Subnetting은 어떻게 했는가?</li>\n<li>Cognito가 어떤 서비스인가? Cognito를 굳이 사용한 이유가 무엇인가?</li>\n<li>Data layer에서 ElastiCache와 Aurora를 사용했는데, 데이터 캐싱이 어떻게 이루어지는가?</li>\n</ul>\n<p>제대로 대답을 한 질문도 있고, 못한 질문도 있었는데\n아쉬움이 있다면, 아키텍처를 설계하고 직접 AWS console에서 시스템을 구성해봤으면 더 디테일한 부분까지 대답할 수 있었지 않았을까 하는 것이었다.</p>\n<p>이후로는 두 번째 과제(프로젝트 설명)에 대한 인터뷰가 짧게 이어졌다.\n먼저, 프로젝트에 대한 개요를 간략하게 설명해야 했다.\n이후에 인터뷰어분들께서 이 프로젝트에 대한 질문을 해주셨다.</p>\n<p>질문은 주로 다음과 같은 것들이었다.</p>\n<ul>\n<li>이 프로젝트가 실무/실제 환경에서 어떤 기여를 할 수 있는가?</li>\n<li>이 프로젝트에서 어떤 기여를 하였는가?</li>\n</ul>\n<p>이 외에는 프로젝트 내용에 대한 추가 질문이었다.</p>\n<h2 id=\"4-loop-interview\" style=\"position:relative;\"><a href=\"#4-loop-interview\" aria-label=\"4 loop interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Loop Interview</h2>\n<p>사실 이전 인터뷰에서 대답을 못한 것들도 많고, 인터뷰가 끝나고 여러 가지 아쉬움이 많이 남았기 때문에 최종 인터뷰까지는 합격할 수 있을지가 불확실했다.\n그러나 놀랍게도 바로 다음날 채용 담당자분께서 2차 인터뷰 합격 소식을 전해주셨다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC8klEQVQ4y32S7W/bVBSH+88hIdBAQiDxBU39wkAUId467ctQAa2sAonBQFtXEEId2wfoNAZ76daVDiZRQGTspVlTx4kdN4ntayd+iZ3EcR50b5plk6Zd6/E5Pr735/s7vlMMMvptj77dYFC36Ok66b/bpFe2sE8XuPPFJmsf/s7p96+z8OYqszOXeeuNi7z6+gX2z/zMzNw1njmwzKdLa8gxJW/anVv8celXbq+vce3sWf4+c55bJy6w+sEyP72zzJf7T/Dxy6c4sO8YL+37nGefnue5FxZ5cfpHDh7+nuenF/jo+KU9wXzAMA7JfZfcbtA3Dfp3dfobGv5KkdI3/3Hzs79YmbvJ8UMbzB28zqHZq7w7e5XX3rvIK2+v8NT0El8v3xgJ9no9wiAgCgOSOFZF8hyynGFvwKA7IEsH9JKMbpKR7NHp9IklSUYY90i7/ZFgJ0lwHAfheURRTBzHBGFIFEcMhrmaNBwOGV8oHj/kvKk0TfA9l5YvaPkeUdgmCFq0W55C1pJOTL/XpZt2GGT9Jwv6rZDb9zTuFnXF1naV4o7JVslga9vg3v0KO/outbqPLSKabkRTTJC1hhMSROnI8n3d4duVf/juXIGvfviTTxY3WFi6wdGlUZTML65z5OQ68ycncZwfPfUbh4+t8st6cXJssqxHabvIrlVT9l3HxhOusut7gqDtP7F3j1iWifwRm5ubFAoFNK1MtVrFsiwM08Q0TQzDVDVXCJIkpdvtKpIkUTFNu+R5PtlhmqaUy2U0TcMwDKIoUjW5QMYgCGi32w8Yi3U6HRUlcncPWc7U0bFtW8UwDBVRHOP7LSUiF8sPSTfqXRSNjtNDKMFxImOz2aRUKlGpVBS1moll1TCMKjVp3zBU7gmBEEJFhexzEEwEx6Ku44z6V6sp65WqQVmvKvSKgaZX2dF0HMfFcQWO8HH3eKSH8kEW6w0ba7eBtVunZtWxHYHwfITwlIAQPrbj0pStcQVN26HRsGkH4QPL/wPY0j0rqPJi6wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"AWS-interview-5.png\"\n        title=\"AWS-interview-5.png\"\n        src=\"/static/7f98ca27d144b150c373a71b846b7fe6/37523/AWS-interview-5.png\"\n        srcset=\"/static/7f98ca27d144b150c373a71b846b7fe6/e9ff0/AWS-interview-5.png 180w,\n/static/7f98ca27d144b150c373a71b846b7fe6/f21e7/AWS-interview-5.png 360w,\n/static/7f98ca27d144b150c373a71b846b7fe6/37523/AWS-interview-5.png 720w,\n/static/7f98ca27d144b150c373a71b846b7fe6/302a4/AWS-interview-5.png 1080w,\n/static/7f98ca27d144b150c373a71b846b7fe6/07a9c/AWS-interview-5.png 1440w,\n/static/7f98ca27d144b150c373a71b846b7fe6/c655d/AWS-interview-5.png 1586w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>따라서 바로 최종 인터뷰를 준비해햐 했는데,\n사실 아마존의 최종 인터뷰가 알고보니 굉장이 악명이 높았다.</p>\n<p>필자의 경우도 4분의 아마조니언분들과 1시간씩 1:1로 총 4시간을 인터뷰해야 했다.</p>\n<p>면접 날짜도 2주 내로 회신드려야했지만,\n필자의 경우 해외 학회 참석 일정때문에 2주 이후로 일정이 잡혔다.</p>\n<p>이 부분에서도 채용 담당자분께서 배려를 정말 많이 해주셨다.</p>\n<h3 id=\"41-인터뷰-준비\" style=\"position:relative;\"><a href=\"#41-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84\" aria-label=\"41 인터뷰 준비 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1 인터뷰 준비</h3>\n<p>Loop 인터뷰는 아마존의 <a href=\"https://www.amazon.jobs/content/en/our-workplace/leadership-principles\">Leadership Principles</a>에 기반해서 Behavior Question에 경험 및 사례로 답하는 과정이다.</p>\n<p>해당 인터뷰를 준비하기 위해서는 <a href=\"https://www.amazon.jobs/en/landing_pages/in-person-interview\">AWS Interview</a>에 안내되어 있는 것처럼 STAR format을 따르는 답변들을 준비해야한다.</p>\n<p>인터뷰어가 묻는 질문들에 대해</p>\n<blockquote>\n<p>Situation - Task - Action - Result</p>\n</blockquote>\n<p>순으로 대답해야 한다.</p>\n<p>Leadership Principle 1개당 3-4개의 시나리오를 준비하라고들 말하는데\n필자의 경우, 그동안 있었던 모든 프로젝트나 경험들을 잘 정리해서 Leadership Principle 1개당 4-5개의 시나리오들을 준비했다.</p>\n<p>사실, 모든 직무에서 14개의 Leadership Principle이 필요하지는 않다.\n따라서 지원한 직무에 해당하는 Leadership Principle을 추리고, 해당 원칙에 어떤 질문들이 있는지 찾아본 뒤 해당 질문에 답할 수 있는 여러 시나리오를 준비해놓아야한다.</p>\n<p>어떤 직무이던간에 가장 중요하게 생각해야 할 리더십 원칙은 Customer Obesession이다.\n이 원칙의 경우, 이 원칙에만 해당하는 시나리오를 준비하는 것 이외에 모든 원칙의 시나리오 조금씩 묻어나올 수 있도록 준비하면 더 좋을 것 같다는 생각이 들었다.</p>\n<p>실제 인터뷰 과정에서도 인터뷰어분이 이 부분을 굉장이 중요하게 생각하지는 것 같았다.</p>\n<p>사실 인터뷰를 준비하다보면, 각 원칙에 해댱하는 질문들이 뭔지 알아햐한다.\n필자의 경우, 다음 사이트에서 굉장히 많은 도움을 얻었다.</p>\n<ul>\n<li><a href=\"https://www.interviewgenie.com/blog?category=Amazon%20interviews\">interview genie - amazon interview</a></li>\n<li><a href=\"https://www.levels.fyi/blog/amazon-leadership-principles.html\">Amazon Leadership Principle: Questions and Interview Tips</a></li>\n</ul>\n<p>이 사이트에 나와있는 예상 질문들을 추리고, 해당 질문들에 대한 답변만 잘 정리해도 인터뷰를 잘 준비할 수 있을 것이다.</p>\n<p>참고로 시나리오 하나당 답변의 길이는 너무 길지 않게 1-2분 사이로 준비하는 것이 좋을 것 같다.\n처음에 너무 길게 답변했다가 인터뷰어 분께서 조금 더 짧게 얘기하면 좋을 것 같다고 지적해주셨다 😂.</p>\n<p>핵심만 간략하게 STAR 형식으로 전달한 뒤, 그 뒤로 이어지는 추가 질문들에서 더 자세한 내용들을 설명하면 될 것 같다.</p>\n<h3 id=\"42-인터뷰-내용\" style=\"position:relative;\"><a href=\"#42-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%82%B4%EC%9A%A9\" aria-label=\"42 인터뷰 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2 인터뷰 내용</h3>\n<p>인터뷰는 정확히 1시간동안 이어졌고, 모든 인터뷰에서의 공통점은 바로 자기소개로 시작한다는 점과 마지막에 질문할 시간을 5분 정도 (길게는 20분정도 남겨주신 인터뷰어분도 계셨다) 남겨주신다.</p>\n<p>따라서 자기 소개와 함께 질문거리들을 8개 이상(한 분당 2개 정도) 준비하면 좋을 것 같다.</p>\n<p>총 4분과의 인터뷰가 이어졌고, 필자의 경우 다음과 같은 질문들을 받았다.</p>\n<ul>\n<li>회사에서 직무 경험이 있거나, 인턴 경험이 있었는지?</li>\n<li>가장 기억에 남는 실패/실수/잘못을 한 경험이 있는지? 잘못된 판단으로 인해서 큰 실패로 이어졌던 경험, 그리고 그것으로 인해 어떤 것을 배울 수 있었는지?</li>\n</ul>\n<h2 id=\"5-끝으로\" style=\"position:relative;\"><a href=\"#5-%EB%81%9D%EC%9C%BC%EB%A1%9C\" aria-label=\"5 끝으로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 끝으로</h2>\n<p>최종 Loop Interview를 끝내고 채용 담당자님께서 전화로 결과를 통보해주셨다.</p>\n<p>결과는 최종 탈락이었지만,\n채용 담당자님께서 Loop Interview에 참여했던 Interviewer분들의 의견을 종합해서 전달해주셨고</p>\n<p>인터뷰 과정 중 어떠한 점 때문에 최종 탈락을 통보받게 되었는지,</p>\n<p>한 달여 간 진행되었던 채용 과정 속에서</p>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#0-aws%EC%9D%98-%EC%B1%84%EC%9A%A9-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\">0. AWS의 채용 프로세스</a></p>\n</li>\n<li>\n<p><a href=\"#1-job-application\">1. Job Application</a></p>\n</li>\n<li>\n<p><a href=\"#2-phone-interview\">2. Phone Interview</a></p>\n</li>\n<li>\n<p><a href=\"#3-assignment-interview\">3. Assignment Interview</a></p>\n<ul>\n<li><a href=\"#31-%EA%B3%BC%EC%A0%9C-%EC%9E%91%EC%84%B1-%EB%B0%8F-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84\">3.1 과제 작성 및 인터뷰 준비</a></li>\n<li><a href=\"#32-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%82%B4%EC%9A%A9\">3.2 인터뷰 내용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-loop-interview\">4. Loop Interview</a></p>\n<ul>\n<li><a href=\"#41-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A4%80%EB%B9%84\">4.1 인터뷰 준비</a></li>\n<li><a href=\"#42-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%82%B4%EC%9A%A9\">4.2 인터뷰 내용</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#5-%EB%81%9D%EC%9C%BC%EB%A1%9C\">5. 끝으로</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 13, 2022","title":"AWS Korea Interview - Associate Solutions Architect","categories":"Interview","author":"Mini","emoji":"💼"},"fields":{"slug":"/Interview/AWS-interview/"}},"prev":{"id":"0de738e2-7ce9-5de4-a3d4-53c76eb7ebec","html":"<h2 id=\"tldr\" style=\"position:relative;\"><a href=\"#tldr\" aria-label=\"tldr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TL;DR</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">xcode-select --installs</code></pre></div>\n<h2 id=\"problem\" style=\"position:relative;\"><a href=\"#problem\" aria-label=\"problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Problem</h2>\n<p>Mac OS를 업데이트 후, 평소와 같이 TIL Git Blog를 적다가 commit하려고 했더니 다음과 같은 error가 발생함.</p>\n<p>error log는 다음과 같음.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">sominsong.github.io % <span class=\"token function\">git</span> status \nxcrun: error: invalid active developer path <span class=\"token punctuation\">(</span>/Library/Developer/CommandLineTools<span class=\"token punctuation\">)</span>, missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</code></pre></div>\n<p>원인은 MacOS Update 이후에 CommandLineTools를 식별하기 못하여 발생함</p>\n<h2 id=\"solution\" style=\"position:relative;\"><a href=\"#solution\" aria-label=\"solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution</h2>\n<p><code class=\"language-text\">xcode-select</code> command로 CommandLineTools(command line developer tools)를 설치하면 문제 해결</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">xcode-select --install</code></pre></div>\n<p>완료 시, 다음과 같이 성공적으로 작동</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">sominsong.github.io % <span class=\"token function\">git</span> status\nOn branch gh-pages\nChanges not staged <span class=\"token keyword\">for</span> commit:\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git add &lt;file>...\"</span> to update what will be committed<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git restore &lt;file>...\"</span> to discard changes <span class=\"token keyword\">in</span> working directory<span class=\"token punctuation\">)</span>\n\tmodified:   content/LSM/index.md\n\nUntracked files:\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git add &lt;file>...\"</span> to include <span class=\"token keyword\">in</span> what will be committed<span class=\"token punctuation\">)</span>\n\tcontent/LSM/LSM-2.jpeg\n\tcontent/LSM/LSM-3.png\n\tcontent/Security_3/\n\tcontent/xcrun_error/\n\nno changes added to commit <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git add\"</span> and/or <span class=\"token string\">\"git commit -a\"</span><span class=\"token punctuation\">)</span>\nsominsong.github.io<span class=\"token punctuation\">[</span>gh-pages*<span class=\"token punctuation\">]</span> % \n</code></pre></div>","frontmatter":{"date":"October 25, 2022","title":"Error - Mac 업그레이드 후 xcrun error 해결","categories":"Error Mac","author":"Mini","emoji":"📖"},"fields":{"slug":"/Error/xcrun_error/"}},"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/TIL/eBPF/","nextSlug":"/Interview/AWS-interview/","prevSlug":"/Error/xcrun_error/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}