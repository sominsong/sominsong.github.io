{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/BCC/",
    "result": {"data":{"cur":{"id":"0489ec5c-997d-5236-8341-bff4776f9677","html":"<p><a href=\"https://github.com/iovisor/bcc\">BCC</a>는 커널 tracing이나 manipulation 프로그램을 만들기 위한 유용한 toolkit을 제공하는 오픈 소스이다.</p>\n<p>맨처음 eBPF 프로그램을 작성하기 시작한다면, 어려워하는 부분이 바로 eBPF 프로그램을 컴파일하고 커널 소스코드에서 eBPF 라이브러리를 연결하는 부분일 것이다.\n이러한 부분을 해결해주기 위해 등장한 Toolkit이 BCC라고 보면 된다.</p>\n<p>즉, BCC는 eBPF 프로그램 작성, 컴파일 및 로드를 위한 Toolchain을 제공하고, 뿐만 아니라 performance issue 디버깅 및 진단을 위한 여러 가지 예제 프로그램과 도구도 제공한다.</p>\n<p>2015년 4월 출시 이후 많은 개발자에 의해 BCC가 발전했으며, 수많은 <a href=\"https://github.com/iovisor/bcc/tree/master/examples\">예제 코드</a>와 함께 즉시 사용 가능한 <a href=\"https://github.com/iovisor/bcc/tree/master/tools\">tracing tool</a>이 제작되었다.</p>\n<p>예를 들어, <a href=\"https://github.com/iovisor/bcc/blob/master/tools/lib/ugc.py\">garbage collection 이벤트 추적</a>, <a href=\"https://github.com/iovisor/bcc/blob/master/tools/lib/ucalls.py\">method call과 system call 추적</a>, <a href=\"https://github.com/iovisor/bcc/blob/master/tools/lib/uthreads.py\">스레드 생성 및 소멸 추적</a>을 위해 작성된 USDT(User Statically-Defined Tracing) probes를 사용하는 스크립트 등이 있다.\n이러한 probe는 이름에서도 알 수 있듯이, 컴파일 타임에 정적으로 사용자의 application에 삽입된다.</p>\n<p>BCC는  eBPF 프로그램 작성을 위해 기존에 LLVM/Clang 컴파일러에서 제공하는 C언어뿐만 아니라 파이썬, Go, Lua 언어를 위한 front-end를 지원한다.</p>\n<p>예를 들어, 다음 코드는 파이썬으로 작성되었으며, <code class=\"language-text\">clone()</code> 시스템콜 이벤트가 발생한 경우 <code class=\"language-text\">kprobe__sys_clone()</code> 함수를 수행하고 <code class=\"language-text\">Hello World</code>를 화면에 출력하는 예시이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> bcc <span class=\"token keyword\">import</span> BPF\nprogram <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">\"\"\"\n        int kprobe__sys_clone(void *ctx){\n            bpf_trace_printk(\"Hello World\");\n            return 0;\n        }\n\"\"\"</span>\nb <span class=\"token operator\">=</span> BPF<span class=\"token punctuation\">(</span>text<span class=\"token operator\">=</span>program<span class=\"token punctuation\">)</span>\nb<span class=\"token punctuation\">.</span>attach_kprobe<span class=\"token punctuation\">(</span>event<span class=\"token operator\">=</span><span class=\"token string\">\"sys_clone\"</span><span class=\"token punctuation\">,</span> fn_name<span class=\"token operator\">=</span><span class=\"token string\">\"kprobe__sys_clone\"</span><span class=\"token punctuation\">)</span>\nb<span class=\"token punctuation\">.</span>trace_print<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>전체 eBPF 프로그램이 <code class=\"language-text\">program</code> 변수에 포함되며, 이 변수는 커널 내부의 eBPF VM애서 실행되는 코드이다.</p>\n<p>함수 이름인 <code class=\"language-text\">kprobe__sys_clone()</code>의 형식은 중요하다.\n<code class=\"language-text\">kprobe__</code> 접두사는 BCC toolchain에 kprobe에 뒤따르는 커널 심볼들을 attach하도록 지시하기 때문이다.\n이 경우, 뒤따르는 커널 심볼은 <code class=\"language-text\">sys_clone()</code>이다.</p>\n<p><code class=\"language-text\">sys_clone()</code>이 호출되고 <code class=\"language-text\">kprobe</code>가 실행되면, eBPF 프로그램이 동작하고 <code class=\"language-text\">bpf_trace_printk()</code> 함수가 <code class=\"language-text\">Hello, World!</code>를 커널의 trace buffer로 출력한다.</p>\n<p>BCC는 front-end를 통해 파이썬을 바인딩하고, BPF back-end가 있는 LLVM/Clang 컴파일러를 호출하여 C를 eBPF 바이트코드로 변환한다.\n그런 다음, BCC는 <code class=\"language-text\">bpf()</code> 시스템콜을 사용하여 eBPF 바이트 코드를 커널에 로드하는 작업을 처리한다.</p>\n<p>예를 들어, in-kernel verifier의 검사가 실패한 경우와 같이 로드가 실패하면 BCC는 로드가 실패한 이유에 대한 힌트를 다음과 같이 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HINT: The `map_value_or_null` error can happen if you dereference a pointer value from a map loopup without first checking if that pointer is NULL</code></pre></div>\n<p>이러한 에러 로그도 BCC를 구성하는 또 다른 주요한 기능히다.\n올바른 eBPF 프로그램을 작성하는 것은 매우 까다로운 작업이기 때문에, BCC가 이를 도울 수 있다.</p>\n<p><code class=\"language-text\">BPF.trace_print()</code>는 커널의 trace 버퍼 파일(<code class=\"language-text\">/sys/kernel/debug/tracing/trace_pipe</code>)에 blocking read를 수행하여 버퍼 파일의 내용을 standard output으로 프린트한다.\n출력은 다음과 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    gnome-terminal--3210  [003] d..2 19252.369014: 0x00000001: Hello, World!\n    gnome-terminal--3210  [003] d..2 19252.369080: 0x00000001: Hello, World!\n    pool-21543 [001] d..2 19252.382317: 0x00000001: Hello, World!\n    bash-21545 [002] d..2 19252.385535: 0x00000001: Hello, World!\n    bash-21546 [003] d..2 19252.385752: 0x00000001: Hello, World!\n    bash-21545 [002] d..2 19252.386883: 0x00000001: Hello, World!</code></pre></div>\n<p>출력은 다음을 포함한다:</p>\n<ul>\n<li>kprobe를 트리거한 application 이름</li>\n<li>application의 PID</li>\n<li>실행 중인 CPU ([괄호] 안)</li>\n<li>다양한 프로세스의 context</li>\n<li>타임스탬프</li>\n<li>주소 0x00000001: 일반적으로 커널 코드가 trace 버퍼에 기록할 때 <code class=\"language-text\">trace_printk()</code> 호출 뒤에 instruction pointer address가 해당 필드에 프린트된다. 그러나 이 함수는 <code class=\"language-text\">bpf_trace_prink()</code>에 대해 구현되어 있지 않으므로 하드 코딩된 주소값인 <code class=\"language-text\">0x00000001</code>이 항상 사용된다.</li>\n<li><code class=\"language-text\">bpf_trace_printk()</code>에 전달한 “Hello, World” 문자열</li>\n</ul>\n<p>이렇게 <code class=\"language-text\">bpr_trace_prink()</code>를 이용하여 런타임 디버깅을 할 수 있지만, <code class=\"language-text\">trace_pipe</code> 파일이 전역 리소스이기 때문에 concurrent writer가 작성한 모든 메세지를 포함하므로, 단일 BPF 프로그램의 메세지를 필터링하기 어렵다는 단점이 존재한다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://lwn.net/Articles/742082/\">https://lwn.net/Articles/742082/</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","excerpt":"BCC는 커널 tracing이나 manipulation 프로그램을 만들기 위한 유용한 toolkit을 제공하는 오픈 소스이다. 맨처음 eBPF 프로그램을 작성하기 시작한다면, 어려워하는 부분이 바로 eBPF 프로그램을 컴파일하고 커널 소스코드에서 eBPF 라이브러리를 연결하는 부분일 것이다.\n이러한 부분을 해결해주기 위해 등장한 Toolkit이 BCC라고 보면 된다. 즉, BCC는 eBPF 프로그램 작성, 컴파일 및 로드를 위한 Toolchain을 제공하고, 뿐만 아니라 performance issue 디버깅 및 진단을 위한 여러 가지 예제 프로그램과 도구도 제공한다. 2015년 4월 출시 이후 많은 개발자에 의해 BCC가 발전했으며, 수많은 예제 코드와 함께 즉시 사용 가능한 tracing tool이 제작되었다. 예를 들어, garbage collection 이벤트 추적, method call과 system call 추적, 스레드 생성 및 소멸 추적을 위해 작성된 USDT(Use…","frontmatter":{"date":"October 27, 2022","title":"TIL - BCC (eBPF Compiler Collection)","categories":"TIL Linux","author":"Mini","emoji":"📖"},"fields":{"slug":"/BCC/"}},"next":{"id":"e7d13b49-1ca9-56fc-8ac1-8202fedc922b","html":"<h2 id=\"정보-보안의-3요소\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%B3%B4-%EB%B3%B4%EC%95%88%EC%9D%98-3%EC%9A%94%EC%86%8C\" aria-label=\"정보 보안의 3요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정보 보안의 3요소</h2>\n<ul>\n<li>\n<p>Confidentiality(기밀성): asset이 authorization(인가)된 user에 의해서만 접근하는 것을 보장하는 것 (e.g., 비밀 일기)</p>\n<ul>\n<li>일기장을 남이 훔쳐보기 못하도록 지키는 것 = 기밀성을 지키는 것. 남이 훔쳐보더라도 무슨 말인지 못알아보게 적는 것 = 기밀성을 지키기 위해 암호화하는 것.</li>\n<li>Threat list: 도청, 도난, 사회공학 (shouler surfing) 등</li>\n</ul>\n</li>\n<li>\n<p>Integrity(무결성): asset이 authorization된 user에 의해서, authorization된 방법으로만 변경 가능한 것</p>\n<ul>\n<li>일기가 다른 사람에 의해 일부 수정된다 = 무결성이 꺠진 것. 무결성 검증을 위해서는 Hash 값을 비교함.</li>\n<li>Threat list: 트로이 목마, 바이러스</li>\n</ul>\n</li>\n<li>\n<p>Availability(가용성): asset이 적절한 시간에 authorization된 user가 접근할 수 있는 것</p>\n<ul>\n<li>DB를 Active/Standby로 구성하는 것</li>\n<li>Threat list: Dos/DDoS 공격</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"October 26, 2022","title":"TIL - 정보 보안의 3요소","categories":"TIL Security","author":"Mini","emoji":"📖"},"fields":{"slug":"/Security_3/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/BCC/","nextSlug":"/Security_3/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}