{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Algorithm/Shortest_Path/",
    "result": {"data":{"cur":{"id":"8c9766f2-c436-516c-87d7-6ca50cda89e9","html":"<ul>\n<li>가장 짧은 경로를 찾는 알고리즘</li>\n<li>최단 경로 알고리즘이 사용될 수 있는 다양한 문제 상황\n<ul>\n<li>한 지점에서 다른 한 지점까지의 최단 경로</li>\n<li>한 지점에서 다른 모든 지점까지의 최단 경로</li>\n<li>모든 지점에서 다른 모든 지점까지의 최단 경로</li>\n</ul>\n</li>\n<li>Dynamic Programming 문제로 분류되기도 함</li>\n</ul>\n<h2 id=\"1-dijkstra-shortest-path-알고리즘\" style=\"position:relative;\"><a href=\"#1-dijkstra-shortest-path-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"1 dijkstra shortest path 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Dijkstra Shortest Path 알고리즘</h2>\n<ul>\n<li><strong>특정한 한 노드</strong>에서 출발하여 <strong>다른 모든 노드</strong>로 가는 최단 경로 계산</li>\n<li>조건: <strong>음수 Edge가 없을 때</strong> (현실 세계의 도로)</li>\n<li>Greedy 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 Node를 선택</li>\n</ul>\n<blockquote>\n<p>💡 알고리즘 동작 과정</p>\n<ol>\n<li>출발 노드 설정</li>\n<li>최단 거리 테이블 초기화 (모든 노드까지의 거리 무한으로 설정 &#x26; 자기 자신까지의 거리는 0으로 설정)\n<ul>\n<li>최단 거리 테이블: 각 노드에 대한 현재끼ㅏ지의 최단 거리 정보 저장</li>\n</ul>\n</li>\n<li>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택</li>\n<li>해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신</li>\n<li>위 과정에서 3번과 4번을 반복</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p>Dijkstra 알고리즘 특징</p>\n<ul>\n<li>Greedy 알고리즘: 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정 반복</li>\n</ul>\n</li>\n<li>\n<p>단계를 거치며 <strong>한 번 처리된 노드의 최단 거리는 고정</strong>되어 더 이상 바뀌지 않음</p>\n<ul>\n<li>한 단계당 하나의 노드에 대한 최단 거리를 확실하게 찾음</li>\n</ul>\n</li>\n<li>\n<p>알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 <strong>거리</strong> 정보만 저장됨</p>\n<ul>\n<li>완벽한 형태의 최단 <strong>경로</strong>를 구하려면 소스코드에 추가적인 기능을 더 넣어야 함</li>\n</ul>\n</li>\n<li>\n<p>간단한 구현 방법</p>\n<ul>\n<li>단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 <strong>매 단계마다 1차원 테이블의 모든 원소를 확인(순차 탐색)</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력 받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 방문한 적이 있는지 체크하는 목적의 리스트</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_smallest_node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    min_value <span class=\"token operator\">=</span> INF\n    index <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token comment\"># 가장 최단 거리가 짧은 노드(인덱스)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min_value <span class=\"token keyword\">and</span> <span class=\"token keyword\">not</span> visited<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            min_value <span class=\"token operator\">=</span> distnace<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            index <span class=\"token operator\">=</span> i\n    <span class=\"token keyword\">return</span> index\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    visited<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    <span class=\"token comment\"># 시작 노드와 연결된 노드까지의 거리</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드를 제외한 전체 n-1개의 노드에 대해 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리</span>\n        now <span class=\"token operator\">=</span> get_smallest_node<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        visited<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 노드 확인</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐 해당 노드로 갈 때의 거리</span>\n            cost <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> j<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서 해당 노드로 이동하는 거리가 더 짧은 경우 최단 거리 테이블 update</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n\n<span class=\"token comment\"># 다익스트라 알고리즘 수행</span>\ndikstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한(INFINITY)라고 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도달할 수 있는 경우 거리 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distnace<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>‘간단한 구현 방법’ 성능 분석</p>\n<ul>\n<li>전체 시간 복잡도: <strong>O(V^2)</strong>\n<ul>\n<li>총 O(V)번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색</li>\n</ul>\n</li>\n<li>전체 노드의 개수가 5,000개 이하일 경우 가능 BUT <strong>만 개를 넘어간다면 불가능</strong></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 우선순위 큐 (Priority Queue)\n: 우선 순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조\ne.g., 여러 개의 물건 데이터를 자료 구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서 확인해야 하는 경우</p>\n<ul>\n<li>Heap: Priority Queue를 구현하기 위해 사용하는 자료구조\n<ul>\n<li>Min Heap &#x26; Max Heap 존재</li>\n</ul>\n</li>\n<li>시간 복잡도: O(NlogN) (merge sort, quick sort와 동일)</li>\n</ul>\n</blockquote>\n<p><a href=\"https://sominsong.github.io/Data_Structure/#1-priority-queue-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90--heap-%ED%9E%99\">Priority 정리 참고</a></p>\n<ul>\n<li>\n<p>개선된 구현 방법</p>\n<ul>\n<li>단계마다 <strong>방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택</strong>하기 위해 <strong>Heap</strong> 자료구조 이용</li>\n<li>알고리즘이 동작하는 기본 원리는 동일</li>\n<li>현재 가장 가까운 노드를 저장해 놓기 위해 Heap 자료구조를 추가로 이용한다는 점이 다름</li>\n<li>현재의 최단 거리가 가장 짧은 노드를 선택해야 함으로 <strong>Min Heap 사용</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> heapq\n<span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수, 간선의 개수를 입력 받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 시작 노드 번호 입력받기</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndistance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">#### 여기까지는 기존 방법과 동일 ####</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dikstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    q <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># 시작 노드로 가기 위한 최단 경로르 0으로 설정, 큐에 삽입</span>\n    heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>    <span class=\"token comment\"># 큐가 비어있지 않다면</span>\n        <span class=\"token comment\"># 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기</span>\n        dist<span class=\"token punctuation\">,</span> now <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 현재 노드가 이미 처리된 적이 있는 노드라면 무시</span>\n        <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token comment\"># 현재 노드와 연결된 다른 인접 노드들 확인</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            cost <span class=\"token operator\">=</span> dist <span class=\"token operator\">+</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> cost <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cost\n                heapq<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 다익스트라 알고리즘 수행</span>\ndijkstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 노드로 가기 위한 최단 거리 출력</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 도달할 수 없는 경우, 무한으로 출력</span>\n    <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 도다랗ㄹ 수 있는 경우 거리 출력</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n<li>\n<p>‘개선된 구현 방법’ 성능 분석</p>\n<ul>\n<li>시간 복잡도: O(ElogV)\n<ul>\n<li>노드를 하나씩 꺼내 검사하는 반복문(<code class=\"language-text\">while</code>문)은 노드의 개수 V 이상 처리되지 않음\n: 결과적으로 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 총 횟수는 최대 edge의 개수(E)만큼 수행됨</li>\n</ul>\n</li>\n<li>직관적으로 전체 과정은 E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사\n<ul>\n<li>O(ElogE)로 판단할 수 있음</li>\n<li>중복 간선을 초함하지 않는 경우 O(ElogV)로 정리 가능\n: O(ElogE) -> O(ElogV^2) -> O(2ElogV) -> O(ElogV)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-floyd-warshall-알고리즘\" style=\"position:relative;\"><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"2 floyd warshall 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Floyd-Warshall 알고리즘</h2>\n<ul>\n<li><strong>모든 노드</strong>에서 <strong>다른 모든 노드</strong>까지의 최단 경로를 모두 계산</li>\n<li>다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘 수행\n<ul>\n<li>다만 매 단계마다 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾는 과정 필요하지 않음</li>\n</ul>\n</li>\n<li>2차원 테이블에 최단 거리 정보 저장</li>\n<li>Dynamic Programming 유형에 속함: 2차원 최단 거리 테이블을 점화식으로 update\n<ul>\n<li>각 단계마다 <strong>특정한 노드 K를 거쳐 가는 경우 확인</strong>: a에서 b로 가는 최단 거리보다 a에서 k를 거처 b로 가는 거리가 더 짧은지 검사</li>\n<li>점화식: <code class=\"language-text\">D_ab = min(D_ab, D_ak + D_kb)</code></li>\n</ul>\n</li>\n<li>시간 복잡도: O(N^3) -> 노드가 적은 경우에만 이용할 수 있음</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">INF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 무한을 의미하는 값으로 10억을 설정</span>\n\n<span class=\"token comment\"># 노드의 개수 및 간선의 개수를 입력받기</span>\nn <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nm <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 2차원 리스트(그래프 표현)를 만들고, 무한으로 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화</span>\n<span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token operator\">==</span>b<span class=\"token punctuation\">:</span>\n            graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token comment\"># 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># A에서 B로 가는 비용은 C라고 설정</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> c\n\n<span class=\"token comment\"># 점화식에 따라 플로이스 워션 알고리즘 수행</span>\n<span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span>graph<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 수행된 결과를 출력</span>\n<span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 도달할 수 없는 경우, 무한</span>\n        <span class=\"token keyword\">if</span> graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"INFINITY\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 도달할 수 있는 경우, 거리 출력</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Floyd-Warshall 알고리즘 성능 분석\n<ul>\n<li>시간 복잡도: O(N^3)\n<ul>\n<li>노드의 개수가 N개일 때, 알고리즘 상으로 N번의 단계(k를 거쳐 가는 경우)를 수행함</li>\n<li>각 단계마다 O(N^2)의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려함</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-bellman-ford-알고리즘\" style=\"position:relative;\"><a href=\"#3-bellman-ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"3 bellman ford 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Bellman-Ford 알고리즘</h2>\n<ul>\n<li>\n<p>조건: 음수 Edge가 포함된 상황에서의 최단 거리 문제</p>\n<ul>\n<li>e.g. <a href=\"https://www.acmicpc.net/problem/11657\">https://www.acmicpc.net/problem/11657</a></li>\n<li>음수 Edge에 대한 최단 경로 문제의 분류\n<ol>\n<li>모든 edge가 양수인 경우</li>\n<li>음수 edge가 있는 경우\n<ol>\n<li>음수 edge cycle이 없는 경우</li>\n<li>음수 edge cycle이 있는 경우</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Bellan-Ford 알고리즘</p>\n<ul>\n<li>음수 edge가 포함된 상황에서 사용 가능</li>\n<li>음수 edge의 cycle 감지 가능</li>\n<li>기본 시간 복잡도: O(VE)\n<ul>\n<li>Dijkstra 알고리즘에 비해 느림</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Bellman-Ford 알고리즘 동작 과정</p>\n<ol>\n<li>출발 노드 설정</li>\n<li>최단 거리 테이블 초기화</li>\n<li>다음 과정은 N-1번 반복\n<ol>\n<li>전체 edge E개를 하나씩 확인함</li>\n<li>각 edge를 거쳐 다른 노드로 가는 비용을 계산하여 최단거리 테이블 update</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>If, 음수 edge cycle이 발생하는지 체크하고 싶다면 3번의 과정을 한 번 더 수행\n<ul>\n<li>이 때, 최단거리 테이블이 update된다면 음수 edge cycle이 존재한다는 의미</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>💡 Bellman-Ford 알고리즘 v.s. Dijkstra 알고리즘</p>\n<ul>\n<li>Dijkstra 알고리즘\n<ul>\n<li><strong>매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택</strong></li>\n<li>음수 edge가 없다면 최적의 해를 찾을 수 있음</li>\n</ul>\n</li>\n<li>Bellman-Ford 알고리즘\n<ul>\n<li><strong>매번 모든 edge를 전부 확인함</strong>-> 따라서 <strong>Dijkstra 알고리즘에서의 최적의 해를 항상 포함</strong></li>\n<li>Dijkstra 알고리즘에 비해서 시간이 오래 걸리지만 음수 edge cycle을 탐지할 수 있음</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token builtin\">input</span> <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>realine\nINF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 무한을 의미하는 값으로 10억 설정</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">bf</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 시작 노드에 대해서 초기화</span>\n    dist<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token comment\"># 전체 n번의 round를 반복</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 매 반복마다 '모든 edge'를 확인하며</span>\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            cur <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n            next_node <span class=\"token operator\">=</span> edges<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            cost <span class=\"token operator\">=</span> edge<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 현재 edge를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우</span>\n            <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> INF <span class=\"token keyword\">and</span> dist<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> cost<span class=\"token punctuation\">:</span>\n                dist<span class=\"token punctuation\">[</span>next_node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dist<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> cost\n                <span class=\"token comment\"># n번째 라운드에서도 값이 갱신된다면 음수 cycle이 존재</span>\n                <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> n <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n<span class=\"token comment\"># 노드의 개수, edge의 개수 입력받기</span>\nn<span class=\"token punctuation\">,</span>m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 edge에 대한 정보를 담는 리스트 만들기</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 최단 거리 테이블을 모두 무한으로 초기화</span>\ndist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 모든 edge 정보를 입력받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># a번 노드에서 b번 노드로 가는 비용이 c라는 의미</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 벨만 포드 알고리즘 수행</span>\nnegative_cycle <span class=\"token operator\">=</span> bf<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 1번 노드가 시작 노드</span>\n\n<span class=\"token keyword\">if</span> negative_cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 1번 노드를 제외한 다른 모든 노드로 가기 위한 최단 거리 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 도달할 수 없는 경우 -1 출력</span>\n        <span class=\"token keyword\">if</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> INF<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 도달할 수 있는 경우 거리 출력</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-dijkstra-shortest-path-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">1. Dijkstra Shortest Path 알고리즘</a></li>\n<li><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">2. Floyd-Warshall 알고리즘</a></li>\n<li><a href=\"#3-bellman-ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">3. Bellman-Ford 알고리즘</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n</div>","excerpt":"가장 짧은 경로를 찾는 알고리즘 최단 경로 알고리즘이 사용될 수 있는 다양한 문제 상황 한 지점에서 다른 한 지점까지의 최단 경로 한 지점에서 다른 모든 지점까지의 최단 경로 모든 지점에서 다른 모든 지점까지의 최단 경로 Dynamic Programming 문제로 분류되기도 함 1. Dijkstra Shortest Path 알고리즘 특정한 한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로 계산 조건: 음수 Edge가 없을 때 (현실 세계의 도로) Greedy 알고리즘으로 분류: 매 상황에서 가장 비용이 적은 Node를 선택 💡 알고리즘 동작 과정 출발 노드 설정 최단 거리 테이블 초기화 (모든 노드까지의 거리 무한으로 설정 & 자기 자신까지의 거리는 0으로 설정) 최단 거리 테이블: 각 노드에 대한 현재끼ㅏ지의 최단 거리 정보 저장 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신 위 과정에…","frontmatter":{"date":"November 09, 2022","title":"Shortest Path 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Algorithm/Shortest_Path/"}},"next":{"id":"d1fef546-5d83-5ae7-bf87-4b75aafd193e","html":"<h2 id=\"1-disjoint-sets-서로소-집합-자료구조\" style=\"position:relative;\"><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\" aria-label=\"1 disjoint sets 서로소 집합 자료구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Disjoint Sets (서로소 집합) 자료구조</h2>\n<ul>\n<li>\n<p>서로소: ‘공통 원소가 없는 두 집합’ 의미</p>\n</li>\n<li>\n<p>서로소 집합 자료구조: 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조</p>\n</li>\n<li>\n<p>서로소 집합 자료구조(= <strong>Union Find 자료구조</strong>)의 연산</p>\n<ul>\n<li><strong>Union(합집합)</strong></li>\n<li><strong>Find(찾기)</strong>: 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산</li>\n</ul>\n</li>\n<li>\n<p>서로소 집합 자료구조 동작 과정</p>\n<ol>\n<li>Union 연산 확인 -> 서로 연결된 두 노드 A, B 확인\n<ol>\n<li>A와 B의 루트 노드 A’, B’를 각각 찾음</li>\n<li>A’를 B’의 부모 노드로 설정</li>\n</ol>\n</li>\n<li>모든 Union 연산을 처리할 때까지 1번 과정 반복</li>\n</ol>\n</li>\n<li>\n<p>서로소 집합 자료구조의 연결성</p>\n<ul>\n<li>기본적인 형태로 서로소 집합 자료구조에서는 root 노드에 즉시 접근할 수 없음\n-> root 노드를 찾기 위해 부모 테이블을 계속해서 확인하며 거슬러 올라가야 함</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABWElEQVQoz22PQU/CQBCF+6c96NWDJ3+GF9GTiSEaEhI1lBZtDdaWEoQ2ECPQbUvbBbbbPrOLJdQwyZd5szvvZVcpyxKiqp7nuaQqoTnn+x3GGIqiqHlEr1AqUZlplmFNqQwRc5omoJTKEBGWJLv5WJgMxEGJkCiOsUoSlEWBgnMsAyJnlCVyxkAIQZqm+8D/pYgQgfxGWSDbbLHI1mCcY81yLLM1ArrBlnNQliOmG/lysV95D1HiOEYURViQEPOAYElCkDDCT0AwJwSrv/vdHEp9iPAfonzPZhhMfFw+6Di/beGiqaNjjzDzJ/B9H+PxGK7rSu17HobDIb5GI3ieJ8+m02kNxR04eLVsnFzd4/S6hbM7Fc2uAcfq48Oy0O/3YZgmLMuSvJkm3lUVlmHg07bhOE4NpdfroaNpaDy2cdN6QqP1jPZLB7rWRbe7Q1XVo1rTNOi6XuMXuy1T+a8HV44AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-1.png\"\n        title=\"노드 3의 root를 찾기 위해 노드 2를 거쳐 노드 1에 접근해야 함\"\n        src=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png\"\n        srcset=\"/static/2b3fece62ca0d1847f7c7b8d807fba18/e9ff0/disjoint_set-1.png 180w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/f21e7/disjoint_set-1.png 360w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/37523/disjoint_set-1.png 720w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/302a4/disjoint_set-1.png 1080w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/07a9c/disjoint_set-1.png 1440w,\n/static/2b3fece62ca0d1847f7c7b8d807fba18/17d12/disjoint_set-1.png 1666w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>기본적인 구현 방법</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합을 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_partent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화</span>\n\n<span class=\"token comment\"># 부모 테이블상에서, 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># Union 연산 각각 수행</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 각 원소가 속한 집합 출력</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"각 원소가 속한 집합: \"</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 부모 테이블 내용 출력하기</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'부모 테이블: '</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>‘기본적인 구현 방법’의 문제점</p>\n<ul>\n<li>Union 연산이 편향되게 이루어지는 경우 Find 함수가 비효율적으로 동작</li>\n<li>최악의 경우에는 Find 함수가 모든 노드를 다 확인하게 되어 시간 복잡도다 O(V)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABiElEQVQoz02RS4sTQRSF+/f6A9y5c6kuXbp0IwyKDMMM6CTd6XZQJpmeJJ1MhIQk/UgC6Uz6/f6kLiIWXM6pc27dunVLq+uaxWLBZDJhuVyy3+/Z7XZ4nsd6vZbwfV9QaSpntVqJdgxD1Hm1uq4T1Nq25XA4sNlspFiaJMRRRBzHpGkqkSQJURSRZxlZmgpv/ivUNM0/rvF3VXVNWTeotLKqyfOcsmllXxQFeVFQdVA3rXhZWVK1HVmWk2UZqjHpsKoq6rIgjc6kSUxRlkRxTHg8ck4SkrzgdDoRhiFxXhAnqXinKCItS57PZ05hKJeoWpp65q/fa67vJ3y3nzCfNqw2Lr7nSXiuK/NyXVd4EPgyHuUFvs92uxUvCAIZmaY+5N2lwYsPX3j56ZZXlz8Z3D8wdxzsx0dGowdmsxm2bTMajXAcR3A8HjOdThkOh4JKn8/naHd3P3h/ccXrj195+/kbby5uuLnVsUwT3TAwDAPTstB1nX6/j2magqKbJr1ej8FgINyyLP4AJ9P/2tPubNUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"disjoint_set-2.png\"\n        title=\"최악의 경우 예시\"\n        src=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png\"\n        srcset=\"/static/d719cb6e7e8378a8a39bf9ebb59cde3b/e9ff0/disjoint_set-2.png 180w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/f21e7/disjoint_set-2.png 360w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/37523/disjoint_set-2.png 720w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/302a4/disjoint_set-2.png 1080w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/07a9c/disjoint_set-2.png 1440w,\n/static/d719cb6e7e8378a8a39bf9ebb59cde3b/96191/disjoint_set-2.png 2176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n</li>\n<li>\n<p>Path Compression (경로 압축)</p>\n<ul>\n<li>Find 함수를 최적화하기 위한 방법</li>\n<li>Find 함수를 재귀적으로 호출한 뒤에 <strong>부모 테이블 값을 바로 갱신</strong>\n<ul>\n<li>Find 함수를 호출한 이후에 해당 노드의 root 노드가 바로 부모 노드가 됨</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>partent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드가 아니라면 root 노드를 찾을 때까지 재귀적으로 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"disjoint-set을-활용한-cycle-판별\" style=\"position:relative;\"><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\" aria-label=\"disjoint set을 활용한 cycle 판별 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disjoint Set을 활용한 Cycle 판별</h3>\n<ul>\n<li>서로소 집합은 <strong>무방향 그래프(Undirected Graph) 내에서의 사이클을 판별</strong>할 때 사용 가능\n<ul>\n<li>cf. 방향 그래프(Directed Graph)에서의 사이클 여부는 DFS를 이용하여 판별 가능</li>\n</ul>\n</li>\n<li>Cycle 판별 알고리즘\n<ol>\n<li>각 Edge를 하나씩 확인하여 두 노드의 root 노드를 확인함\n<ol>\n<li>root 노드가 서로 다르다면 두 노드에 대해 Union 수행</li>\n<li>root 노드가 서로 같다면 Cycle이 발생한 것임</li>\n</ol>\n</li>\n<li>그래프에 포함되어 있는 모든 Edge에 대해 1번 과정을 반복</li>\n</ol>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 edge(Union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 부모 테이블 초기화하기</span>\n\n<span class=\"token comment\"># 부모 테이블에서 부모를 자기 자신으로 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\ncycle <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span> <span class=\"token comment\"># 사이클 발생 여부</span>\n\n<span class=\"token comment\"># Edge를 순회하며 cycle 탐색</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># cycle이 발생한 경우 종료</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        cycle <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n        <span class=\"token keyword\">break</span>\n    <span class=\"token comment\"># cycle이 발생하지 않았다면 Union 연산 수행</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> cycle<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"there is cycle\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no cycle\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"2-minimum-spanning-tree-최소-신장-트리\" style=\"position:relative;\"><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\" aria-label=\"2 minimum spanning tree 최소 신장 트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Minimum Spanning Tree (최소 신장 트리)</h2>\n<ul>\n<li>Spanning Tree: 그래프에서 <strong>모든 노드를 포함</strong>하면서 <strong>cycle이 존재하지 않는 부분 그래프</strong> 의미\n<ul>\n<li>cf. Tree의 조건: 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다</li>\n<li>Edge의 개수 = Vertex의 개수 - 1</li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA70lEQVQY002ObW+DMAyE+f//a6q6VUzTNqFC2/HyYZogQCgqISE8k1PR7STL9tm+cwTgvWee55CttSzLwgbpnVtwy322IdzIrl+ZZxt6QbSJTdP0EJTaOYd1jts0Yaxj8R5j5oehZCNPrOv9xpjAR3JojAnqQqzrGgyE2752/0IMRGD7VubaedR4wxpDpLVGKcUwDNR1Td/3dF33F1rTdj2NUlzHEdW2YUeyHq781DXfnUY1DX1TExVFQVmWZFlGHMckSUJVVeR5TlkWJOmZ+D3l9SPl7TMjLwryy4XjfkcWH0hf9pwPzxx3T3ydMn4BG7x+0KXicSUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"spanning_tree-1.png\"\n        title=\"spanning_tree-1.png\"\n        src=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png\"\n        srcset=\"/static/646bf58eedfaacc58c1aa3f2785ca3a1/e9ff0/spanning_tree-1.png 180w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/f21e7/spanning_tree-1.png 360w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/37523/spanning_tree-1.png 720w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/302a4/spanning_tree-1.png 1080w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/07a9c/spanning_tree-1.png 1440w,\n/static/646bf58eedfaacc58c1aa3f2785ca3a1/b918a/spanning_tree-1.png 2780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>Minimum Spanning Tree: <strong>최소한의 비용으로 구성되는 신장 트리</strong></p>\n<ul>\n<li>e.g., N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 <strong>전체 도시가 서로 연결</strong>될 수 있게 도로를 설치하는 경우 (= 두 도시 A, B를 선택했을 때 A에서 B로 이동하는 경로가 반드시 존재)</li>\n</ul>\n</li>\n<li>\n<p><strong>Kruskal 알고리즘</strong></p>\n<ul>\n<li>대표적인 Minimum Spanning Tree 알고리즘</li>\n<li>Greedy 알고리즘</li>\n<li>동작 과정:\n<blockquote>\n<ol>\n<li>edge 데이터를 cost에 따라 <strong>오름차순으로 정렬</strong></li>\n<li>edge를 하나씩 확인하며 <strong>현재의 간선이 사이클을 발생시키는지 확인</strong>\n<ol>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시킴</li>\n<li>사이클이 발생하지 않는 경우: MSP에 포함시키지 않음</li>\n</ol>\n</li>\n<li>모든 edge에 대해 2번 과정 반복</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 특정 원소가 속한 집합 찾기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">find_parent</span><span class=\"token punctuation\">(</span>parent x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># root 노드를 찾을 때까지 재귀 호출</span>\n    <span class=\"token keyword\">if</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 두 원소가 속한 집합 합치기</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">union_parent</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    b <span class=\"token operator\">=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        parent<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> b\n\n<span class=\"token comment\"># 노드의 개수와 간선(union 연산)의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nparent <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 자기 자신을 부모로 parent table 초기화</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n\n<span class=\"token comment\"># 모든 edge를 담을 리스트와 final cost를 담을 변수</span>\nedges <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nresult <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 연산에 포함될 경우 = MST에 포함된다는 의미</span>\n\n<span class=\"token comment\"># 모든 간선에 대한 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> cost <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 cost으로 설정</span>\n    edges<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 cost순으로 정렬</span>\nedges<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># edge를 하나씩 확인해가며</span>\n<span class=\"token keyword\">for</span> edge <span class=\"token keyword\">in</span> edges<span class=\"token punctuation\">:</span>\n    cost<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> edge\n    <span class=\"token comment\"># 사이클이 발생하지 않는 경우에만 집합에 포함</span>\n    <span class=\"token keyword\">if</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> find_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        union_parent<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">+=</span> cost\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Kruskal 알고리즘의 성능 분석\n<ul>\n<li>시간 복잡도: O(ElogE) (Edge 개수 = E일 때)</li>\n<li>가장 많은 시간 요구하는 곳: edge 정렬 부분\n<ul>\n<li>표준 라이브러리(<code class=\"language-text\">sort()</code>)를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도: O(ElogE)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-topological-sort-위상-정렬\" style=\"position:relative;\"><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\" aria-label=\"3 topological sort 위상 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Topological Sort (위상 정렬)</h2>\n<ul>\n<li>**Cycle이 없는 Directed Graph(DAG, Directed Acyclic Graph)**의 모든 노드를 <strong>방향성에 거스르지 않도록 순서대로 나열</strong>\n<blockquote>\n<p>💡 DAG 여야하는 이유?\n: Cycle이 존재할 경우 Cycle이 존재하는 모든 노드의 Indegree가 1 이상이 되므로 다음 알고리즘을 사용할 경우, Cycle이 존재하는 모든 노드가 영원히 Queue에 들어갈 수 없음(=Sorting 수행할 수 없음)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>cf. Indegree와 Outdegree</p>\n<ul>\n<li>Indegree: 특정한 노드로 들어오는 edge의 개수</li>\n<li>Outdegree: 특정한 노드에서 나가는 edge의 개수</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Queue</strong>를 이용하는 Topological Sort 알고리즘 동작 과정\\</p>\n<ul>\n<li>각 노드가 Queue에 들어온 순서 = Topological Sort 수행 결과</li>\n</ul>\n<blockquote>\n<ol>\n<li>Indegree가 0인 모든 노드를 Queue에 넣음</li>\n<li>Queue가 빌 때까지 다음의 과정 반복</li>\n<li>Queue에서 원소를 꺼내 해당 노드에서 Outdegree를 그래프에서 제거함</li>\n<li>새롭게 Indegree가 0이 된 노드를 Queue에 넣음</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>Topological Sort 특징</p>\n<ul>\n<li>DAG (Direct Acyclic Graph), 순환하지 않는 방향 그래프에서만 수행 가능</li>\n<li><strong>여러 가지 답이 존재</strong>할 수 있음\n<ul>\n<li>한 단계에서 Queue에 새롭게 드어가는 원소가 2개 이상 있다면, 여러 가지 답이 존재</li>\n</ul>\n</li>\n<li><strong>모든 원소를 방문하기 전에 큐가 빈다면 Cycle이 존재</strong>한다고 판단\n<ul>\n<li>Cycle에 포함된 원소 중에서 어떠한 원소도 Queue에 들어가지 못함</li>\n</ul>\n</li>\n<li>Stack을 활용한 DFS를 이용해서도 Topological Sort 수행 가능</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\n<span class=\"token comment\"># 노드의 개수와 Edge의 개수 입력 받기</span>\nv<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 모든 노드에 대한 indegree를 0으로 초기화</span>\nindegree <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 각 노드에 연결된 edge 정보를 담기 위한 연결 리스트 초기화</span>\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> ragne<span class=\"token punctuation\">(</span>v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\"># 방향 그래프의 모든 간선 정보 입력 받기</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    a<span class=\"token punctuation\">,</span>b <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># A에서 B로 이동 가능</span>\n    <span class=\"token comment\"># indegree를 1 증가</span>\n    indegree<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\"># Topological Sort</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">topology_sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># 알고리즘 수행 결과를 담을 리스트</span>\n    q <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># queue</span>\n    <span class=\"token comment\"># 처음 시작할 때는 진입 차수가 0인ㅇ 노드를 queue에 삽입</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 큐가 빌 때까지 반복</span>\n    <span class=\"token keyword\">while</span> q<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 큐에서 원소 꺼내기</span>\n        now <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 해당 원소와 연결된 노드들의 indegree에서 1 빼기</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n            <span class=\"token comment\"># 새롭게 indegree가 0이 되는 노드를 queue에 삽입</span>\n            <span class=\"token keyword\">if</span> indegree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                q<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Topological Sort 수행 결과 출력</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> result<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\ntopology_sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Topology Sort의 성능 분석\n<ul>\n<li>시간 복잡도: O(V+E)</li>\n<li>차례대로 모든 Vertex를 확인해가며 각 Vertex에서 나가는 Edge를 차례대로 제거해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">나동빈. (2021). 이것이 취업을 위한 코딩 테스트다</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-disjoint-sets-%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0\">1. Disjoint Sets (서로소 집합) 자료구조</a></p>\n<ul>\n<li><a href=\"#disjoint-set%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-cycle-%ED%8C%90%EB%B3%84\">Disjoint Set을 활용한 Cycle 판별</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-minimum-spanning-tree-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\">2. Minimum Spanning Tree (최소 신장 트리)</a></p>\n</li>\n<li>\n<p><a href=\"#3-topological-sort-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\">3. Topological Sort (위상 정렬)</a></p>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 08, 2022","title":"Graph 알고리즘 정리","categories":"Algorithm","author":"Mini","emoji":"🧩"},"fields":{"slug":"/Algorithm/Graph/"}},"prev":{"id":"7693020f-a73f-5ab9-9144-05687ca77cc5","html":"<h2 id=\"0-들어가기-전에\" style=\"position:relative;\"><a href=\"#0-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"0 들어가기 전에 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0. 들어가기 전에</h2>\n<p>아직 면접 경험이 별로 없지만, 면접 기회가 생길 때마다 질문으로 나올 만한 CS 개념들을 정리해두면\n앞으로의 면접에서도 많은 도움을 받을 수 있지 않을까해서 정리해둔다.</p>\n<p>참고로, 아래에는 일반적인 CS 개념들도 포함되어 있지만\n일부는 내가 석사 과정동안 진행했던 연구들에 대한 개념들도 함께 들어있다.</p>\n<p>석사 과정동안 진행했던 연구의 키워드들은 조금 깊게,\n그리고 그 이외의 CS 키워드들은 좀 더 얕게 정리할 계획이다.</p>\n<p>참고로 면접에서는 장황하게 말하는 것보다, 키워드를 담은 한 문장으로 설명하는 것이 중요하더라.\n그래서 최대한 키워드를 담은 한 문장을 통해 개념을 설명하고, 추가 질문에 대비한 답변들도 정리해 둘 계획이다.</p>\n<p>지금 당장은 외국 기업 면접을 앞두고 있는터라, 영어로도 함께 정리해 둘 계획이다.</p>\n<p>큰 카테고리로 나누어서 개념들을 정리해두었다.</p>\n<h2 id=\"common-cs-interview\" style=\"position:relative;\"><a href=\"#common-cs-interview\" aria-label=\"common cs interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Common CS Interview</h2>\n<h3 id=\"1-os\" style=\"position:relative;\"><a href=\"#1-os\" aria-label=\"1 os permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. OS</h3>\n<ul>\n<li>‘Operating System’이라는 용어를 일반인에게 설명</li>\n</ul>\n<blockquote>\n<p>짧게 말하자면, ‘무엇인가를 수행’하기 위해서 하드웨어에 로드하는 소프트웨어를 말한다.\n예를 들어, 당신의 아이폰이라는 하드웨어에서 실행되는 iOS 운영 체제가 있다.\n<u>The short answer is that an operatin system is software that you load on your hardware to make it ‘do things’.</u>\n<u>The example is iOS operating system which runs on your iPhone hordware.</u></p>\n</blockquote>\n<ul>\n<li>Linux의 네트워크 인터페이스</li>\n</ul>\n<blockquote>\n<p>Loopback과 Ethernet이 있습니다. Loopback(lo)는 127.0.0.1 IP 주소를 가지며, Ethernet(eth0) 인터페이스는 DHCP에 의해 dynamic address를 부여받으며,</p>\n</blockquote>\n<ul>\n<li>Linux에서 네트워킹 도구 사례</li>\n</ul>\n<blockquote>\n<p>네트워크 도달 가능성을 테스트하기 위한 가장 기본적인 네트워크 테스트 도구인 Ping이 있으며, 네트워크를 통해 ICMP(Internet Control Message Protocol) 패킷을 보내고 응답이 있는지 알려준다. 호스트가 작동 중이고 네트워크에서 통신할 수 있는 경우, ICMP 응답이 반환된다.\n<u>Ping is the most basic network test tool around for testing network reachabiltiy, and it sends out an Internet Control Message Protocol (ICMP) patcket across the network and norifies you whether there is a reponse. If a host is up and able to communicate on the network, an ICMP response will be returned.</u>\n또 다른 도구는 네트워크 trouble shooting 도구인 traceroute이며, 로컬 시스템에서 출발하여 destination으로 도달하기까지 경로를 따라 라우팅되는 각 IP 라우터에 대한 정보를 수집한다. 이를 통해 어떤 노드가 문제를 일으키는지 확인할 수 있습니다.\n<u>Another Linux network trouble shooting tool is traceroute, and it proves the network between the local system and a destination, gathering information about each IP router in the path. It is usefuls when you want to find out which node is creating the problem.</u></p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Linux의 Inter-Process Communication 기술</strong></p>\n</li>\n<li>\n<p>System Daemon 설명</p>\n</li>\n</ul>\n<blockquote>\n<p>시스템 데몬은 일반적으로 작업을 시작하기 전에 특정 조건 집합을 기다리는 백그라운드 시스템 프로세스이며, 일반적으로는 사용자가 직접 제어하지 않고 시스템 자체에사 제어한다.\n<u>A system daemon is typically a background system process that awaits a specific set of conditions before jumping into action, and it is not typically under the direct control of users, but rather of the system itself.</u></p>\n</blockquote>\n<ul>\n<li>\n<p>Message Queue의 작업 설명</p>\n</li>\n<li>\n<p>Semaphore와 Busy Waiting 설명</p>\n<ul>\n<li>실제 사례를 사용하여 Busy Waiting 설명</li>\n</ul>\n</li>\n<li>\n<p><strong>Semaphore와 Mutex</strong></p>\n</li>\n<li>\n<p><strong>Multi-threading 설명</strong></p>\n<ul>\n<li>Multi-threading의 장점은 무엇인가?</li>\n</ul>\n</li>\n<li>\n<p>리눅스에서 실행 중인 프로세스의 PID를 가져오는 프로그램</p>\n</li>\n<li>\n<p><strong>스케줄링의 종류</strong></p>\n</li>\n<li>\n<p>한가지 프로세스 스케줄링 방법을 다른 스케줄링 방법으로 변환하는 방법</p>\n</li>\n<li>\n<p>Queue를 구현하지 위해서 몇 개의 Stack이 필요한가? 구현을 위한 Pseudo-code</p>\n</li>\n<li>\n<p>메모리의 유형</p>\n</li>\n<li>\n<p>Virtual Memory</p>\n</li>\n<li>\n<p>Cache memory와 Main Memory의 차이점</p>\n</li>\n<li>\n<p>System Call 설명</p>\n</li>\n<li>\n<p>Printf()는 어떻게 작동하는가?</p>\n</li>\n<li>\n<p>Deadlock</p>\n</li>\n<li>\n<p>Context Switching</p>\n</li>\n<li>\n<p>Paging과 Segmentation</p>\n</li>\n<li>\n<p>Process 상태와 속성</p>\n</li>\n<li>\n<p><strong>Thread</strong></p>\n<ul>\n<li>Thread 관련 프로그래밍</li>\n</ul>\n</li>\n<li>\n<p>라이브러리의 유형</p>\n<ul>\n<li>동적 라이브러리를 driver test 프로그램과 연결하는 방법</li>\n</ul>\n</li>\n<li>\n<p>시스템 간의 Synchronous &#x26; Asynchronous communication 방법</p>\n</li>\n<li>\n<p>Recycle bin(휴지통)의 내부 구현</p>\n</li>\n<li>\n<p>Atomic Transaction(원자적 트랜잭션) 설명</p>\n<ul>\n<li>트랜잭션이 atomic한지 어떻게 확인할 수 있는가?</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-network\" style=\"position:relative;\"><a href=\"#2-network\" aria-label=\"2 network permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Network</h3>\n<ul>\n<li>MAC 주소란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>MAC(Media Access Control) 주소는 OSI 모델의 데이터 링크 계층인 2계층에서 네트워크 인터페이스에 할당된 고유 식별자이며, 네트워크 인터페이스에는 IP 주소는 없더라도 하드웨어 주소라고도 하는 MAC 주소가 항상 존재한다.</p>\n</blockquote>\n<ul>\n<li><strong>Networking 용어 설명</strong></li>\n</ul>\n<blockquote>\n<p>디바이스가 네트워크에 연결되어 서로 통신하는 것을 의미한다.\nIt means that devices are connected to the network and communicate with each other.</p>\n</blockquote>\n<ul>\n<li><strong>Network 유형</strong></li>\n</ul>\n<blockquote>\n<p>“거리”에 따라 5m 전후의 인접 통신인 PAN(Personal Area Network), 소규모 공간 내의 고속 통신 회선인 LAN(Local Area Network), LAN과 WAN의 중간 형태인 MAN(Metropolitan Area Network), 광대역 네트워크 망으로 관련된 LAN을 서로 연결한 WAN(Wide Area Network)기 있다.\n“데이터 전송 방식”에 따라 단방향 통신(Simplex), 서로 데이터를 전송할 수 있지만, 하나의 회선을 사용하기 때문에 동시에 전송을 불가능한 반이중 통신(Half Duplex), 서로 언제나 필요한 데이터를 동시에 송수신할 수 있는 Full Duplex가 있다.\n“네트워크 토폴로지”에 따라 Tree형, Bus형, Star형, Ring현, Mesh형이 있다.</p>\n</blockquote>\n<ul>\n<li>P2P 및 Client-Server 네트워크 설명 및 장단점</li>\n</ul>\n<blockquote>\n<p>Client-Servier 네트워크는 정보를 가지고 있고, 이를 처리하는 서버 컴퓨터와 서버에 정보를 요청하여 응답을 받는 클라이언트로 구성된 네트워크이다.\n반면에 P2P 네트워크는 서버를 거치지 않고 클라이언트끼리 직접 통신하는 방식이다. 각 노드들은 요청과 응답 모두 가능하다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 실생활에서 P2P의 예</code></pre></div>\n<blockquote>\n<p>대표적으로는 암호 화페와 같은 블록체인 기술이 있습니다. 탈중앙화를 위해 P2P 네트워크를 채택하여 사용합니다.\nA representative example is blockchain technology such as cryptocurrency. It adopts P2P network decentralization.</p>\n</blockquote>\n<ul>\n<li><strong>Bridge와 Switch의 차이점</strong></li>\n</ul>\n<blockquote>\n<p>Bridge는 Switch와 비슷한 역할을 한다. 하지만 Switch는 처리 방식이 하드웨어이고, Bridge는 소프트웨어이기 때문에 속도가 Switch가 훨씬 빠르다. 또한 포트 10개도 채 지원되지 않는 Bridge에 비해 Switch의 포트 수가 훨씬 많다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- __Router의 동작 과정을 간략하게 설명__</code></pre></div>\n<blockquote>\n<ol>\n<li>패킷은 목적지의 IP 주고와 데이터로 구성된다. 라우터는 패킷의 목적지가 같은 네트워크에 있는지 아니면 다른 네트워크에 있는지 확인하기 위해 LAN 테이블을 검사한다.</li>\n<li>네트워크 테이블을 검사하여 패킷을 전달할 네트워크 주소를 찾아낸다</li>\n<li>라우팅 테이블을 검색하여 가장 적합한 경로를 찾아내서 패킷을 보낸다.</li>\n</ol>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 경로에 오류가 있는 경우, dynamic routing protocol은 어떻게 경로를 전환하는가?</code></pre></div>\n<ul>\n<li><strong>OSI Reference Model에서 계층들</strong></li>\n</ul>\n<blockquote>\n<p>1 Physical Layer (cable, hub), 2 Data Link Layer (bridge, switch), 3 Network Layer (router), 4 Transport Layer (TCP, UDP), 5 Session Layer, 6 Presentation Layer (SSL), 7 Application Layer (HTTP, SMTP)</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- __Router와 Switch는 어느 Layer에 위치해 있는지? 이 둘의 차이점은 무엇인지?__</code></pre></div>\n<blockquote>\n<p>Switch는 여러 디바이스를 서로 연결함으로써 하나의 네트워크(IntraNet)를 구축한다. Switch는 같은 네트워크 안에서 목적지에 맞게 데이터를 중간에 적합한 경로로 스위칭해주는 역할을 한다. Layer 2(데이터 링크 계층)에 해당하며, 데이터 링크 계층이기 때문에 MAC 주소 기반으로 동작한다.\nRouter는 여러 스위치, 즉 각각의 서로 다른 네트워크들을 연결하여 더 큰 네트워크(인터넷)를 형성한다. Router 또한 서로 다른 네트워크 목적지로 가는 적합한 경로를 찾아주는 라우팅 기능을 한다. 라우터는 Layer 3(네트워크 계층)의 IP 주소를 기반으로 작동한다.\n둘의 차이점은 우선 서로 다른 계층에서 작동한다는 점이다. 또한, Switch의 경우 목적지가 없을 경우 모든 포트에 패킷을 전송하지만, 라우터의 경우 분명한 도착지 정보가 있을 때만 통신을 허락하ㅗ 없으면 패킷을 바로 버린다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- Networking에서 왜 이렇게 다른 Layer가 필요한지?</code></pre></div>\n<blockquote>\n<p>if is because of the fact that it will be easy for troubleshooting the network problems.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 물리적 계층에서는 어떤 일이 발생하는지?</code></pre></div>\n<blockquote>\n<p>물리적 계층에서는 이진수로된 신호를 전기 신호로 바꾸어 케이블을 통해 목적지로 전달함\nAt the physical layer, the binary signal is converted into a electrical siganl and transmitted to the destination through the cables.</p>\n</blockquote>\n<ul>\n<li><strong>TCP/IP 설명</strong></li>\n</ul>\n<blockquote>\n<p>TCP는 애플리케이션이 네트워크에서 신뢰성 있는 통신 채널을 만들고, IP는 올바른 대상에 도달하도록 각 패킷의 주소를 지정하고 라우팅하는 방법을 정의한다.\n1 Network Access Layer (MAC), 2 Internet Layer (IP), 3 Transport Layer (TCP), 4 Application Layer (HTTP)로 구성되어 있다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- TCP의 message에는 어떤 내용이 있는지?</code></pre></div>\n<blockquote>\n<p>Source port, destination port, sequence number, acknowledgment number, data offset, reserved, control bits, window, checksum, urgent pointer, options, padding, data</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- TCP/IP는 어떻게 작동하는가?</code></pre></div>\n<blockquote>\n<p>Data -(Application)-> Message -(Transfer)-> Segment -(Internet)-> Packet -(Network Interface)-> Frame</p>\n</blockquote>\n<ul>\n<li>IPv4 address에서 클래스 설명</li>\n</ul>\n<blockquote>\n<p>IP 주소는 네트워크 주소 부분과 호스트 주소 부분으로 나뉘다. 클래스에 따라 네트워크 주소 부분과 호스트 주소 부분의 크기가 변한다.\n네트워크 클래스는 A, B, C, D, E로 나누어져 있으며, Class A는 0.0.0.0<del>127.255.255.255 범위이며, 네트워크 개수가 126개 &#x26; 호스트 개수가 (256<em>256</em>256 - 2)개이다.\nClass B는 128.0.0.0</del>191.255.255.255 범위이며, 네트워크 주소 개수가 64<em>256개, 호스트 주소 개수가 (256</em>256 - 2)개이다.\nClass C는 192.0.0.0<del>223.255.255.255 범위이며, 네트워크 주소 개수가 32<em>256</em>256개이며, 호스트 주소가 (256-2)개\nClass D는 224.0.0.0</del>239.255.255.255 범위로 네트워크 주소 16개, 호스트 주소 (256-2)개이다.\nClass E는 240.0.0.0~255.255.255.255 범위로 네트워크 주소 16개 호스트 주소 (256-2)개이다.\n(-2는 모두 0은 자기 자신, 모두 1은 브로드캐스트 주소를 의미하기 때문이다.)</p>\n</blockquote>\n<ul>\n<li>IPv4와 IPv6의 차이점은?</li>\n</ul>\n<blockquote>\n<p>IPv4는 주소 길이가 8bit씩 4부분으로 10진수(Decimal)로 표시된 32bit 인데 반면, IPv6는 16비트가 8부분으로 16진수(Hexadecimal)로 표시된 128bit 주소이다. IPv6은 IPv4의 주소 부족 문제를 해결하였다.</p>\n</blockquote>\n<ul>\n<li>Ethernet Cable은 무엇이고, 어떻게 작동하는가?</li>\n</ul>\n<blockquote>\n<p>Ethernet Cable은 디바이스와 네트워크 장치(Switch, Router)를 연결하는 케이블로, 로컬 네트워크 또는 인터넷에 대한 장치 액세스를 제공한다.</p>\n</blockquote>\n<ul>\n<li><strong>DNS 작동 방식</strong></li>\n</ul>\n<blockquote>\n<p>Domain Name System 호스트의 도메인 이름을 호스트의 IP 주소로 바꾸거나 그 반대를 수행하는 시스템이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- __웹 브라우저에 www.google.com을 입력할 경우 어떻게 되는지?__</code></pre></div>\n<blockquote>\n<ol>\n<li>local DNS에게 <a href=\"http://www.google.com%EC%9D%B4%EB%9D%BC%EB%8A%94\">www.google.com이라는</a> hostname에 대한 IP 주소를 request, local DNS에 없으면 Root DNS 정보 전달받음</li>\n<li>Root DNS 서버에 <a href=\"http://www.google.com\">www.google.com</a> Request</li>\n<li>Root DNS 서버로부터 .com 도메인을 관리하는 TLD(Top-Level Domain) DNS 정보 전달 받음</li>\n<li>TLD에게 <a href=\"http://www.google.com\">www.google.com</a> request</li>\n<li>TLD에서 google.com 관리하는 DNS 정보 전달</li>\n<li>google.com 도메인을 관리하는 DNS 서버에 <a href=\"http://www.google.com\">www.google.com</a> 호스트네임에 대한 IP 주소 request</li>\n<li>해당 서버가 <a href=\"http://www.google.com\">www.google.com</a> IP 주소 response</li>\n<li>Local DNS는 <a href=\"http://www.google.com%EC%97%90\">www.google.com에</a> 대한 IP 주소를 caching하고 IP 주소 전달</li>\n</ol>\n</blockquote>\n<ul>\n<li>ARP(Address Resolution Protocol) 설명</li>\n</ul>\n<blockquote>\n<p>Address Resolution Protocol, IP 주소를 해당 IP 주소에 맞는 MAC 주소로 변환시켜주는 프로토콜\n송신자는 목적지 MAC 주소가 필요하므로, MAC 주소 요청을 위한 ARP request packet을 boadcast로 전송 -> 모든 호스트와 라우터는 송신자가 보낸 ARP 요청 패킷을 수신함 -> 해당되는 수신자만 자신의 IP 주소와 MAC 주소를 넣어 response 패킷을 Unicast로 전송</p>\n</blockquote>\n<ul>\n<li><strong>TCP와 UDP의 차이</strong></li>\n</ul>\n<blockquote>\n<p>둘 다 4계층, 전송 계층에 해당한다.\nTCP 프로토콜은 양종단 호스트 내 프로세스 상호 간에 신뢰적인 연결 지향적 서비스를 제공한다. 3-way handshaking(SYN->SYN/ACK->ACK) 과정을 통해 연결 설정 및 4-way handshaking(FIN->ACK->FIN->ACK)을 통해 연결 해제\nUDP 프로토콜은 비연결성이고, 신뢰성이 없으며, 순서화되지 않은 Datagram 서비스를 제공하지만, 빠른 요청과 응답이 가능하다.\nThey are corresponds to the Layer 4, Transport Layer.\nTCP protocol provides reliable connection-oriented services between processes in both end to end. 3-way handshaking to connect and 4-way handshaking to disconnect.\nUDP protocol provides a connectionless, unreliable, unordered datagram service, but allows fast requests and responses.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 사용되는 실제 사례</code></pre></div>\n<blockquote>\n<ul>\n<li>TCP: email, HTTP, file transfer</li>\n<li>UDP: real-time video player, game</li>\n</ul>\n</blockquote>\n<ul>\n<li>HTTP란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.</p>\n</blockquote>\n<ul>\n<li><strong>Super-Netting과 Sub-Netting이 무엇인가?</strong></li>\n</ul>\n<blockquote>\n<p>Subnetting은 Subnet을 만드는 것으로, Network를 나누는 개념이다. 즉, IP address에서 Network 범위는 늘이고, Host 범위는 줄이는 것이다.\nSupternetting은 Network를 합치는 것이다. 즉, IP address에서 Netowrk 범위는 줄이고, Host 범위는 늘이는 것이다.</p>\n</blockquote>\n<ul>\n<li>TraceRoute 설명</li>\n</ul>\n<blockquote>\n<p>패킷이 목적지까지 도달하는 동안 거치는 라우터의 IP를 확인할 수 있는 Tool 이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- ICMP 설명</code></pre></div>\n<blockquote>\n<p>Internet Control Message Protocol, TCP/IC에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다. 이는 패킷이 오로지 목적지 도달만을 위한 내용으로 구성되어 있기 때문에 에러가 발생한 경우 출발지에게 이를 알릴 방법이 없어 이를 보완하기 위해 나왔다.</p>\n</blockquote>\n<ul>\n<li>\n<p>IP header</p>\n</li>\n<li>\n<p>Sliding Window Protocol 설명</p>\n</li>\n</ul>\n<blockquote>\n<p>두 호스트 간 데이터 전송 시 오류 제어와 흐름 제어를 지원하는 통신 프로토콜이다.\n즉, 수신 호스트가 연속적으로 수신할 수 있는 정보 프레임의 개수를 윈도우의 크기로 지정함으로써, 송신 호스트의 프레임 전송 속도를 제어한다.</p>\n</blockquote>\n<ul>\n<li>TTL이란</li>\n</ul>\n<blockquote>\n<p>Time To Live의 약자고 패킷의 생존 시간을 의미한다. 즉, 인터넷에서 IP 패킷이 거쳐갈 수 있는 라우터의 개수를 표현하는 수이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- TTL의 기본값은?</code></pre></div>\n<blockquote>\n<p>TTL의 default 값은 OS마다 다르며, Linux는 64, Window는 128, Cisco는 256이다.</p>\n</blockquote>\n<ul>\n<li>SDN이란</li>\n</ul>\n<blockquote>\n<p>Software-Defined Networking으로 소프트웨어 애플리케이션과 API를 이용하여 네트워크를 프로그래밍하고, 중앙에서 전체 네트워크를 제어하고 관리하는 접근 방식이다.\n기존 Router에서는 Path를 결정하는 Control Plane과 전송을 담당하는 Data Plane이 함께 있었지만, SDN을 적용하면 이를 분리하여 Control Plane을 별도의 컴퓨팅 서버로 분리하고, Router는 전송만 담당하는 Data Plane 역할만 하도록 만들 수 있다.</p>\n</blockquote>\n<h3 id=\"3-dsa-data-structure--algorithm\" style=\"position:relative;\"><a href=\"#3-dsa-data-structure--algorithm\" aria-label=\"3 dsa data structure  algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. DSA (Data Structure &#x26; Algorithm)</h3>\n<ul>\n<li>\n<p>공간 복잡도 O(1)로 하나의 숫자를 search할 확률</p>\n</li>\n<li>\n<p>Linked List 구현 (insertion, deletion, traversing)</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Insertion:\n1. 메모리 공간 할당 받고 삽입할 내요응ㄹ 저장하여 삽입할 노드 생성\n2. 삽입할 노드의 next가 후행 노드가 될 노드를 가리키게 함\n3. 삽입할 노드의 선행 노드가 될 노드의 next가 삽입할 노드의 주소를 가리키게 함</li>\n<li>Deletion:\n1. 삭제할 노드의 선행 노드의 next를 삭제할 노드의 next를 가리키게 함\n2. 삭제할 노드를 메모리에 반환</li>\n<li>Traversing:\n1. head 노드부터 시작해서 next 노드로 계속 이동\n2. next가 NULl이면 linked list의 끝에 도달</li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/reverse-a-doubly-linked-list/\"><strong>Reverse Doubly Linke List</strong></a></li>\n</ul>\n<blockquote>\n<p>Key Point: Stack을 사용한다.\n첫 번째 Linked List Traversal에는 Stack에 data를 push\n두 번째 Linked List Traversal에는 Stack에서 Pop한 data를 차례로 Update</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/reverse-a-linked-list/\">Reverse Linked List</a></li>\n</ul>\n<blockquote>\n<p>Linked List를 첫 번째 노드와 나머지 노드들, 두 부분으로 나눔.\n연결된 목록의 나머지 부분에 대해 reverse 수행\n나머지를 첫 번째 노드한테 연결\nHead를 마지막 노드로 바꾸기</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/\">2개의 Linked List가 교차하는 지점(intersection)을 얻는 방법</a></li>\n</ul>\n<blockquote>\n<ol>\n<li>두 Linked List의 길이를 잰다</li>\n<li>길이 차이가 있다먄 둘 중 더 긴 리스트의 포인터를 스킵한다.</li>\n<li>같은 출발 지점부터 포인터를 같은 속도로 이동시키며 비교한다.</li>\n</ol>\n<p>Time Complexity: O(A+B)\nSpace Complexity: O(1)</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/detect-and-remove-loop-in-a-linked-list/\"><strong>Linked List에서 Loop를 감지하고 제거하는 방법</strong></a></li>\n</ul>\n<blockquote>\n<p>Key Point: Fast Pointer(i+2씩 증가) Slow Pointer(i+1씩 증가)</p>\n<ol>\n<li>Fast Pointer와 Slow Pointer가 Loop 안에서 만남 (Loop Detection)</li>\n<li>Slow Pointer를 제일 처음으로 다시 이동</li>\n<li>Slow와 Fast가 만날 때까지 다시 반복. 이번에는 둘 다 한 칸씩 이동</li>\n<li>Loop의 시작 노드에서 만나게 됨.</li>\n<li>Loop의 마지막 노드의 next를 NULL로 수정</li>\n</ol>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/\">Linked List에서 중간 지점 요소 찾는 방법</a></li>\n</ul>\n<blockquote>\n<p>Key Point: Fast Pointer(i+2씩 증가) Slow Pointer(i+1씩 증가)</p>\n<ol>\n<li>Slow Pointer와 Fast Pointer 각각 이동</li>\n<li>Slow Pointer가 traversal이 끝났을 때, Fast Pointer의 위치 반환</li>\n</ol>\n</blockquote>\n<ul>\n<li>단 한 번의 traversal만을 사용하여 Linked List에서 끝에서부터 n번째 노드 찾기</li>\n</ul>\n<blockquote>\n<p>Key Point: n만큼 간격을 유지하는 두 개의 포인터 사용</p>\n<ol>\n<li>첫 번째 포인터를 n만큼 먼저 이동</li>\n<li>두 번째 포인터와 함께 첫 번째 포인터를 한 칸씩 이동</li>\n<li>첫 번째 포인터가 linked list 끝에 도달 할 경우, 두 번째 포인터의 위치가 끝에서부터 n번째 노드</li>\n</ol>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/in-a-linked-list-given-only-a-pointer-to-a-node-to-be-deleted-in-a-singly-linked-list-how-do-you-delete-it/\">Single Pointer를 사용하여 Linked List에서 노드를 삭제하는 방법</a></li>\n</ul>\n<blockquote>\n<ol>\n<li>tmp pointer를 다음 노드를 가리키게 함</li>\n<li>tmp의 데이터를 현재 노드로 복사</li>\n<li>tmp 노드의 next를 현재 노드의 next가 가리키게 함</li>\n<li>tmp 노드 free</li>\n</ol>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/\">Linked List에서 동일한 메모리 위치에 다음 주소와 이전 주소를 모두 저장하는 방법 (XOR Linked List)</a></li>\n</ul>\n<blockquote>\n<p>pre와 next 주소를 XOR bitwise 하여 저장</p>\n</blockquote>\n<ul>\n<li>Stack 구현</li>\n</ul>\n<blockquote>\n<p>Stack은 LIFO(Last In First Out) 방식 자료구조이다.\ntop 변수를 통해 최상단의 데이터 위치를 추적함. (default -1)\npush일 때마다 1씩 증가, pop일 때마다 1씩 감소</p>\n</blockquote>\n<ul>\n<li>Queue를 사용해서 Stack을 구현하는 방법</li>\n</ul>\n<blockquote>\n<p>Main Queue와 Sub Queue 2개를 사용한다.\nPush가 일어날 때, Main Queue에 데이터가 있다면 모두 Dequeue해서 Sub Queue로 넣는다.\n이후 Main Queue에 data를 push한 후, Sub Queue에 있는 data들을 모두 deQueue해서 Main Queue로 다시 넣어준다.\nPop이 일어날 때, Main Queue에 있는 것을 deQueue해준다.</p>\n</blockquote>\n<ul>\n<li>Stack을 사용해서 Queue를 구현하는 방법</li>\n</ul>\n<blockquote>\n<p>In-Queue Stack과 Out-Queue Stack을 2개 사용한다.\nPush이 일어나면 In-Queue Stack에 data를 push한다.\nPop이 일어나면 In-Queue Stack의 모든 data를 Out-Queue Stack으로 옮긴다.\n이후 Out-Queue Stack을 pop</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://www.techiedelight.com/find-diagonal-sum-given-binary-tree/\">Binary Tree의 대각선 합 코딩</a></p>\n</li>\n<li>\n<p>Tree Traversal의 모든 유형</p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>In-order(Infix): left - root - right</li>\n<li>Pre-order(Prefix): root - left - right</li>\n<li>Post-order(Postfix): left - right- root</li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/\">row-wise와 column-wise로 정렬된 행렬에서 검색하는 방법</a></li>\n</ul>\n<blockquote>\n<p>Key idea : 요소를 찾을 때까지 각 비교에서 행이나 열을 제거하는 것. top-right 모서리부터 시작.\n가능한 케이스는 다음 3가지:</p>\n<ol>\n<li>주어진 숫자가 현재 숫자보다 클 경우: 현재 column의 왼쪽 column 모두 제거</li>\n<li>주어진 숫자가 현재 숫자보다 작을 경우: 헌재 row의 아래쪽 row 모두 제거</li>\n<li>똑같을 경우: search 종료</li>\n</ol>\n</blockquote>\n<ul>\n<li>Heap의 내부 작업</li>\n</ul>\n<blockquote>\n<p>Push 일 때:</p>\n<ol>\n<li>가장 마치막 위치에 data 삽입</li>\n<li>부모 노드와 비교해서 작을 경우 부모와 자리 바꿈, 같은 경우 Stop</li>\n</ol>\n<p>Pop 일 때:</p>\n<ol>\n<li>Root 노드에 저장된 값을 제거</li>\n<li>마지막 노드에 저장된 값을 root 노드로 옮기고 마지막 노드 제거</li>\n<li>root 노드부터 Top-down으로 자식 노드와 비교, left->right 순으로 자신보다 작은 자식노드가 잇을 경우 자리 바꿈, 아닌 경우 Stop</li>\n</ol>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/swap-two-numbers-without-using-temporary-variable/\">temp 변수 없이 int a와 b를 reverse하는 방법</a></li>\n</ul>\n<blockquote>\n<p>Key Idea: 합계 이용하기</p>\n<ol>\n<li>x = x + y</li>\n<li>y = x - y</li>\n<li>x = x - y</li>\n</ol>\n</blockquote>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/third-largest-element-array-distinct-elements/\"><strong>배열에서 3번째로 큰 수 찾기</strong></a></li>\n<li>Array에서 첫 번째 최대값과 두 번째 최대값을 찾는 코딩</li>\n</ul>\n<blockquote>\n<p>Key Idea: First, Second, Third 변수를 선언해서 추적</p>\n<ol>\n<li>배열을 순회하며, first보다 큰지 확인 -> 더 큰 경우 first를 update &#x26; first를 second에 &#x26; second를 third에</li>\n<li>first보다 작지만 second보다 크다면, second update &#x26; second를 third에</li>\n<li>first보다 작고 seconde보다 작지만 third보다 크다면, third update</li>\n<li>배열 순회가 끝난 뒤, 세 번째 값 출력</li>\n</ol>\n</blockquote>\n<ul>\n<li>\n<p><strong>Array에서 중복을 찾을 수 있는 최적화된 코드 (QuickSort)</strong></p>\n</li>\n<li>\n<p>Longest Palindromic Substring(가장 긴 회문 부분 문자열)</p>\n</li>\n<li>\n<p>Longest Bitonic Subsequece(가장 긴 bItonic 부분 시퀀스) 코딩</p>\n</li>\n<li>\n<p>0-1 sorting하는 모든 방법</p>\n</li>\n<li>\n<p>Sorting 알고리즘의 유형</p>\n</li>\n<li>\n<p>피보나치 수열을 생성하는 모든 방법</p>\n</li>\n</ul>\n<blockquote>\n<p>피보나치: f[i] = f[i-1] + f[i-2]\nRecursive, Iteration, Dynamic Programming, using Fibonachi Matrix</p>\n</blockquote>\n<ul>\n<li>\n<p>IP 주소를 유효성을 확인하는 python 프로그램 코딩</p>\n</li>\n<li>\n<p>특정 알고리즘의 Complexity 분석</p>\n</li>\n<li>\n<p>2개의 정렬된 array을 교집합/합집합</p>\n</li>\n<li>\n<p>backspace 문자 처리 후 두 문자 비교</p>\n</li>\n<li>\n<p>이진수와 정수 N이 주어질 때, if-else 문 없이 bitwise AND와 OR만을 사용해서 N번째 비트를 뒤집는 함수 작성</p>\n</li>\n<li>\n<p><a href=\"https://www.geeksforgeeks.org/count-set-bits-in-an-integer/\">정수에서 2진수 bit의 수를 세는 코드</a></p>\n</li>\n</ul>\n<blockquote>\n</blockquote>\n<ul>\n<li>\n<p>숫자의 마지막 bit 반환</p>\n</li>\n<li>\n<p>숫자가 주어지면 m 위치에서 n 위치로 비트를 추출하여 10진수로 변환</p>\n</li>\n</ul>\n<h2 id=\"research-interview\" style=\"position:relative;\"><a href=\"#research-interview\" aria-label=\"research interview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Research Interview</h2>\n<h3 id=\"1-cloud-computing\" style=\"position:relative;\"><a href=\"#1-cloud-computing\" aria-label=\"1 cloud computing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Cloud Computing</h3>\n<!-- - Cloud 기술은 무엇인가?\n\n- Cloud Computing의 Key 특징은 무엇인가?\n\n- Cloud Delivery Model에는 무엇이 있는가?\n\n- Cloud Deployment Model에는 무엇이 있는가?\n\n- Cloud Computing Architecture에 대해 설명하라\n\n- Cloud의 Storage Level에는 무엇이 있는가?\n\n- Microservice란 무엇인가?\n\n- Cloud-Native Application이란 무엇인가? -->\n<h3 id=\"2-container\" style=\"position:relative;\"><a href=\"#2-container\" aria-label=\"2 container permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Container</h3>\n<ul>\n<li>Container란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>컨테이너란 어떤 환경에서나 소프트웨어 서비스를 실행하기 위해 필요한 모든 요소, 즉 라이브러리와 같은 종속 항목과 애플리케이션 코드를 포함하는 소프트웨어 패키지이다.\n<u>Containers are lightweight software package of application code with dependencies such as libraries required to run in any environment.</u>\n컨테이너는 3가지 커널의 기본 요소로 구성된다. 볼 수 있는 것을 제한하는 Namespace, 사용할 수 있는 리소스 양을 제한하는 Cgroup, 사용자의 행동을 제한하는 LSM Module이 그것들이다.\n<u>Container is made up of three kernel basic elements: Namespaces limit what can be seen, Cgroups limit the amount of resources that can be used, and LSM modules limit user behavior.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- Virtual Machine(VM)과의 차이점은 무엇인가?\n> 컨테이너와 VM은 모두 사용자에게 격리된 환경을 제공한다는 점에서 동일하다. 그러나 컨테이너는 OS 수준에서 가상화되며, VM은 하드웨어 수준에서 가상화됩니다. 따라서 컨테이너는 VM보다 훨씬 더 경량이며, OS 커널을 공유하기 때문에 VM에 필요한 것보다 훨씬 더 적은 메모리를 사용한다.\n> &lt;u>Containers and VMs both provide an isolated environment for users. However, containers are virtualized at the OS level, and VMs are virtualized at the hardware level. Containers are therefore much more lightweight than VMs, and because they share the OS kernel, they use much less memory than the VM needs.&lt;/u>\n\n- 가상화는 어떤 종류가 있는가?\n> 가상화는 3종류가 있다.\n> 첫 번째는 호스트 OS 가상화이며, 물리적 하드웨어 위에 호스트 OS가 존재하며 그 위에 가상화 소프트웨어를 통해 게스트 OS를 제공하는 방식이다. (e.g., VMWare, Virtual Box)\n> 두 번째는 하이퍼바이저 가상화이며, Host OS 없이 하드웨어 위에 하이퍼바이저를 직접 작동시켜, 이 하이퍼바이저 위에 게스트 OS를 제공하는 방식이다.\n    > 참고로 하이퍼바이저는 전가상화(Full Virtualization)과 반가상화(Para Virtualization)으로 나뉜다. 전가상화는 하이퍼바이저가 게스트 OS에서 요청하는 특권 명령을 Trap&amp;Emulate 한거나 Binary Translation하여 호스트 OS에게 전달하는 방식이며, 반가상화는 게스트 OS가 Hyper-call을 통해 하이퍼바이저에게 요청하는 방식이다. \n> 세 번째는 컨테이너 형으로, 하드웨어 레벨에서 OS를 가상화하는 것이 아닌, OS 레벨에서 프로게스를 격리시킴으로써 소프트웨어를 가상화한다.\n> &lt;u>There are 3 types of Virtualization.&lt;/u>\n> &lt;u>The first is host OS virtualizationn, in which a host OS exists on physical HW and a guest OS is provided through virtualization software on top of host OS.&lt;/u>\n> &lt;u>The second is Hypervisor vitualization, which operates a hypervisor directly on HW without a host OS and provides a guest OS on this hypervisor.&lt;/u>\n&lt;u>The third is a container type, which virtualizes software by isolating processes at the OS level rather than virtualizing the OS at the HW level.&lt;/u></code></pre></div>\n<ul>\n<li>하이퍼바이저란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>가상 머신 모니터(VMM)이라고도 불리는 하이퍼바이저란 VM을 생성하고 구동하는 소프트웨어를 말하며, Linux에는 KVM이 포함되어 있다.\n<u>Hypervisor, also called a Virtual Machine Monitor(VMM), is a software that creates and executes VMs, and Linux includes an excellent hypervisor called KVM</u></p>\n</blockquote>\n<ul>\n<li>Container Image란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>컨테이너가 애플리케이션 실행에 필요한 것들을 패키징한 상태를 포착하여 데이터로 남긴 것\n<u>The container captures the packaged the things needed to run the application and leaves it as file.</u></p>\n</blockquote>\n<ul>\n<li>\n<p>Container가 실행되는 단계를 설명하라</p>\n</li>\n<li>\n<p>Container Runtime이란 무엇인가?</p>\n</li>\n</ul>\n<blockquote>\n<p>컨테이너 런타임이란 컨테이너를 실행하는 데 필요한 구성 요소를 실행하고 관리하는 소프트웨어이다.\n<u>The container runtime is the software that runs and manages the components needed to run containers.</u></p>\n</blockquote>\n<ul>\n<li>OCI란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>Open Container Initiative 런타임으로, 컨테이너를 생성하고 실행, 삭제하는 컨테이너의 lifecycle 관리에 중점을 두고 있다.\n<u>As an Open Container Initiative runtimes, they focus on managing the lifecycle of containers like creating, running, deleting containers.</u>\nrunC, crun과 같은 Native runtime과 gVisor, Nabla와 같은 Sandboxed runtime, Kata와 같은 virtualized runtime이 있다.\n<u>There are native runtimes such as runC and crun, sandboxed runtimes such as gVisor and Nabla, and virtualized runtimes such as Kata.</u></p>\n</blockquote>\n<ul>\n<li>CRI란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>Container Runtime Interface 런타임으로, 컨테이너 오케스트레이션을 위한 컨테이너 런타임으로써, 이미지 관리 및 배포, 저장, 스냅샷, 네트워킹과 같이 컨테이너를 생성하는데 집중하는 OCI 런타임과 달리 컨테이너를 활용하는데 필요한 기능을 가지고 있으며, 실제로 CRI는 컨테이너 실행을 위한 부분은 OCI 런타임에게 위임한다. containerd와 cri-o가 있다.\n<u>As a Container Runtime Interface runtime, they are container runtimes for container ochestration. Unlike the OCI runtimes, which focuses on creating containers, they have funtions necessary to utilize containers such as image management and distribution, storage, snapshots, and networking. In fact, CRI delegate the part for container execution to the OCI runtimes. There are container-d and cri-o.</u></p>\n</blockquote>\n<ul>\n<li>Docker란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>도커는 컨테이너를 만들고 사용할 수 있도록 도와주는 도구 모음인 컨테이너 엔진이다.\n<u>Docker is a container engine which is a tool set that allows people to create and use container.</u>\n도커는 CRI와 OCI를 둘 다 (containerd + runC) 사용하며, CRI 또는 OCI 사양의 범위를 벗어나는 이미지 building 및 signing과 같은 추가 기능을 제공한다.\n<u>Docker uses both CRI and OCI (containerd+runC) and provides additional features such as image building and signing that are outside the scope of the CRI or OCI specifications.</u></p>\n</blockquote>\n<ul>\n<li>Kubenetes란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>다중 서버에서 컨테이너 운영 자동화와 오케스트레이션을 제공하는 툴이다.\n<u>It is a tool that provides automation and orchestration of container operations across multiple servers.</u></p>\n</blockquote>\n<ul>\n<li>gVisor에 대해 설명하라</li>\n</ul>\n<blockquote>\n<p>gVisor는 Sanboxed 컨테이너 런타임으로, Senty와 Gofer라는 애플리케이션을 통해 유저 공간에서 호출하는 시스템콜을 호스트 커널 대신 처리하여 Host OS의 Attack Surface를 줄이는 기술이다.\n<u>gVisor is a sanboxed container runtime, a technology that reduces the attacks surface of the host OS by processing system calls called from user space through applications called Sentry and Gofer instead of the host kernel.</u></p>\n</blockquote>\n<ul>\n<li>Kata Container에 대해 설명하라</li>\n</ul>\n<blockquote>\n<p>Kata Container는 virtualized 컨테이너 런타임으로, 컨테이너 전용 경량 ㄹ가상 머신을 사용하여 컨테이너 환경을 구현하는 기술이다.\n<u>Kata Container is a virtualized container runtime, a technology that implements a container environment using a lightweight virtual machine dedicated to container.</u></p>\n</blockquote>\n<h3 id=\"3-program-analysis\" style=\"position:relative;\"><a href=\"#3-program-analysis\" aria-label=\"3 program analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Program Analysis</h3>\n<ul>\n<li>컴파일러란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어 혹은 컴퓨터 언어로 옮기는, 일종의 번역 프로그램이다.\n<u>It is a kind of translation program that transfers a file written in a specific high-level programming language to another programming language or low-level computer language.</u></p>\n</blockquote>\n<ul>\n<li>GCC란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>GNU Compiler Collection으로 GNU 프로젝트의 일환으로 개발된 컴파일 드라이버로써, 전처리기, 컴파일러, 어셈블러, 링커를 각각 호출해 주는 역할을 한다.\n<u>GNU Compiler Collection is a compilation driver developed as part of the GNU Project, and it plays a role of calling the preprocessor, compiler, assembler, and linker respectively.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- GCC IR은 무엇인가?</code></pre></div>\n<blockquote>\n<p>전처리가 끝난 <code class=\"language-text\">.i</code> 화장자 파일은 컴파일러를 통해 어셈블리어로 변환되는데, 그 과정에서 Front-end, Middle-end, Back-end로 단계를 나누어 동작하게된다. 이 중간 단계에서 생성되는 결과물들이 바로 IR(Intermediate Representation)이다. 순서대로 GIMPLE IR, SSA IR, RTL IR이 만들어진다.\n<u>The preprocessed <code class=\"language-text\">.i</code> extension file is converted into assembly through the compiler. In this process, it operates by dividing the steps into Front-end, Middle-end, and Back-end. The outputs produced in this intermediate steps are IR(Intermediate Representation). GIMPLE IR, SSA IR, and RTL IR are created in order.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- GCC의 컴파일 단계에 대해 설명하라</code></pre></div>\n<blockquote>\n<p>Front-end 부분에서는 전처리가 끝난 소스코드를 token으로 나누는 어휘 분석 단계, token으로 parse tree를 만들어 문법 오류를 검출하는 구문 분석 단계, parse tree를 문석하여 의미상 오류(e.g., 변수 자료형 불일치)를 검출하는 의미 분석 단계를 거친 후에 프로그래밍 언어 독립적인 GIMPLE Tree를 생성한다.\n<u>In the front-end part, after going thorugh the lexical analysis step of dividing the preprocessed source code into tokens, the syntax analysis step of detecting grammatical errors by creating a parse tree with tokens, and the semantic analysis step of detecting semantic errors(e.g., variable data type mismatch) by analyzing the parse tree, GIMPLE Tree which is independent from programming language is created.</u>\nMiddle-end 부분에서는 GIMPLE 트리를 SSA(Static Single Assignment) 형태로 변환할 후 아키텍처 비종속적인 최적화를 수행한다. 그 후 고급 언어와 어셈블리 언어의 중간 형태인 RTL(Register Transfer Lanugage)를 생성한다.\n<u>In the middle-end part, architecture-independent optimization is performed after converting GIMPLE tree into SSA (Static Single Assignment) form. After that, it creates RTL named as Register Transfer Language, which is an intermediate form between high-level language and assembly language.</u>\nBack-end에서는 RTL optimizer에 의해 아키텍처 비종속적인 최적화 및 아키텍처 종속적인 최적화가 함께 이루어진다. 모든 최적화를 마치게 되면 code generator에 의해 어셈블리 언어로 구성된 <code class=\"language-text\">.s</code> 파일이 만들어진다.\n<u>In the Back-end part, architecture-independent optimization and architecture-dependent optimization are performed together by the RTL optimizer. When all optimizations are completed, <code class=\"language-text\">.s</code> file composed of assembly lanugage is created by the code generator.</u></p>\n</blockquote>\n<ul>\n<li>LLVM은 무엇인가?</li>\n</ul>\n<blockquote>\n<p>LLVM은 modular, 재사용 가능한 컴파일러, 툴체인 기술의 집합체이다.\n<u>LLVM is a collection of modular, reusable compiler and toolchain technologies.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- LLVM IR은 무엇인가?</code></pre></div>\n<blockquote>\n<p>LLVM IR은 아키텍처 비종속 언어로써, LLVM의 컴파일 과정을 Front-end와 Back-end로 나누는 기준이다.\n<u>LLVM IR(Intermediate Representation)is an architecture-independent language, and is a standard for dividing the compilation process of LLM into front-end and back-end.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- LLVM의 컴파일 단계에 대해 설명하라</code></pre></div>\n<blockquote>\n<p>크게 Front-end와 Back-end로 컴파일 단계가 나뉜다. Front-end는 clang, rustc와 같은 컴파일러를 통해 프로그래밍 언어에서 아키텍처 비종속 언어인 LLVM-IR로 변환하는 과정이며, Back-end는 LLVM compiler를 통해 LLVM-IR에서 아키텍처에 맞는 기계어로 변환한다.\n<u>The compilation step is largely divided into front-end and back-end. Front-end is the process of converting from a programming language to LLVM-IR, an architecture-independent language, with compilers such as clang and rustc. Back-end converts LLVM-IR into machine language suitable for the architecture with LLVM compiler.</u></p>\n</blockquote>\n<ul>\n<li>Clang은 무엇인가?</li>\n</ul>\n<blockquote>\n<p>LLVM IR 기반 컴파일러 중 하나로, C C++ 등의 다양한 언어들을 LLVM IR로 컴파일한다.\n<u>As one of the LLVM IR-based compilers, various languages such as C, C++ are compiled to LLVM IR with Clang.</u></p>\n</blockquote>\n<ul>\n<li>GCC와 LLVM의 차이점은 무엇인가?</li>\n</ul>\n<blockquote>\n<p>두 가지 모두 고급 언어를 실행 파일로 바꿔주는 컴파일러이지만, GCC의 경우 각 과정들이 모놀리하게 설계되어 있어, 유지보수가 어려운 반면, LLVM은 GCC의 이러한 문제를 개선하고자 컴파일의 각 과정을 모듈로 제공하기 때문에 유지보수가 쉽다는 장점이 있다.\n<u>Both are compilers, However, in the case of GCC, each compilation process is monolithically designed, making maintenance difficult, whereas LLVM provides each process of compilation as a module to improve GCC’s problem, so it is easy to maintain.</u></p>\n</blockquote>\n<ul>\n<li>컴파일 단계에 대해 설명하라</li>\n</ul>\n<blockquote>\n<p>일반적으로, 소스 코드가 실행 파일이 되기 위해서는 pre-processor를 통한 전처리 단계, compiler를 통한 컴파일 단계, Assembler를 통한 어셈블 단계, Linker를 통한 링킹 단계를 거친다.\n<u>In general, in order for a source code to become an executable file, it goes through a preprocessing stage with a pre-processor, a compilation stage with a compiler, an assembly stage with an assembler, and a linking stage with a linker.</u>\n전처리 단계에서는 전처리기 지시자를 처리한다. 그 결과 <code class=\"language-text\">.i</code> 확장자 파일이 생성된다.\n<u>In the pre-processing stage, pre-precessor directives are processed. As a result, file with the extension <code class=\"language-text\">.i</code> is created.</u>\n컴파일 단계에서는 어셈블리어로 변환한다. 그 결과 <code class=\"language-text\">.s</code> 확장자 파일이 생성된다.\n<u>In the compilation stage, it is converted into assembly. As a result, file with the extension <code class=\"language-text\">.s</code> is created.</u>\n어셈블 단계에서는 기계어로 된 오브젝트 파일로 변환한다. 그 결과 <code class=\"language-text\">.o</code> 확장자 파일이 생성된다.\n<u>In the assembly stage, it is converted into an object file in machine language. As a result, file with the extension <code class=\"language-text\">.o</code> are created.</u>\n링킹 단계에서는 작성한 프로그램이 사용하는 다른 프로그램이나 라이브러리를 가져와서 연결함으로써, 하나의 실행 가능한 파일을 생성한다.\n<u>In the linking stage, single executable file is created by importing and linking other programs or libraries used by the written program.</u></p>\n</blockquote>\n<ul>\n<li>컴파일러 실행 단계에 대해 설명하라</li>\n</ul>\n<blockquote>\n<p>컴파일러는 3단계로, 구문 분석, 최적화, 코드 생성 단계가 있다. 구문 분석 단계에서는 소스 코드 파일을 읽어 추상 구문 트리를 생성하고, 문법을 검사한다. 최적화 단계에서는 추상 구문 트리를 분석하여 최적화한다. 코드 생성 단계에서는 목적 코드를 생성한다.\n<u>A compiler has three stages: syntax analysis, optimizing, and code generation. In the syntax analysis step, the syntax tree is created from the source code file, and the syntax is checked. In the optimization steop, the abstract syntax tree is analyzed and optimized. In the code generation step, object code is generated.</u></p>\n</blockquote>\n<ul>\n<li>\n<p>ftrace는 무엇인가?</p>\n<ul>\n<li>이외 다른 트레이싱 도구는 무엇이 있는가?</li>\n<li>ftrace가 다른 트레이싱 도구들에 비해 가지는 장점이 있는가?</li>\n</ul>\n</li>\n<li>\n<p>동적 분석은 무엇인가</p>\n<ul>\n<li>동적 분석 기법을 아는대로 말해보라</li>\n</ul>\n</li>\n<li>\n<p>정적 분석은 무엇인가</p>\n<ul>\n<li>정적 분석 기법을 아는대로 말해보라</li>\n</ul>\n</li>\n<li>\n<p>동적 분석과 정적 분석의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>라이브러리란 무엇인가?</p>\n</li>\n<li>\n<p>API란 무엇인가?</p>\n</li>\n<li>\n<p>라이브러리 함수란 무엇인가?</p>\n</li>\n</ul>\n<h3 id=\"4-linux-kernel\" style=\"position:relative;\"><a href=\"#4-linux-kernel\" aria-label=\"4 linux kernel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Linux Kernel</h3>\n<ul>\n<li>Kernel이란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>커널은 컴퓨터를 시작할 때 <strong>가장 첫 번째로 로드되는 프로그램</strong>으로써, CPU 하드웨어를 제어하고, 메모리를 할당하고, 데이터에 액세스하고, 프로세스를 스케쥴링하고, 애플리케이션을 실행시키고, 서로 다른 애플리케이션의 실행을 보호하는 역할을 수행하는 운영체제의 매우 특수한 부분을 일컬음\n하드웨어 및 소프트웨어 프로세스를 관리하는 커널 외에도 Linux distribution에는 하드웨어 액세스 및 제어를 위한 device driver, shared libraies, 애플리케이션, 백그라운드에서 실행하면서 네트워크 요청에 응답하는 시스템 데몬과 같은 리눅스 소프트웨어 집합이 포함된다.\n<u>The kernel is the first program loaded on the computer when the computer starts up, and it is the special piece of the operating system that controls the CPU harware, allocates memory, access data, schedules processes, runts the applications, and protects them from each other.</u>\n<u>Linux distributions include collection of Linnux sortware, such as device drivers for accessing and controlling hardware, shared libraries, applications, and system daemons, which run in the background and respond to network requests.</u></p>\n</blockquote>\n<ul>\n<li>Linux Distribution이란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>Distribution은 리눅스 커널의 특정 버전과 함께 해당 커널 버전과 호환되고 상호 운영성 테스트를 거친 다양한 라이브러리, 시스템 데몬, 개발 도구, 애플리케이션, 패키징 및 life-cycle 관리 도구의 조합을 일컫는다.\nLinux Distribution의 예로는 Ubuntu, Debian, Fedora, openSUSE, Cumulus Linux가 있다.\n<u>A distribution is the combination of specific versions of the Linux Kernel with other libraries, system daemons, development tools, applications, packaging, and life-cycle management tools that are compatible with each other and tested for interoperability.</u>\n<u>Exmaples of Linux distributions are Ubuntu, Debian, Fedora, openSUSE, and Cumulus Linux</u></p>\n</blockquote>\n<ul>\n<li>Kernel Space와 User Space의 차이는 무엇인가?</li>\n</ul>\n<blockquote>\n<p>커널 공간과 사용자 공간의 분리는 가능한 한 안정적으로 안전한 운영 체제임을 보장하기 위해 만들어졌다.\n운영 체제는 커널로부터 시스템이 종료되거나 시스템이 충돌나는 것을 방지하기 위해 보호되고 제한된 메모리에서 커널을 실행하는데, 이 공간을 커널 공간이라고 한다.\n사용자가 애플리케이션이나 툴을 실행할때, 이러한 애플리케이션이나 도구가 실행되는 공간을 유저 공간이라고 한다.\n<u>In short, the separation beween user space and kernel space is made to ensure that Linux is as reliable and secure an operating system as possible</u>\n<u>Operating systems executes their kernel in protected and restricted memory that is called kernel space to prevent the kernel from terminating and crashing the system.</u>\n<u>When a user runs an application or tool, that application or tool executes in what is called user space.</u></p>\n</blockquote>\n<ul>\n<li>시스템콜이란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스를 대신하여 하드웨어에 접근해서 필요한 기능을 프로세스가 사용할 수 있도록 해주는 인터페이스이다.\n<u>It is an interface that enables the user mode to use the funtions of the kernel space, that is, to access the HW on behalf of the process so that the process in user space can use the necessary functions in kernel space.</u></p>\n</blockquote>\n<h3 id=\"5-research---security\" style=\"position:relative;\"><a href=\"#5-research---security\" aria-label=\"5 research   security permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Research - Security</h3>\n<ul>\n<li>Malware란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>Malware is Malicious Software. There are warm, Trojan Horse, Smishing, Ransomware.</p>\n</blockquote>\n<ul>\n<li>Exploit이란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>Exploit is a type of Malware and it is an attack which uses the software vulnerability to perform malicious behavior like privilege esaclation, DoS.</p>\n</blockquote>\n<ul>\n<li>Malware와 Exploit의 차이점은?</li>\n</ul>\n<blockquote>\n<p>Malware가 Exploit을 포함하는 개념이다. 즉, Malware는 악성 행위를 포함하는 모든 소프트웨어를 일컫고, Exploit은 Malware의 한 종류로써 SW의 취약점을 이용해서 악성 행위를 하는 공격이다.\n<u>Malware is a concept that includes exploits. In other words, Malware refers to all software including malicious behavior, and Exploit is a type of Malware and it is an attack which uses hte vulnerability of Software to perform malicious behavior.</u></p>\n</blockquote>\n<ul>\n<li>Vulnerability란 무엇인가?</li>\n</ul>\n<blockquote>\n<p>시스템에 손실, 손상의 원인을 줄 수 있는 보안 상의 약점\n<u> A security weakness that could cause loss or damage to the system.</u></p>\n</blockquote>\n<ul>\n<li>\n<p>CVE란 무엇인가?</p>\n</li>\n<li>\n<p>Seccomp란 무엇인가?</p>\n<ul>\n<li>Seccomp와 Seccomp-BPF의 차이점은 무엇인가?</li>\n</ul>\n</li>\n<li>\n<p>Container Escape/Break-Out이 무엇인가?</p>\n</li>\n<li>\n<p>Container 환경에서 Threat Model은 무엇이 있는가?</p>\n</li>\n<li>\n<p>BPF-LSM이란 무엇인가?</p>\n<ul>\n<li>KRSI와 BPF-LSM의 차이점은 무엇인가?</li>\n</ul>\n</li>\n<li>\n<p>LSM이란 무엇인가?</p>\n<ul>\n<li>\n<p>AppArmor와 SELinux의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>LSM Hook이란 무엇인가?</p>\n</li>\n</ul>\n</li>\n<li>\n<p>MAC과 DAC의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>eBPF란 무엇인가?</p>\n</li>\n<li>\n<p>Security Policy란 무엇인가?</p>\n</li>\n<li>\n<p>Libbpfgo란 무엇인가?</p>\n</li>\n<li>\n<p>BTF란 무엇인가?</p>\n</li>\n<li>\n<p>CO-RE란 무엇인가?</p>\n</li>\n<li>\n<p>BPF Map이란 무엇인가?</p>\n</li>\n<li>\n<p>bpfbox에 대해 설명해달라</p>\n</li>\n<li>\n<p>bpfcontian에 대해 설명해달라</p>\n</li>\n<li>\n<p>bpfbox와 bpfcontain의 차이점은 무엇인가?</p>\n</li>\n<li>\n<p>KubeArmor에 대해 설명해달라</p>\n</li>\n<li>\n<p>bpfbox, bpfcontainer과 KubeArmor의 차이점은 무엇인가?</p>\n</li>\n</ul>\n<h3 id=\"6-research---data-analysis\" style=\"position:relative;\"><a href=\"#6-research---data-analysis\" aria-label=\"6 research   data analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Research - Data Analysis</h3>\n<ul>\n<li>\n<p>N-gram이란 무엇인가</p>\n</li>\n<li>\n<p>Word Embedding이란 무엇인가</p>\n<ul>\n<li>Word embedding 기법을 아는대로 말해보라</li>\n</ul>\n</li>\n<li>\n<p>GSP 알고리즘을 설명하라</p>\n</li>\n</ul>\n<blockquote>\n<p>Sequence Data에 대한 패턴 매칭 알고리즘이다.\n이 알고리즘은 주어진 시퀀스 데이터에서 일정 길이의 패턴 후보를 생성하고, 각 패턴 후보의 빈도를 구하여, 일정 빈도 이상이 될 경우, 패턴으로 인식하는 알고리즘이다. 2부터 1씩 길이를 늘려가며 패턴을 매칭하는데, 이 때 후보는 이전 패턴의 조합을 통해 생성된다.\n<u>It is a pattern matching algorithm for sequence data. This algorithm generates pattern candidates of a certain length from given sequence data, finds the frequency of each pattern candidate. If the frequency exceeds a certain frequency, this algorithm recognizes it as a pattern. Patterns are matched by increasing the length by 1 from 2, and at this time, a candidate is created through a combination of previous patterns.</u></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- GSP 알고리즘 이외에 패턴 매칭(mining) 알고리즘을 말해보라</code></pre></div>\n<blockquote>\n<p>Sequence Pattern Matching 알고리즘은 크게 String mining과 itemset mining으로 나눌 수 있다. Itemset Minig에는 GSP와 Apriori 알고리즘이 있다. …</p>\n</blockquote>\n<ul>\n<li>TF-IDF란 무엇인가\n<ul>\n<li>다른 IR 기법은 무엇이 있는가?</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://www.interviewbit.com/cloud-computing-interview-questions/\">https://www.interviewbit.com/cloud-computing-interview-questions/</a></li>\n<li><a href=\"https://velog.io/@jeon3029/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B3%B5%ED%95%99-CS-%EA%B3%B5%EB%B6%80%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EB%A7%81%ED%81%AC%EB%8B%A8%EC%88%9C-%EB%A7%81%ED%81%AC-%EB%AA%A8%EC%9D%8C\">https://velog.io/@jeon3029/컴퓨터-공학-CS-공부를-위한-유용한-링크단순-링크-모음</a></li>\n<li><a href=\"https://www.actualtechmedia.com/wp-content/uploads/2017/12/CUMULUS-NETWORKS-Linux101.pdf\">https://www.actualtechmedia.com/wp-content/uploads/2017/12/CUMULUS-NETWORKS-Linux101.pdf</a></li>\n<li><a href=\"https://cloud.google.com/learn/what-are-containers\">https://cloud.google.com/learn/what-are-containers</a></li>\n</ul>\n<script src=\"https://utteranc.es/client.js\"\n        repo=\"sominsong/sominsong.github.io\"\n        issue-term=\"pathname\"\n        label=\"Comment\"\n        theme=\"github-light\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#0-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\">0. 들어가기 전에</a></p>\n</li>\n<li>\n<p><a href=\"#common-cs-interview\">Common CS Interview</a></p>\n<ul>\n<li><a href=\"#1-os\">1. OS</a></li>\n<li><a href=\"#2-network\">2. Network</a></li>\n<li><a href=\"#3-dsa-data-structure--algorithm\">3. DSA (Data Structure &#x26; Algorithm)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#research-interview\">Research Interview</a></p>\n<ul>\n<li><a href=\"#1-cloud-computing\">1. Cloud Computing</a></li>\n<li><a href=\"#2-container\">2. Container</a></li>\n<li><a href=\"#3-program-analysis\">3. Program Analysis</a></li>\n<li><a href=\"#4-linux-kernel\">4. Linux Kernel</a></li>\n<li><a href=\"#5-research---security\">5. Research - Security</a></li>\n<li><a href=\"#6-research---data-analysis\">6. Research - Data Analysis</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 16, 2022","title":"CS 면접 대비","categories":"Interview","author":"Mini","emoji":"📚"},"fields":{"slug":"/Interview/CS_Interview/"}},"site":{"siteMetadata":{"siteUrl":"https://sominsong.github.io","comments":{"utterances":{"repo":"sominsong/sominsong.github.io"}}}}},"pageContext":{"slug":"/Algorithm/Shortest_Path/","nextSlug":"/Algorithm/Graph/","prevSlug":"/Interview/CS_Interview/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}